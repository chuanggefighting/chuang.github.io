---
title: Javascript 编程范式
tags:
  - Javascript
categories: Javascript
top: false
keywords:
  - js
date: 2019-06-01 21:38:29
description: JS 编程：命令式编程、声明式编程、面向对象编程<br/>常用编程：函数式编程、面向切面编程、模块化编程、异步编程
---


# 一、编程范式
> 即某种编程语言典型的编程风格或者说编程方式，它是程序员看待程序的观点，比如面向对象编程的世界中的程序是一系列相互作用的对象、函数式编程的世界中的程序是一个无状态的函数组合序列。需要注意的是，它是编程语言的一种分类方式但并不针对某种编程语言，每种编程语言都有它提倡的范式而且一般可以适用多种范式。


## 分类
> JS 支持的编程范式主要如下


<div align="center"> 
  ![编程范式](/images/js/paradigm.png)
</div> 

### 1.命令式编程
  * 又称过程式（面向过程），需要指出具体过程而让计算机依次执行命令，是一种简单的从上至下完成任务，流水账式的编程风格。
  * 核心是`模块化`，代码编写比较简单，但是依赖外部变量容易影响其它代码，可读性较少，后期的维护成本也较高，不适合复杂程序的设计。


### 2.声明式编程
  <div style="text-indent: 2em">和命令式编程相对立，只需要指出目标而让计算机去考虑如何做，通过函数、推论规则或项重写规则来描述变量关系并让语言编译器采用相应的固定算法从这些关系产生结果。比如 HTML 等文本标记语言、正则表达式、函数式编程。</div>
  <div style="text-indent: 2em">核心是`通过用框架（不变）来处理声明（变化）`。架构师封装不变的部分（编写框架）、配置变化部分（编写配置声明去生成逻辑），需求变更时一般不需要改写框架（声明分析）代码而只需要修改声明的配置即可。它将计算看作推导，能够最大程度的简化并行计算的代码编写。</div>
 

### 3.面向对象编程

  <div style="text-indent: 2em">又称元编程，计算机程序将对象作为程序的基本单元，将程序和数据封装为彼此相关并能够接收、处理和传递数据的对象。它将现实世界的物体抽象成类，每个物体抽象成对象。用继承来维护物体的关系，用封装来描述物体的数据（属性）与行为（方法），通过封装技术、消息机制可以快速开发出一个全新的系统。既可以提高编程效率，又增强了代码的可扩展/维护等灵活性。</div>
  <div style="text-indent: 2em">核心是`抽象，是对命令式编程的一种抽象`（包括数据抽象、过程抽象）。js 面向对象将逻辑与数据封装到函数与原型中，通过函数的原型链拷贝实现继承，而代码的运行逻辑与数据依然封装在函数内，但是做了属性与方法的区分。优秀的面向对象编程显然可以做到声明式编程，即根据声明配置生成结果（面向对象编程的逻辑是预设的，我们可以根据输入条件判断走不同的逻辑）。</div>



## 区别
  * __命令式、声明式__
    * 命令式编程：命令机器如何去做，机器会按照你的命令实现你想要的。
    * 声明式编程：告诉机器你想要的结果是什么，让机器想出如何去做。
  * __声明式、面向对象__
    * 面向对象编程不会根据声明配置去生成逻辑，逻辑的调用是封装在对象中，而不是动态生成。所以并没有做到真正的声明式，也就是数据与逻辑完全分离。
    * 动态生成逻辑，是根据声明，自动完成逻辑的生成，这样就完全可以不用编写业务代码，而仅仅靠声明来完成逻辑的实现，而这部分处理，交给框架处理即可。


  ```js
  // 命令式
  var numbers = [1, 2, 3, 4, 5]
  var doubled = []
  for(var i = 0; i < numbers.length; i++) {
    var newNumber = numbers[i] * 2
    doubled.push(newNumber)
  }

  /*
  * 声明式
  *   map 接受的是一个纯函数；它不具有任何副作用 (不会改变外部状态)
  *   map 函数所做的事情是将直接遍历整个数组的过程归纳抽离出来，让我们专注于描述想要的是什么
  **/
  var doubled = numbers.map (function (n) {
    return n * 2
  })
  console.log(doubled)   // [2, 4, 6, 8, 10]

  // 面向对象
  (function() {
    "use strict";
    var Task = function(nums) {
      this.nums = nums;
    };
  
    Task.prototype.square = function() {
      var squares = [];
      for (var i=0; i<this.nums.length; i++) {
          squares.push(this.nums[i]*this.nums[i]);
      }
      return squares;
    };
    Task.prototype.sum = function(arr) {
      var res = 0;
      for (var i=0; i<arr.length; i++) {
          res += arr[i];
      }
      return res;
    };
  
    var t = new Task([2,4,6]);
    console.log(t.sum(t.square()));  // 56
  }())
  ```


# 二、常用编程模式
> 模块化编程和异步编程内容较多，下面详述

## 函数式编程
> 通过组合纯函数来构建软件，避免状态共享、可变数据及副作用的产生。

### 概念

  * __函数__
    * 指数学中的函数而不是指命令式编程中的函数。
    * 自变量的映射，一个函数的值仅决定于函数参数的值而不依赖其他状态。
  * __纯函数__
    * 相同的输入永远会得到相同的输出的一种函数。它没有任何可观察的副作用，不依赖、不改变外部状态。
    * 比如 slice 不会改变调用它的数组而是纯函数，splice 则会永久改变调用它的数组而不符合条件。
  * __变量和表达式__
    * 变量：指一个值的名称而不是命令式编程中的变量（存储状态的内存单元）。变量值是不可变的。
    * 表达式：一个单纯的运算过程，而且总是有返回值。函数式编程要求只使用表达式而不使用语句  
    * 语句：执行某种操作而没有返回值，比如命令式编程中的条件语句、循环语句等控制语句。
  * __状态__
    * 程序是拥有状态的。程序执行到断点时就停留在了某个状态，它包括了当前定义的全部变量和一些当前系统的状态，比如打开的文件、网络的连接、申请的内存等。具体保存的信息和语言有关系。
    * 程序通过状态不断推进直至目标。函数式编程强调无状态并不是不保存状态，而是强调将状态锁定在函数的内部，不依赖于外部的任何状态。准确点说，它是通过函数创建新的参数或返回值来将保存程序的状态全部完全保存到栈上。
  * __函数柯里化__
    * 柯里化：将一个低阶函数转换为高阶函数的过程
    ```js
    // 柯里化之前
    function add(x, y) {
        return x + y
    }
    add(1, 2)

    // 柯里化之后
    function addX(y) {
        return function (x) {
            return x + y
        }
    }
    addX(2)(1)
    ```
  * __函数组合__
    * 不使用所要处理的值，只合成运算过程。
    * 为了解决函数嵌套过深，比如洋葱代码：h(g(f(x)))。我们需要通过函数组合一起来用柯里化来优化，让多个函数像拼积木一样。
    ```js
    const compose = (f, g) => (x => f(g(x)))
    var first = arr => arr[0]
    var reverse = arr = arr.reverse()
    var last = compose(first, reverse)
    last([1, 2, 3, 4, 5])      // 5
    ```
  

### 特性

  * __高阶函数__：参数为函数或返回值为函数的函数。它提供了一种函数级别上的依赖注入（或反转控制）机制，可以将复用的粒度降低到函数级别。
  * __闭包__：在形式上就是一个函数内部定义另一个函数，函数的堆栈在在函数返回后并不释放，可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。
  * __访问权限控制__：JS 中的作用域
  * __延长变量生命周期__：在面向对象语言里，函数内的变量都是在栈上分配的，函数调用完成后，栈销毁，变量的生命周期结束。而对象是在堆分配的，会常驻内存，除非被手动或自动回收掉。
  * __函子 Functor__
    * 遵守一些特定规则的容器类型，任何具有 map 方法的数据结构都可看作它的实现。
    * 它是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数。


### 优点
> 由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是不变性带来的。

  * __引用透明__：指函数的运行不依赖于外部变量或状态。没有可变的状态而只依赖于输入的参数，只要参数相同则引用函数所得到的返回值都是相同的。其它语言的函数返回值一般与系统状态有关。这样很不利于观察和理解程序的行为。
  * __没有副作用__：副作用指函数内部与外部互动而产生运算以外的其他结果。
  * __无锁并发__：没有副作用使得函数式编程各个独立的部分的执行顺序可以随意打乱。（多个线程之间）不共享状态，不会造成资源争用，则不需要用锁来保护可变状态，也就不会出现死锁，这样可以更好地进行无锁的并发操作。
  * __惰性求值__：在将表达式赋值给变量（或称作绑定）时并不计算表达式的值，而在变量第一次被使用时才进行计算。这样就可以通过避免不必要的求值提升性能。



## 面向对象编程

### 对象特点
  * 抽象：抓住核心问题
  * 封装：只能通过对象来访问方法
  * 继承：从已有对象上继承出新的对象
  * 多态：多对象的不同形态


### 类的定义
  * __工厂模式__：解决了重复实例化多个对象的问题，但是不能识别各自的实例化对象
  * __构造函数模式__：把函数当作一个类，实例化时它会隐式创建一个空对象并最后返回
    * 建议首字母大写以区分普通函数
    * 实例化的对象可以通过 instanceof 判断它的实例
  * __原型模式__：好处是可以让 `所有对象实例` 共享 `原型对象` 所包含的属性和方法
  * __混合模式__：可变属性写入构造函数，固定属性和方法写入原型对象，这样可以节省内存 


  ```js
  // 工厂模式
  function person(name, age){
      var obj = {};     // 原料
      obj.name = name;  // 加工
      obj.age = age;    
      obj.say = function(){ 
        console.log(this.name)    
      }
      return obj     
  }
  var p1 = person("tom", 18);


  // 构造函数模式
  function Person(name, age){     // 类：模具
      this.name = name;  
      this.age = age;    
      this.say = function(){ 
        console.log(this.name)    
      }  
  }
  var p2 = new Person("tom", 20);  // 实例化对象：产品
  console.log(p2 instanceof Person);


  // 原型模式
  function Person(){  }
  Person.prototype.name = "tom";
  Person.prototype.age = 24;
  Person.prototype.say = function(){
      console.log(this.name) 
  }
  var p3 = new Person()


  // 混合模式
  function Person(name, age){
      this.name = name;   
      this.age = age;   
  }
  Person.prototype.say = function(){
      console.log(this.name);
  }
  var p4 = new Person();
  ```



## 面向切面编程
> 无侵入地将一个函数插入到另一个函数的前面或后面

<div style="text-indent: 2em">主要功能是将日志统计、异常处理等一些跟核心业务逻辑模块无关的功能抽离出来并封装，然后动态插入到业务逻辑模块的指定位置。这样不仅简化了业务逻辑模块，而且方便统一管理功能模块。AOP 其实只是 OOP 的补充，OOP 从横向上区分出一个个的类，AOP 则从纵向上向对象中加入特定的代码。常用场景如下：</div>

  * 防止 window.onload 被二次覆盖
  * 给 Ajax 请求动态添加参数
  * 统计函数的执行时间
  * 分离表单请求和校验
  * 职责链模式
  * 组合替代继承


  ```js
  // before 切面：让一个函数在另一个函数之前执行
  Function.prototype.before = function(fn) {
      var _self = this;     // 保存原函数引用
      return function(){
        fn.apply(this, arguments)   // 执行新函数，修正 this
        return _self.apply(this, arguments);  // 执行原函数
      }
  }

  // after 切面：让一个函数在另一个函数之后执行
  Function.prototype.after = function(fn) {
    var _self = this;
    return function(){
      var ret = _self.apply(this, arguments);
      fn.apply(this, arguments);
      return ret;
    }
  }

  var obj = {
    name: 'tangdy',
    getName: function(){
      console.log(this.name);
    }
  }

  obj.getName = obj.getName.before(function(){
      console.log("before")
  }).after(function(){
      console.log("after")
  });
  obj.getName();
  ```


## 事件驱动编程
> 命令式编程的代码本身给出了程序执行的顺序，但事件驱动程序中的许多代码可能在完全不可预料的时刻被执行 (由用户与正在执行的程序的互动激发导致)。常用于用户与程序的交互，常用于 GUI (图形用户界面) 编程应用通过图形用户接口（鼠标、键盘、触摸板）进行交互式的互动，也可以用于异常的处理和响应用户自定义的事件等。实现事件驱动需要考虑事件定义、事件触发、事件转化、事件合并、事件排队、事件分派、事件处理、事件连带等实际问题，属于事件驱动的编程语言有：VB、C#、Java、Node.js 等。

  * 事件：通知某个特定的事情已经发生（事件发生具有随机性） 
  * 事件与轮询：轮询行为是一种无休止地观察和判断的行为方式。而事件是静静地等待事情的发生
  * 事件处理器：对事件做出响应时所执行的一段程序代码，使得程序能够对于用户的行为做出反映



# 三、模块化编程

<div style="text-indent: 2em">早期引用 JS 文件时直接通过 script 即可，但是随着项目的复杂度越来越大，这种方式带来了 逻辑混乱、可维护性差等问题。为了编写可维护的代码，我们采用将代码合理拆分到不同的文件里，每一个文件就是一个模块，文件路径就是模块名，这种组织代码的方式就是模块化。</div> 

## 优势
  * 开发效率高，有利于多人协同开发
  * 解决项目中的全局变量污染的问题
  * 功能单一，方便代码的复用和维护
  * 解决文件依赖问题，无需关注文件引用顺序


## JS 环境
  * 服务器端
    * 相同的代码需要多次执行
    * CPU 和内存资源是瓶颈
    * 加载时从磁盘中加载
  * 浏览器端
    * 代码需要从一个服务器端分发到多个客户端执行
    * 带宽网络是瓶颈
    * 加载时需要通过网络加载


## 发展进程
  1. 命名空间形式的代码封装 (函数封装)
  2. 通过 立即执行函数(IIFE) 创建的命名空间
  3. 服务器端运行时 Nodejs 的 CommonJS 规范
  4. 将模块化运行在浏览器端的 AMD/CMD 规范
  5. 兼容 AMD 和 CommonJS 的 UMD 规范
  6. 通过语言标准支持的 ES Module

  ```js
  // 命名空间
  function square(x) {
      if(typeof x !== "number") return;
      return x * x;
  }
  var utils = {
      add: function(x, y) {
          return x + y
      }
  }

  // IIFE
  var module = (function(){
      var count = 0;
      return {
          inc: function(){
              count += 1;
          },
          dec: function(){
              count += -1;
          }
      }
  })()
  module.inc();
  ```


## CommonJS
> 服务器端的模块化开发规范，主要特点是 同步加载模块，Nodejs 的模块规范就是参照它实现的

<div style="text-indent: 2em">CommonJS 会在启动时把内置模块和加载过的模块放在本地硬盘，文件读取时不受限于网络而等待时间很短，所以在 Node 环境中使用同步加载的方式不会有很大问题。但是 CommonJS 如果应用在浏览器端，同步加载的机制会使得 JS 阻塞 UI 线程，造成页面卡顿，网速不好时还会导致浏览器假死。</div> 


### 模块定义
<div style="text-indent: 2em">为了方便，NodeJs 为每个模块提供一个 exports 变量指向 module.exports，相当于在每个模块头部执行 `var exports = module.exports`。exports 默认是个空对象，可以添加属性和方法但不能被赋值，因为这样会切断了两者联系，而且不能导出需要new实例化的类。使用时建议 module.exports 导出对象和类、exports 导出普通函数和变量</div> 

  * 一个单独的文件就是一个模块
  * 每个模块都是一个单独的作用域
  * 每个模块内部都有一个 module 对象来代表当前模块
  * 暴露模块中的内容可以通过 module.exports、exports 
    

### 模块加载
  * 本质：读取模块内部的 module.exports 变量
  * 特点
    * 缓存结果：模块第一次加载并执行之后就会缓存结果，再次加载时就会直接读取缓存结果，想要再次运行则必须清除缓存
    * 同步加载：模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行
  * 方法
    * require()：当前模块中读取其它模块并执行
    * require.resolve()：解析模块标识符的绝对路径

### 模块标识
> require() 的参数，require 会根据其格式使用不同的路径加载原则去寻找模块文件

  * 模块名：符合小驼峰命名的字符串
    * 核心模块：系统安装目录
    * 安装模块：node_modules 目录
  * 绝对路径：以 "/" 开头
  * 相对路径：以 "./" 开头


  ```js
  // 导出一个要实例化的类  module.exports = exports = function (){ }

  // rocker.js 
  module.exports = function(name, age) {
      this.name = name;
      this.age = age;
      thisl.about = function() {
          console.log(this.name + 'is' + this.age + 'years old');
      };
  };

  // 引用
  var Rocker = require('./rocker.js')
  var r = new Rocker('Ozzy', 62)
  r.about()   // Ozzy is 62 years old


  // 导出一个静态类 exports.funcName = function (){}

  // hello.js
  function hello() {
      console.log('Hello, world');
  }
  function greet(name) {
      console.log('Hello, ' + name + '!');
  }
  // 写法一
  module.exports = {
      hello: hello,
      greet: greet
  }
  // 写法二
  exports.hello = hello;
  exports.greet = greet;
  // 错误写法
  exports = {
      hello: hello,
      greet: greet
  }

  // 引用
  var hello = require('./hello.js')
  hello.hello()  // Hello, world
  ```


## AMD
> 异步模块定义，浏览器端模块化开发规范。它允许异步和按需加载模块，requireJS 是参照它实现的

### 特点
  * 异步加载方式，模块加载不影响后面语句的运行
    * 实现方式：依赖模块的所有语句都放置在回调函数中并在模块加载完成后执行
    * 解决问题：js 加载时浏览器会停止页面渲染，加载文件越多则页面失去的响应时间越长
  * 管理模块之间的依赖性，便于代码的编写和维护
    * 解决问题：js 文件需要它的被依赖文件早于它加载到浏览器 


### 语法 
  * 模块定义：`define(可选模块标识, 依赖模块数组, 模块初始化要执行的函数或对象)`
  * 模块加载：`require(依赖模块数组, 模块加载成功后的回调函数)`

  ```js
  // 定义模块 myModule.js
  define(['dependency'], function(){
      var name = 'Byron';
      function printName(){
          console.log(name);
      }
      return {
          printName: printName
      };
  });

  // 加载模块
  require(['myModule'], function (my){
  　 my.printName();
  });
  ```


## CMD 
> AMD 基础上改进的一种规范，主要区别是对依赖模块的执行时机处理不同。seaJS 是参照它实现的

### 区别
  * 依赖处理
    * AMD 推崇依赖前置，在定义模块时就要声明其依赖的模块 
    * CMD 推崇就近依赖，只有在用到某个模块时再去 require 
  * 方法    
    * AMD API 默认是一个当多个用，比如模块加载分为全局的和局部的 require
    * CMD 推崇职责单一而且简单，比如模块加载只有 seajs.use() 


### 语法
  ```js
  // 定义模块  index.js
  define(function(require, exports, module) {

      // 使用 exports
      exports.name = 'index';
      exports.hello = function() {
          console.log('Hello index');
      };

      // 使用 module.exports
      module.exports = {
          name: 'index',
          hello: function() {
            console.log('index');
          }
      };
  });

  // 加载模块
  seajs.use('index', function(my) {
      my.hello();
  });
  ```


## UMD
> 兼容 AMD 和 commonJS，提出了跨平台的解决方案

  ```js
  // 无导入导出规范，只有如下的常规写法来检测 JS 环境
  (function (root, factory) {
      if (typeof define === 'function' && define.amd) {
          // AMD
          define(['jquery'], factory);
      } else if (typeof exports === 'object') {
          // CommonJS
          module.exports = factory(require('jquery'));
      } else {
          // 挂载到全局：root 即 window
          root.returnExports = factory(root.jQuery);
      }
  }(this, function ($) {
      // 方法
      function myFunc(){ };
      // 暴露公共方法
      return myFunc;
  }));
  ```


## ES Module
> ES6 的最新语法支持规范

<div style="text-indent: 2em">CommonJS 和 AMD 规范都只能在运行时确定依赖。而 ES6 在语言层面提出了模块化方案, ES6 module 模块编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 模块化这种加载称为 编译时加载(异步按需加载)、静态加载。</div> 

  * 导入：`import {模块名A，模块名B...} from '模块路径'`
  * 导出：`export、export default`
  * 异步加载：`import('模块路径').then()`

  ```js
  /* 错误写法 */
  export 1;

  var m = 1;
  export m;

  if (x === 2) {
    import MyModual from './myModual';
  }

  /* 正确写法 */
  export var m = 1;

  var m = 1;
  export {m};

  var n = 1;
  export {n as m};

  var n = 1;
  export default n;

  import('./myModule.js')
  .then(({export1, export2}) => { })

  Promise.all([
    import('./module1.js'),
    import('./module2.js'),
    import('./module3.js'),
  ])
  .then(([module1, module2, module3]) => { })
  ```


# 四、异步编程
  
## 回调函数
  * 实现：作为参数传递到其它函数执行
  * 优点：简单、容易理解和部署
  * 缺点
    * 层层嵌套，不利于代码的阅读和维护
    * 每个任务只能指定一个回调函数
    * 各个部分之间高度耦合，流程会很混乱
    
  
  ```js
  // 把同步操作变成异步
  f1(f2);

  function f1(callback){
  　　setTimeout(function () {
  　　　　　callback();
  　　}, 1000);
  }
  ```
    

## 事件监听
  * 实现：采用事件驱动模式 
  * 优点
    * 容易理解
    * 可以绑定多个事件
    * 每个事件可以指定多个回调函数
    * 可以去耦合，有利于实现模块化
  * 缺点：整个程序变成事件驱动型，运行流程不清晰 
  * 监听函数：on、bind、listen、observe、addEventListener


  ```js
  // f1 执行完成后立即触发 done 事件从而执行 f2
  f1.on("done", f2);

  function f1(){
    setTimeout(function(){
      //f1的代码量
      f1.trigger("done");
    }, 1000)
  }
  ```
 

## 观察者模式
> 即发布订阅模式，它定义了一种一对多的关系

  * 实现：让多个观察者同时对监听某个对象，对象变化会通知多个观察者对象而自动更新
  * 优点
    * 支持简单的广播通信，自动通知所有已经订阅过的对象
    * 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用
    * 页面载入后，目标对象很容易与观察者存在一种动态关联，增加灵活性


  ```js
  // f1 执行完成后向信号中心 jQuery 发布 done 信号，从而引发 f2 的执行
  jQuery.subscribe("done", f2);

  function f1(){
    setTimeout(function(){
      //f1的代码
      jQuery.publish("done");
    }, 1000)
  } 
  ```


## promise 对象
> CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口

  * 实现机制
    * 代理对象：Promise 对象代表一个异步操作
    * 对象状态：只有异步操作的结果，可以决定 Promise 对象的当前状态
    * 回调函数：`then()` 用来注册当 promise 完成或者失败时调用的回调函数
  * 对象状态
    * 三种状态：等待 `pending`、已完成 `fulfilled`、已失败 `rejected`
    * 状态改变：只能从 pending 转变为 fulfilled/rejected，而且状态一旦改变就不会再变
  * 原生方法
    * then：Promise 被 reject 时触发
    * catch：Promise 被 resolve 时触发
    * finally：Promise 一定会被触发 (新特性)
  * 主要优势
    * 解决回调地狱问题
    * 更好地进行错误捕获 
  * 规范图解
    <div align="center">
      ![Promise 规范](/images/web/promise.png)
    </div>   


  ```js
  // 创建实例
  var promise = new Promise((resolve, reject) => {
      resolve()
  })
  promise.then(val => {   // 抛出错误
      console.log(val)
      console.log(1)
  }).then(() => {         // 不会执行
      console.log(111)
  }).catch(error => {     // 接收错误
      console.log(error)
  }).then(() => {         // 继续执行
      console.log(333)
  }).finally(() => {
      // 一般用于结束动画等
  })


  // 语法糖
  Promise.resolve(42).then(value =>{
      console.log(value);
  })  // 等同于
  new Promise(resolve => {
      resolve(42)
  }).then(value => {
      console.log(value)
  })

  Promise.reject(value) // 等同于
  new Promise(function(resolve, reject){
      reject(new Error("出错了"));
  });


  // 合并多个实例
  function timerPromisefy(delay) {
      return new Promise(function (resolve) {
          setTimeout(function () {
              resolve(delay);
          }, delay);
      });
  }
  // 当数组中所有 Promise 对象被 resolve 之后，该方法才执行 
  Promise.all([
      timerPromisefy(1),
      timerPromisefy(10)
  ]).then(function (value) {
      console.log(value);    
  });
  // 任何一个 promise 变为 resolve/reject，程序就停止运行
  Promise.race([
      timerPromisefy(1),
      timerPromisefy(10)
  ]).then(function (value) {
      console.log(value);    
  });


  // 封装 AJAX 实例
  function get(url) { 
      return new Promise(function (resolve, reject) { 
          var req = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP')
          req.open('GET', url, true) 
          req.onload = function () {
              if (req.readyState == 4 && req.status == 200) {
                  resolve(req.response)
              } else {
                  reject(Error(req.statusText))
              }
          }

          req.onerror = function () {
              reject(Error("Network Error"));
          }

          req.send()
      });
  }
  get("http://something").then(function (response) {
      console.log(response);
  }).catch(function (error) {
      console.log(error);
  })


   // 图片加载完成后播放音乐
  this.loadImg([img, img_1, img_2_1, img_2_2]).then(() => {
    setTimeout(() => {
        this.playMusic()
    }, 500)
  })
  const loadImg = (img) => {  
      const isArray = Array.isArray(img)
      // 参数为单个字符串/数组
      if (!isArray) {
          const oImg = new Image()
          oImg.src = img
          return new Promise(resolve => {
              oImg.onload = () => {
                  resolve()
              }
          })
      }
      const arr = []
      img.forEach(val => {
          const oImg = new Image()
          oImg.src = val
          arr.push(new Promise(resolve => {
              oImg.onload = () => {
                  resolve()
              }
          }))
      })
      return Promise.all(arr)
  }
  ```


## async/await 异步函数
> 一个用同步思维解决异步问题的方案，代码简洁而且更符合编写习惯
     
  * async：表示函数是异步的，定义的函数会隐式返回一个 promise 对象
  * await：表示等待后面的异步函数返回结果之后再执行，只能用于 async 函数内部
  
  
  ```js
  // async 异步 
  async function foo() { return "hello" }
  const foo = async function () {}
  const foo = async () => {}

  console.log(foo());  // promise 对象


  // await 等待
  let fun = function (time) {
      return new Promise(function (resolve, reject) {
          setTimeout(function () {
              resolve(); 
          }, time)
      })
  }
  let funAsync_1 = async function () {
      console.log(1)
      await fun(3000)
      console.log(2);
  }
  let funAsync_2 = async function () {
      console.log(3)
      await funAsync_1()
      console.log(4)
  }
  funAsync_2()  // 3、1、2、4


  // 错误处理
  let p = new Promise((resolve, reject) => {
    reject("error")
  })
  async function demo(params) {
    try {
        let result = await p;
    } catch(e) {
        console.log(e);
    }
  }
  demo()   // error


  // 并行处理
  function count(num) {
      return new Promise((res, rej) => {
          res(num)
      })
  }
  // Promise 写法
  count(100).then(res => {
      return count(res + 100);
  }).then(res => {
      return count(res + 100);
  }).then(res => {
      console.log(res);
  })
  // await 写法
  async function demo() {

      // 返回一个值
      let res_1 = await count(100);
      let res_2 = await count(res_1 + 100);
      let res_3 = await count(res_2 + 100);
      return res_3;

      // 返回数组
      return await Promise.all([count(100), count(200)])

  }
  demo().then(res => {
      console.log(res);
  })


  // 循环处理
  function count(num) {
      return new Promise((res, rej) => {
          console.log(num)
          res(num);
      })
  }
  (async (names) => {
      for(let i = 0; i < names.length; i++) {
          await count(names[i])
      }
  })([1, 2, 3])
  ```



