---
title: ES6 ～ ES9 新特性
tags:
  - Javascript
categories: Javascript
top: false
keywords:
  - js
date: 2019-04-04 00:35:46
description: ECMAScript6 ～ 9 常用的新语法规范
---

# 一、ES6

## let const
  * __var__：声明变量或常量
    * 存在变量提升现象：变量可以在声明之前使用，值为 undefined 
    * 没有块级作用域：ES6 之前的 js 只有全局作用域和函数作用域
  * __let__：声明变量
    * 存在暂时性死区：变量在声明之前使用会报错
    * 存在块级作用域：声明的变量只能在其所在的代码块内才能访问
  * __const__：声明常量
    * 存在暂时性死区和块级作用域
    * 常量名建议写成纯大写字母表示
    * 不允许重新赋值，只能在声明时立即初始化


## 字符串

### 字符串拼接
  ```js
  // ES5 
  var name = 'lux'
  console.log('hello' + name)

  // ES6：${}
  const name = 'lux'
  console.log(`hello ${name}`)  // hello lux
  ```


### 多行字符串
  ```js
  // ES5：反斜杠
  var msg = "Hi \
  man
  "

  // ES6：反引号
  const template = `welcome
      to
  world`
  ```


### API
  ```js
  // includes：判断是否包含
  const str = 'hahay'
  console.log(str.includes('y')) // true

  // repeat: 获取字符串重复n次
  const str = 'he'
  console.log(str.repeat(3)) // 'hehehe'
  // 如果带有小数，先进行 Math.floor(num) 处理

  // startsWith、endsWith：判断是否以给定文本 开始、结束
  const str =  'hello world!'
  console.log(str.startsWith('hello'))  // true
  console.log(str.endsWith('!'))        // true
  
  // padStart、padEnd：若字符串不够指定长度则在 头部、尾部 补全
  setInterval(() => {
      const now = new Date()
      const hours = now.getHours().toString()
      const minutes = now.getMinutes().toString()
      const seconds = now.getSeconds().toString()
      console.log(`${hours.padStart(2, 0)}:${minutes.padStart(2, 0)}:${seconds.padStart(2, 0)}`)
  }, 1000)
  ```


## 函数

### 箭头函数
  * 省略 return 关键字
  * 不需要 function 关键字
  * 始终指向当前上下文的 this 对象
  
```js
// 只有一个参数时不需要 ()
let f = n => n  
let f = () => 5 

// 只有一条返回语句时不需要 {}
[1,2,3].map(x => x + 1)

// 返回对象则需要括号包裹
let obj = name => ({"name":name}) 
```


            
### 函数参数
  * 默认参数：定义函数时指定
  * Rest 参数：获取函数的不定参数

```js
// 默认参数
function sum(x=1, y=1){  
  return x + y;  
}

// Rest 参数
function foo(x, ...params){ 
  console.log(params) 
} 

foo(1, 2)      // [2]
foo(1, 2, 3)   // [2, 3]
```


## 对象
  ```js
  // 属性简写：属性名相同
  function people(name, age) {
      return {
          name, age     
      }
  }
  var name = 'bar';
  var user = { name }; // { name: "bar" }


  // 方法简写
  const people = {
    name: 'lux',
    getName () {
        console.log(this.name)
    }
  }

  // 浅拷贝方法
  const target = {}   
  Object.assign(target, { name: 'Lisa' }, { age: 18 })
  ```


## 解构赋值
> 自动提取数组或对象中的值并赋值给变量，要求前后结构相同或包含

  ```js
  // 对象：变量须与属性同名但不分顺序
  let { name, age } = { name: 'lux', age: 20 }
  console.log(`${name}: ${age}`)  // lux : 20

  var {foo} = {bar: 'baz'}
  console.log(foo)           // undefined
  

  // 数组：变量值由其位置决定
  let [x, y] = [1, 2]
  console.log(x, y)     // 1, 2

  let [a, ...b] = [1, 2, 3, 4]

  // 不完全解构
  let [x, y] = [1, 2, 3]

  // 默认值
  [x, y = 'b'] = ['a']    // x='a', y='b'


  // 代码重构：最后一行即可
  var body = request.body
  var username = body.username
  var password = body.password
  const { body, body: { username, password } } = request 
  ``` 


## Spread 扩展运算符 
> Rest 参数的逆运算，用于将数组或对象展开成一系列用逗号隔开的值

  * 合并对象或数组：参数位置不限制
  * 配合解构赋值：必须将参数放到最后，否则报错

```js
// 数组
const color = ['red', 'yellow']
const colorful = [...color, 'green', 'pink']  
const [first, ...colorful] = color  // ['yellow']

// 对象
const user = { name: 'lux', age: 20 }
const userinfo = { ...user, address: 'shanghai' }
const { name, ...userinfo } = user   // {age: 20}
```


## Symbol 类型
> 一种新的原始数据类型，Symbol 值类似于字符串但每一个都表示独一无二的值

  ```js
  // 创建
  var s1 = Symbol();          
  var s2 = Symbol();
  var s3 = Symbol("foo");      // 传入字符串表示描述信息
  var s4 = Symbol.for("foo");  // 有则返回，无则创建

  // 任何两个 Symbol 值都不相等
  console.log(typeof s1, s1 == s2)   // symbol false

  console.log(Symbol.keyFor(s3))     // undefined
  console.log(Symbol.keyFor(s4))     // foo


  // 不能与其他类型的值进行运算，否则会报错
  // var k = s1 + 1

  // 可以转为字符串、布尔值
  var str = String(s1)
  var bl = Boolean(s1)


  // 作为对象属性名：不能使用点操作
  var obj = { [s1]: 'hello' };

  var obj = {}
  obj[s1] = 'hello';

  var obj = {};
  Object.defineProperty(obj, s1, { value: 'hello' });


  // 属性名的遍历
  var sKey = Object.getOwnPropertySymbols(obj)  // 返回Symbol键名
  var aKey = Reflect.ownKeys(obj)               // 返回所有键名
  ```


## for-of 遍历
  * 方式对比
    * forEach：无法跳出循环，即 break、return 命令都不奏效
    * for-in：主要是为遍历对象而设计的，不适用于遍历数组
    * for-of：调用遍历器接口，使用范围较广
  * 使用技巧
    * 类似数组的对象：通过 Array.from 方法转为数组
    * 普通对象
      * 通过 Object.keys 方法将键名生成数组
      * 通过 Generator 函数将对象重新包装

  ```js
  let arrLike = { length: 2, 0: 'a', 1: 'b' };
  for (let x of Array.from(arrLike)) {
      console.log(x)
  }

  let obj = { name: 'Jane', age: 20 };
  for (var key of Object.keys(obj)) {
    console.log(obj[key]);
  }
  ```


## Iterator 遍历器
> 本质是一种有 next() 方法的指针对象，第几次调用就指向第几个成员

### 功能
  * 为各种数据结构提供一个统一的、简便的访问接口（统一）
  * 使得数据结构的成员能够按某种次序排列（按序）
  * 配合 for-of 实现遍历


### 接口
> 本质是一个生成遍历器的函数，不同于 forEach 等遍历方法

  <div style="text-indent: 2em">默认部署在数据结构的 Symbol.iterator 属性，它是当前数据结构默认的遍历器生成函数，执行这个函数就会返回一个遍历器。原生具备 Iterator 接口的数据结构如下：Array、TypedArray、Map、Set、String，只有这些数据结构不需要自定义遍历器生成函数并部署，循环遍历时可以直接通过 for-of 循环或 while 判断对象的 done 属性。</div>

  ```js
  // 原生接口
  let arr = ['a', 'b', 'c'];
  let iter = arr[Symbol.iterator]();
  console.log(iter.next())  // {value: "a", done: false}

  // 自定义接口
  const obj = {
    a: 1,
    b: 2,
    [Symbol.iterator]: function(){
      const that = this;
      let index = 0;
      // 对象属性组成的数组
      const ks = Object.keys(that);
      return {
        next: function() {
          return {
            value: that[ks[index++]],
            done: (index > ks.length)
          }
        }
      }
    }
  }
  for(const v of obj) {
    console.log(v);      // 1
    break;      // 触发 return 
  }
  ```


### 使用场景
> 任何接受数组作为参数的场景都默认调用了遍历器接口，比如 Array.from、Object.keys、Promise.all、Map() 等

  ```js
  // 解构赋值
  let set = new Set().add('a').add('b');
  let [first, ...rest] = set;

  // 扩展运算符
  var str = 'hello';
  [...str] //  ['h','e','l','l','o']

  // yield*
  let generator = function* () {
    yield 1;
    yield* [2,3,4];
    yield 5;
  };
  var iterator = generator();
  iterator.next()
  ```


## Promise 对象
> 处理异步操作的对象，可以通过链式调用的方式来组织代码，让代码更加直观

  ```js
  // 创建promise
  var promise = new Promise(function(resolve, reject) {
      // 进行一些异步或耗时操作
      if ( /* 如果成功 */ ) {
          resolve("Stuff worked!")
      } else {
          reject(Error("It broke"))
      }
  })

  // 绑定处理程序
  promise.then(function(result) {
        console.log(result)
  }, function(err) {
        console.log(err)
  })
  ```


## Generators 函数

### 基础语法
* __定义__
  * function 关键字和函数名之间有一个星号
  * 内部使用 yield 语句，定义不同的内部状态
  * 作为对象属性时可以简写
* __调用__
  * 调用函数会返回一个生成的遍历器对象，并没有执行函数体并返回结果
  * 调用 next 方法分段执行，从上次暂停地方开始直到 yield/return 语句，返回对象的 
  value 值会被赋值为 yield/return 右边的结果
* __原理__
  * 通过 yield 语句实现传出返回对象
  * 通过 next(value) 方法传入参数，参数值将作为上一个 yield 语句的返回值
* __yield 语句__ 
  * 只能用于 Generator 函数内部
  * 如果用于其它表达式中，则必须放到圆括号里面
  * 用作函数参数或放在赋值表达式的右边时，可以不加括号
    
```js
function* foo(){
  yield 100;
  yield 200;
  return 300;
}
let f = foo();				

console.log(f.next());  // { value: 100, done: false }	
console.log(f.next());	// { value: 200, done: false }
console.log(f.next());	// { value: 300, done: true }
console.log(f.next());	// { value: undefined, done: true }
```


### 应用场景
  * 异步编程：将异步操作写到 yield 语句，等到调用 next 方法时再继续执行
  * 控制流管理：执行多步的耗时操作时，通过回调函数或 Promise 方式都不简洁
  * 部署 Iterator 接口：利用 Generator 函数，可以在任意对象上部署 Iterator 接口
  * 作为数据结构：可以返回一系列的值，所以它可以对任意表达式提供类似数组的接口

  ```js
  // 异步操作的同步化表达
  function* loadUI() {
    showLoading();
    yield loadUIDataAsynchronously();
    hideLoading();
  }
  var loader = loadUI();
  loader.next()  // 加载
  loader.next()  // 隐藏
  

  // 控制流管理
  step1(function (value1) {
    step2(value1, function(value2) {
      step3(value2, function(value3) {
        // Do something with value3
      })
    })
  })

  Promise.resolve(step1)
    .then(step2)
    .then(step3)
    .then(function (value3) {
        // Do something with value3
    }, function (error) {})
    .done();

  function* longRunningTask(value1) {
    try {
      var value2 = yield step1(value1);
      var value3 = yield step2(value2);
      var value4 = yield step3(value3);
      var value5 = yield step4(value4);
      // Do something with value4

    } catch (e) {
      
    }
  }


  // 部署 Iterator 接口
  function* iterEntries(obj) {
    let keys = Object.keys(obj);
    for (let i=0; i < keys.length; i++) {
      let key = keys[i];
      yield [key, obj[key]];
    }
  }

  let myObj = { foo: 3, bar: 7 };
  for (let [key, value] of iterEntries(myObj)) {
    console.log(key, value);
  }


  // 作为数据结构
  function doStuff() {
    return [
      fs.readFile.bind(null, 'hello.txt'),
      fs.readFile.bind(null, 'world.txt'),
      fs.readFile.bind(null, 'and-such.txt')
    ]
  }

  function *doStuff() {
    yield fs.readFile.bind(null, 'hello.txt');
    yield fs.readFile.bind(null, 'world.txt');
    yield fs.readFile.bind(null, 'and-such.txt');
  }
  for (task of doStuff()) {
      // task是一个函数，可以像回调函数那样使用
  }
  ```



## Moudle 模块化
  <div style="text-indent: 2em">ES5 不支持原生的模块化，ES6 的 内置模块功能借鉴了 CommonJS、AMD 各自的优点，根据功能将代码封装到不同模块中。每一个模块都有独立的作用域和命名空间，可以防止命名冲突。当前模块通过 export (default) 定义对外暴露的接口，其它模块通过 import 加载对应模块。</div>
      
  * export：对外输出当前模块中的多个变量或函数的接口
    * 通过 export 方式导出时需要加 {}，export default 则不需要
    * 在一个模块中可以有多个 export，但最多只能有一个 export default
  * import：一个模块中加载另一个含有 export 接口的模块
    

  ```js  
  // lib.js 
  let name = 'freddy'
  let sayName = function(name) {
      console.log(name);
  };

  // export 在一个模块中可以多次使用
  export const age = 20;
  export { name, sayName }
  export { name as userName, sayName as say }  // 改变输出的变量名

  // export default：在一个模块中只能输出一次
  export default name;
  export default sayName;  
  export default { name, sayName }  // 输出一个对象


  // main.js

  // 导入部分
  // export 输出的变量名不可改变
  import { name, sayName } from "./lib";  
  import { name as userName } from "./lib";  
  import { userName, say } from "./lib";  // 接收新变量名

  // export default 输出的变量名可以重新自定义
  import userName from "./lib";
  import userObj from "./lib";

  // 将整个模块当作单一对象导入
  import * as userinfo from "./lib";
  ```
        

## class 类的支持
> 关键字有 constructor、extends、super

### 定义类
> 本质是扩充原型，使其所有实例可以访问相应的属性、方法

  ```js
  // ES5 
  (function(){
      // 定义类、构造函数
      function User(name, age){
          this.name = name;
          this.age = age;
      }

      // 定义原型方法
      User.prototype.show = function(){
          console.log('prototype');
      }

      // 定义静态方法
      User.run = function(){
          console.log('static');
      }

      // 暴露接口
      window.User = user;
  })();

  // ES6：构造函数、静态方法、原型方法
  class User {
      // 构造函数：实例化时默认执行
      constructor(name, age){
          // 初始化对象
          this.name = name;
          this.age = age;
      }

      // 原型方法
      show(){
          console.log('prototype');
      }

      // 静态方法
      static run(){
          console.log('static');
      }
  }
  ```


### 继承类
> 本质是延长原型链，将父类的实例置于子类原型链上，使子类的实例可以访问父类及其原型链上的所有属性和方法。

  ```js
  function Father(name, age){  
      this.name = name;
      this.age = age; 
  }
  Father.prototype.show = function(){ }

  // ES5 
  function Son(name, age, address){
      // 继承第一句：让子类实例化的对象具备父类的所有属性
      // Father.apply(this,arguments);
      Father.call(this, name, age);
      this.address = address;
  }
  // 继承第二句：让子类实例化对象具备父类的所有原型方法
  Son.prototype = Object.create(Father.prototype);

  // 继承第三句：找回丢失的构造函数
  Son.prototype.constructor = Son;

  Son.prototype.run = function(){ }


  // ES6 
  class Son extends Father{
      constructor(name, age, address){
          // super 指代整个 prototype/proto 指向的对象
          super(name, age);
          this.address = address;
      }
  }
  ```
 

### getters & setters
> 对某个属性设置存值函数和取值函数，拦截该属性的存取行为

  ```js
  // 只有 getter 没有 setter 时无法进行赋值操作
  class People {
      constructor(name) { //构造函数
          this.name = name;
      }
      get name() {
          return this._name.toUpperCase();
      }
      set name(name) {
          // 对 this.name 赋则会调用 set name 导致无限递归
          this._name = name;
      }
      sayName() {
          console.log(this.name);
      }
  }
  var p = new People("tom");
  console.log(p.name);    // TOM
  console.log(p._name);   // tom
  p.sayName();            // TOM
  ```


# 二、ES7

## 装饰器
> 通过装饰器函数可以对类、类成员 (类的属性或方法) 进行修饰，从而进行一些相关功能定制。函数有三个参数：`target` (类的原型)、`name` (类/属性/方法的名字)、`descriptor` (将传递给 Object.defineProperty)。

### 装饰模式

  * 包装模式：它们都是通过封装其他对象达到设计目的，但是形态有很大区别
    * 适配器模式：比如连接不同数据库时需要包装已有接口而实现适配数据库。类似手机使用转接口来适配插座。
    * 装饰器模式：旨在促进代码复用 (可看作继承)，希望为对象添加额外功能而又不需要改变原有接口。类似手机添加一个外壳而并不影响原有的通话、充电等功能。
  * 应用场景
    * 经典应用：AOP 编程，包括 安全检查、缓存、调试、持久化等。
    * 具体实例：比如日志系统，它的作用是记录系统的行为操作，在不影响原有系统功能的基础上增加记录环节，类似你佩戴了一个智能手环。


### 基础使用

  ```js
  // 装饰类成员
  class Example {
    @log
    add(a, b) {
      return a + b;
    }

    @unenumerable
    @readonly
    name = "alibaba"
  }

  function readonly(target, name, descriptor) {
    descriptor.writable = false;
    return descriptor;
  }

  function unenumerable(target, name, descriptor) {
    descriptor.enumerable = false;
    return descriptor;
  }

  function log(target, name, descriptor) {
    const original = descriptor.value;
    if (typeof original === 'function') {
      descriptor.value = function(...args) {
        console.log(`Arguments: ${args}`);
        try {
          const result = original.apply(this, args);
          console.log(`Result: ${result}`);
          return result;
        } catch (e) {
          console.log(`Error: ${e}`);
          throw e;
        }
      }
    }
    return descriptor;
  }

  const e = new Example();
  e.add(2, 4);
  e.name = 'antd'; // Error


  // 装饰类
  function doge(tar) {
    tar.isDoge = true;
  }
  @doge
  class Dog { }
  Dog.isDoge //  true

  function doge (par) {
    return function (tar) {
      tar.isDoge = par;
    }
  }
  @doge(false)
  class Dog { }
  Dog.isDoge //  false
  ```


### 实际应用
  ```js
  // react、redux 库的结合使用

  // 正常使用
  class ReactComponent extends React.Component { }
  export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);

  // 使用装饰器
  @connect(mapStateToProps, mapDispatchToProps)
  export default class MyReactComponent extends React.Component {}
  ```



## arr.includes
> 判断数组是否包含一个指定值

  * 参数
    * 要搜索的值
    * 搜索的开始索引
  * 区别
    * 返回布尔值，indexOf 返回数值
    * 可用来判断数组是否包含 NaN，而 indexOf 不行
    * 对于数组中的空值，includes 返回 undefined，而 indexOf 不会


  ```js
  var arr = [1, , 3, NaN]
  arr.includes(1)          // true
  arr.includes(1, 1)       // false
  arr.includes(NaN)        // true
  arr.includes(undefined)  // true
  ```


## 求幂运算符 
  ```js   
  // 运算符 **  
  let a = 2
  a **= 3
  a == Math.pow(2, 3) == 2 ** 3   // 8    
  ```
 


# 三、ES8

## async/await
> async 可看作多个异步操作包装成的一个 Promise 对象，await 是 then() 的语法糖
  
### 本质
> async 函数是对 Generator 函数的改进，使用时将它的 星号、yield 分别替换为 async、await 即可，优点如下：

  * 内置执行器：Generator 函数的执行必须依靠 co 模块的执行器，而 async 函数自带
  * 更好的语义：async、await 分别表示函数里有异步操作、需要等待后面表达式
      的执行结果，语义比较清楚
  * 更广的适用性：co 模块约定 yield 命令后面只能是 Thunk 函数或 Promise 对象，
      而 await 命令后面可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。
  * 返回 Promise 对象：可以用 then 方法指定下一步的操作


### 基础使用
  ```js
  login(userName) {
      return new Promise((resolve, reject) => {
          setTimeout(() => {
              resolve('1001');
          }, 600);
      });
  }

  getData(userId) {
      return new Promise((resolve, reject) => {
          setTimeout(() => {
              if (userId === '1001') {
                  resolve('Success');
              } else {
                  reject('Fail');
              }
          }, 600);
      });
  }

  // 不使用 async/await
  doLogin(userName) {
      this.login(userName)
          .then(this.getData)
          .then(result => {
              console.log(result)
          })
  }

  // 使用 async/await
  async doLogin2(userName) {
      const userId=await this.login(userName);
      const result=await this.getData(userId);
  }

  this.doLogin()   // Success
  this.doLogin2()  // Succes
  ```


## SharedArrayBuffer-Atomics
>  用于从共享内存位置读取和写入

* 并行：同时执行多个任务
  * JavaScript 在单线程中执行任务
    * 同步任务直接在单线程中排队执行
    * 异步任务通过回调函数将结果重新放入到单线程等待执行调用
  * Web Worker 引入了多线程并行处理任务
    * 主线程用来与用户互动
    * Worker 线程用来承担计算任务
    * 每个线程的数据都是隔离的，通过 postMessage() 通信
  * WebGL 用于 GPU 计算来并行处理数据
* 并发：在重叠的时间段内执行几个任务
  * SharedArrayBuffer：允许 Worker 线程与主线程共享同一块内存
  * Atomics: 用于处理 worker 共同操作同一内存地址时引起的冲突等问题


## Object.values/entries
  * Object.values：返回自身属性值的数组
  * Object.entries：返回自身属性的键值对的数组
  * Object.getOwnPropertyDescriptors：返回自身属性的描述对象


  ```js
  const obj = { 
    name: "Jine",
    get age() { return '18' }
  }
  Object.values(obj)   // ["Jine", "18"]
  Object.entries(obj)  // [["name", "Jine"], ["age", "18"]]

  Object.getOwnPropertyDescriptor(obj, "name")  // 单个属性
  Object.getOwnPropertyDescriptors(obj)         // 所有属性
  ```


## String.padStart/padEnd
> 用于填补字符串的首部或尾部来达到给定长度，参数为 目标长度和可选的填充字符

  ```js
  "a".padStart(2)         //  a 
  "a".padStart(2, "bc")   // ba
  "a".padEnd(3, "b")      // abb
  ```


# 四、ES9
> 正则命名捕获组、反向断言、Unicode 转义等略过

## 异步迭代
> 允许 async/await 和 for-of 一起使用，以串行的方式执行异步操作

  ```js
  // ES6 同步迭代器
  const items = ['a', 'b'];
  for(const item of items) {
      console.log(item);  // a b   
  }

  // 异步迭代器：返回一个 Promise
  const promises = [
      new Promise(resolve => resolve(1)),
      new Promise(resolve => resolve(2)),
      new Promise(resolve => resolve(3)),
  ]
  async function test() {
      for await (let p of promises) {
          console.log(p);
      }
  }
  test(); //1 ,2 3
  ```



## Promise.finally
> 指定最终一定会执行的逻辑处理

  ```js
  Promise.resolve(42)
    .then(result =>{ })
    .catch(error => { })
    .finally(() => { }) 
  ```







