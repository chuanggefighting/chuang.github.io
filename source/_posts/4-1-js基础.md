---
title: Javascript 主要内容
tags:
  - Javascript
categories: Javascript 
top: false
keywords:
  - js
date: 2019-03-10 00:11:13
description: ECMAScript、DOM、BOM、jQuery
---

# 一、Javascript 
> JavaScript 由对象组成，一切皆为对象

## 组成部分
  * __ECMAScript__：核心，描述了JS的语法和基本对象
  * __DOM__：文档对象模型，处理网页内容的方法和接口
  * __BOM__：浏览器对象模型，与浏览器交互的方法和接口


## 语言特点
  * 解释型的脚本语言：在程序的运行过程中逐行进行解释
  * 语法简单：使用弱类型的变量，对数据类型也没有严格要求
  * 事件驱动：通过事件对用户操作做出响应
  * 跨平台性：不依赖于操作系统，只需要兼容浏览器即可


## 历史演变
  * 始于1995年，前身为网景公司开发的 LiveScript，用来处理 以前由服务端负责的数据验证
  * 后更名为JavaScript，功能演变为：前后端数据交互、页面特效、服务端开发 NodeJS
  * JS 的很多语法和 Java、C# 语法相似，和 Java 毫无关系


# 二、ECMAScript
> 一种根据 ECMA-262 标准制定的通用脚本语言规范，JavaScript 是遵守该标准实现的一种脚本语言


## 变量

### 命名
  * 方法：匈牙利命名法、驼峰命名法
  * 规则
    * 首字符：英文字母、下划线
    * 组成：英文字母、下划线、数字
    * 禁忌：关键字、保留字

### 声明
  * 显式声明：`var 变量名`
  * 错误用法：没有类型、重复声明、隐式声明、不声明直接使用
  * 正确用法：先声明后读写、先赋值后运算


### 作用域
1. 全局变量
  * 包含：在函数外定义的变量，没有使用 var 的变量
  * 调用：任何位置
2. 局部变量
  * 包含：在函数内使用 var 声明的变量，函数的参数变量
  * 调用：当前函数体内
3. 优先级
  * 局部变量 > 同名参数变量 > 同名全局变量
4. 特性
  * 忽略块级用域
    * ES6之前，js的作用域只有 函数作用域和全局作用域
    * ES6中定义了块级作用域，有“暂时性死区”的特性（声明前不可用）
  * 作用域链
    * 内层函数可以访问外层函数的局部变量
    * 外层函数不能访问内层函数的局部变量
  生命周期
    * 全局变量除非被显式删除，否则一直存在
    * 局部变量从声明开始到函数运行完毕或被显式删除
    * 回收机制有 标记清除、引用计数


### 面试题
  ```js
  var obj = {
        say: function(){
            console.log(say)
        }
  }
  obj.say()   // 报错，没有在函数作用域内创建 fn


  var a = 1;
  function test() {
    var a = 2;
    console.log(a);   // 2，遵循就近原则
  }
  test();

  var a = 1;
  function test2() {
    console.log(a);   // undefined，变量提升
    var a = 2;
  }
  test2(); 

  var a = 1; 
  function test3() {
    console.log(a);   // 1，重新赋值而未重新声明
    a = 2;
  }
  test3();

  let b = 1;
  function test4() {
    console.log(b); // 报错，let 不能变量提升
    let b = 2;
  }
  test4();

  function test5() {
    let a = 1;
    { let a = 2; }
    console.log(a);  // 1，console不在块级作用域中
  }
  test5();
  ```


## 数据类型
> 分为原始数据和引用数据，js 变量的类型会根据其所赋值的数据类型来决定

### 基本数据
  * 即原始值：`Number、String、Boolean、undefined、Null`
  * 6 个假值：`0、" "、undefined、null、NaN、false`
  * 存储方式：存储在栈中的简单数据段。js 可按值访问其实际保存的值，复制时则会创建其副本
  * 检测方法：`typeof`
      
### 引用数据
  * 即引用值：`Object`
  * 存储方式：存储在堆中的对象。js按引用访问其值，即访问时先从栈中读取内存地址（大小固定，保存于栈中），然后再找到保存在堆内存中的值。复制时只是复制了地址，两个对象实际指向的都是同一个值。
  * 检测方法：`instanceof`

  
### 栈和堆
  * __栈 stack__：可理解为一个无盖水缸，它会自动分配内存空间和释放。用于存储基本数据类型，具有空间大小固定和先进后出的特点。
  * __堆 heap__：可理解为封闭盒子，动态分配内存，大小不固定而且不会自动释放。用于存储基本数据类型包装起来的类，实际上保存的不是变量本身，而是指向该对象的指针。

### 类型转换
  * 强制转换：`Boolean()、Number()、String()`
  * 普通转换：`parseInt()、parseFloat()、num.toString()`


## 运算符
  * 算术运算符：`+、-、*、/、%、++、--`
  * 赋值运算符：`=、+=、-=、*=、/=`
  * 字符串运算符：`+、+=`
  * 比较运算符：`>、<、>=、<=、==、!=、===、!==`
  * 逻辑运算符：`&&、||、!`
  * 三元运算符：`?:`


## 流程语句

### 循环语句
  * while：`while(条件表达式) { 代码段 }`
  * do-while：`do{ 代码段 } while(条件表达式)`
  * for：`for(循环变量 = 初值; 循环条件; 递增/递减){ 代码段 }`
  * for-in：`for(声明变量 in 对象){ 代码段 }`

### 跳转语句
  * return：终止函数体的运行，并返回一个值
  * break：终止整个循环，不再判断
  * continue：结束本次循环，判断是否执行下次循环

### 选择语句
  * if：`if(条件1){ } else if(条件2){ } else{ }`
  * switch：`switch(条件){ case 1: break; default: break; }`
  * 三元表达式：`var res = x>0 ? 1 : (x=0 ? -1 : 2)`

### 异常处理语句
  * throw：主动抛出异常
  * try：指明需要处理的代码段
  * catch：捕获异常
  * finally：后期处理



## 函数
> 一段可以反复调用的代码块

### 分类
  * 普通函数
  * 构造函数：类，可分为 内置类和自定义类
  * 函数对象：通过 new Function() 创建的对象


  ```js
  // 1、普通函数

  // 函数声明
  function f1(){  } 

  // 函数表达式    
  var f2 = function(){ }  

  // 回调函数 callback：特定条件下调用
  function f(num, callback){   
    if(num == 3){
        callback();
    }
  }

  // 自执行函数 IIFE：独立作用域而不会污染全局环境
  (function(x, y){
      console.log(x + y);
  })(2, 3);
  ;(function(){ 
      console.log(111);
  })();


  // 2-1、内置类
  var f3 = new Function('a','b','c','return a+b');
  console.log(f3.constructor);   // 当前实例所属类


  // 2-2、自定义类
  function Person(name, age){ 
      this.name = name;
      this.age = age;
      return 1;  // return 基本类型则被忽略
      // return { 'Jack': 18 }; // return 引用类型则被返回
  }
  Person.prototype.eat = function(){ };  
  var p = new Person('Tom', 20);  
    

  // 3、函数对象
  var f4 = new Function('str', 'console.log(str)');
  ```


### 调用
  * 函数模式：`fn()`
  * 方法模式：`obj.fn()、绑定 html 标签`
  * 构造器模式：`new`
  * 上下文模式：`call / apply`


  ```js
  function foo(m, n){
      console.log(this);
      return m + n;
  }
  // 函数调用
  var f1 = foo(1, 5);
  // 以 window 为上下文调用
  var f1 = foo.apply(null, [1, 5])
  var f1 = foo.call(null, 1, 5);

  
  var obj = {
      age: 20,
      getAge: function(){
          return this.age;
      }
  }
  // 方法调用
  var f2 = obj.getAge();
  //  以 obj 为上下文调用
  var f2 = obj.getAge.apply(obj);
  var f2 = obj.getAge.call(obj);
  ```


### this 指向

  ```js
  var obj = {
        name: 'tom',
        getName: function () {
            return this.name;
        }
    };
  var obj2 = { name: 'tony' }
  console.log(obj.getName());  // tom，this 指向对象本身
  var getName = obj.getName;
  console.log(getName());      // 空，此时方法中的 this 指向 window 对象
  console.log(getName.apply(obj2))    // tony，this 指向了 obj2 对象
  ```


### apply、call、bind
> 都是用来改变 this 指向

  * call、apply
    * 相同点：功能相同，都是调用一个对象的一个方法并用另一个对象替换当前对象
    * 不同点：参数书写方式不同。第一个参数是 this 要指向的对象，null、undefined 时默认指向 window，后面的参数分别是 call 的参数列表或 apply 的参数数组。
    ```js
    // 基础使用
    var obj = { name: 'linxin' }
    function f(x, y){
        console.log(this.name)   // linxin
    }
    f.apply(obj, [1, 2])
    f.call(obj, 1, 2)


    // 应用场景

    // 1、改变 this 指向
    var obj = { name: 'linxin' }
    function foo(){
        console.log(this.name);
    }
    foo.call(obj);   // linxin

    // 2、借用别的对象的方法
    var Person1  = function(){
        this.name = 'linxin';
    }
    var Person2 = function(){
        this.getname = function(){
            console.log(this.name);
        }
        // 使用 Person1 对象代替 this 对象，所以 Person2 继承了 Person1 的属性和方法
        Person1.call(this);
    }
    var person = new Person2();
    person.getname();  // linxin

    // 3、调用函数
    function fn() {
        console.log('linxin');
    }
    fn.call();  // linxin
    ```
  * call、bind
    * 相同点：都是用来改变this的指向
    * 不同点：call 改变 this 的指向后会再执行函数，bind 改变后不执行函数而会返回一个绑定新 this 的函数。
    ```js
    function f(){
        console.log(this) // 指向this
    }
    var obj = {}

    // 直接调用函数
    f.call(obj)

    // bind 不能调用函数
    var g = f.bind(obj) 
    g()
    ```
  * 常见用法
    ```js
    // 1、利用 call 判断数据类型
    console.log(Object.prototype.toString.call("qq"))        // [Object String]
    console.log(Object.prototype.toString.call(12))          // [object Number]
    console.log(Object.prototype.toString.call(undefined))   // [object Undefined]

    // 2、利用 call 翻转字符串：将字符串转化为数组，通过数组的 reverse 将字符串翻转过来
    var str = "abcdefg";
    var a =  Array.from(str).reverse().join("")  // gfedcba
    var b = Array.prototype.reverse.call(str.split("")).join("")  // gfedcba

    // 3、利用 apply 求最大值：执行 Math.max(1, 2, 3, 5)，然后将内部的 this 改为 arr
    var arr = [2, 6, 8, 3, 4, 56, 889]
    // 第一个 arr 表示让 arr 借用 max 方法，第二个 arr 表示传给 max 的数据
    console.log(Math.max.apply(arr, arr)) 
    ```
 


### 函数前置
<div style="text-indent: 2em">函数声明会被 js解析器 优先读取，有重名的只留一个（变量和函数重名只留函数）。表达式只有在执行该语句时才会被逐行解析，而函数只有在被调用时才执行内部封装的函数体。</div>

  ```js
  f1() 
  var f1 = function(){ }   //报错

  f2() 
  function f2(){ }        // 正常 
  ```


### 函数标识
  * this：指向当前操作对象
  * callee：指向参数集合所属对象
  * prototype：指向函数附带的原型对象
  * constructor：指向创建该对象的构造函数


### 闭包
> 指有权访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数，主要是用来设计私有的方法和变量

<div style="text-indent: 2em">局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量以便反复使用，但又不会造成全局污染。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</div>

  * 特性
    * 函数嵌套函数 
    * 函数内部可以引用外部的参数和变量 
    * 参数和变量不会被垃圾回收机制回收
  * 用途：
    * 数据缓存
    * 封装私有变量
    * 封装自定义插件
    * 实现类和继承

  ```js  
  // 异步获取数据并缓存
  const getList = (function() {
      let data = {};
      const getData = () => {
          return new Promise((resolve, reject) => {
              let packageOptions = {
                  url: '/names',
                  params: {
                      normal: 1
                  },
                  success: function (rsp) {
                      data = rsp.data
                      resolve();
                  }
              };
              ajax(packageOptions);
          })
      }
      // 闭包存储data
      const result = async function (type) {
          if (JONS.stringify(data) === '{}') {
              await getData();
              return data;
          } else {
              return data;
          }
      }
      return result;
  })() 
  getList().then(res => {
      console.log(res);
  })


  // 封装私有变量
  var person = function(){     
      var name = "default";       
        
      return {    
          getName : function(){    
              return name;    
          },    
          setName : function(newName){    
              name = newName;    
        }    
      }    
  }();    
  console.log(person.name);       // undefined    
  console.log(person.getName());  // default  
  person.setName("chuang");    
  console.log(person.getName());  // chuang  
 

  // 封装插件：匿名自执行函数执行完后会立刻释放资源
  ;(function(document) { 
    var obj = {
          setColor: function(id, color) {
            document.getElementById(id).style.color = color;
          }
    }
    window.view = obj;  // 暴露接口
  })(document);
  view.setColor('main','red');


  // 实现类和继承
  function Person(){    
    var name = "default";       
       
    return {    
       getName: function(){    
           return name;    
       },    
       setName: function(newName){    
           name = newName;    
       }    
    }    
  }
  var p = new Person();
  p.setName("Tom");
  console.log(p.getName());
  ```


## 正则表达式
> 使用 `RegExp` 对象表示并由元字符、字符串和量词组成，用于描述字符串的匹配规则

### 创建
  1. 方式
    * 字面量：`/pattern/attributes`，特殊字符不需要转义，不支持字符串拼接
    * 实例化：`new RegExp(“pattern”, “attributes”)`，特殊字符需要转义，支持字符串拼接
  2. 参数
    * pattern：正则表达式
    * attributes：匹配模式，`g、i、m` 分别表示 全局匹配、忽略大小写、多行匹配

  ```js
  var regExp = 'ab';

  // 字面量 
  var reg_1 = /regExp/;
  var reg_1 = /^[a-zA-Z0-9]{3,8}$/;

  // 实例化
  var reg_2 = new RegExp(regExp+'1');
  var reg_2 = new RegExp(“[a-zA-Z0-9]{3,8}”);
  ```

### 基础语法
<div align="center"> 
  ![regExp](/images/js/regExp.png)
</div> 



## 全局对象
> Window 对象，表示允许 JavaScript 代码访问的 Web 浏览器窗口

### 全局函数
  * 编码：`encodeURI、encodeURIComponent、escape`
  * 解码：`decodeURI、decodeURIComponent、unescape`
  * 检测：`isNaN、isFinite`
  * 转换：`eval、String、Number`
  * 解析：`parseInt、parseFloat`

### 全局属性
  * NaN：不是数字值
  * undefined：未定义的值
  * Infinity：正无穷大的数值 


## 计时器
<div style="text-indent: 2em">requestAnimationFrame 采用系统时间间隔来保持最佳绘制效率而不需要手动设置，这样就不会因间隔时间过短而会造成 过度绘制并增加开销，也不会因时间太长则导致 动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</div>

  * __setTimeout__：延时执行指定代码, 取消时使用 clearTimeout
  * __setInterval__：间隔时间重复执行代码, 取消时使用 clearInterval
  * __requestAnimationFrame__：在浏览器每次刷新页面之前执行代码，时间间隔由浏览器刷新频率决定，取消时使用 cancelAnimationFrame

  ```js
  var box = document.getElementById("box");
  var timer = requestAnimationFrame(function step(){
        var width = parseInt(box.style.width);
        if(width < 500){
            box.style.width = width + 10;
            requestAnimationFrame(step);
        }else{
            cancelAnimationFrame(timer);
        } 
  })
  ```



# 三、DOM
> 文档对象模型，用于操作 HTML 和 XML 文档（浏览器内容）的编程接口

## 节点
<div style="text-indent: 2em">DOM 将整个文档（XML文档和HTML文档）看作一个树形结构，并用document对象表示该文档，并规定其中每个成分都是一个节点（Node），JavaScript 通过 DOM API 可以操作到每个节点。</div>

### 节点信息
  * `nodeType`：节点类型
  * `nodeName`：节点名称
  * `nodeValue`：节点值

### 节点类型
  * 文档节点：整个文档
  * 注释节点：文档注释
  * 元素节点：html 标签
  * 文本节点：元素/属性节点中的文本内容
  * 属性节点：元素节点的属性

  <div align="center"> 
    ![节点类型](/images/js/domNodes.png) 
  </div> 


### 文档节点
  * 标签：`document.documentElement/body/forms`
  * 信息：`document.URL/domain/readyState`
  * 方法：`document.write/writeln/open/close`


### 元素节点
> 文本节点、属性节点都属于元素节点的子节点，操作时都需要先获取 元素节点

  1. 获取
    * document
      * `document.getElementById/TagName/ClassName/Name`
      * `document.querySelector [All]`
      * `document.documentElement`
      * `document.body`
      * `document.forms` 
    * 节点指针
      * 父节点：`parentNode`
      * 同级节点：`previousSibling、nextSibling`
      * 子节点：`firstChild、lastChild、childNodes、children`
  2. 操作
    * 创建：`createElement、createAttribute、createTextNode`
    * 插入：`appendChild、insertBefore`
    * 替换：`replaceChild`
    * 复制：`cloneNode`
    * 删除：`removeChild` 
    * 样式：`dom.style.样式名`
      * 样式名必须使用驼峰命名法
      * 修改 class 时必须使用 className
  3. 属性
    * 获取：`getAttribute`
    * 设置：`setAttribute`
    * 移除：`removeAttribute`
  4. 文本
    * 获取：`innerHTML / innerText`
    * 设置：`dom.innerHTML / innerText = "new"`
    * 表单元素：`input.value、input.value = “new”`

 
  ```js
  // 设置元素属性
  var box = document.getElementById("box");
  box.setAttribute("title", "this is box");  
  console.log(box.getAttribute("title"));  
    
  // 创建属性节点
  var placeholder = document.createAttribute("placeholder");
  placeholder.nodeValue = "请输入姓名"; 
  box.setAttributeNode(placeholder);  
  ```


## 事件

### DOM0 级  
> 在 DOM 中直接绑定事件

  * 绑定：`DOM.onclick = function(){ }`
  * 移除：`DOM.onclick = null / ""`
  

### DOM2 级  
> 使用事件监听绑定事件，浏览器监听到用户执行相关操作做出响应

  1. 主流浏览器
    * 绑定：`DOM.addEventListener('click', fn, false)`
    * 移除：`DOM.removeEventListener('click', fn)`
    * 参数：false 时在冒泡阶段执行，true 则在捕获阶段执行
  2. IE8及以下
    * 绑定：`DOM.attachEvent('onclick', fn)`
    * 移除：`DOM.detachEvent('click', fn)`


  ```js
  // DOM0 级事件可能被覆盖：2，3，4
  var box = document.querySelector('#box')
  box.onclick = function() {
      alert(1)
  }
  box.onclick = function() {
      alert(2)
  }
  box.addEventListener('click', function() {
      alert(3)
  })
  box.addEventListener('click', function() {
      alert(4)
  })  
  ```

### 事件流
> 事件的执行顺序

  * 事件冒泡：事件从事件目标元素开始触发，向上触发到最外层的 document 对象
  * 事件捕获：与冒泡相反
  * DOM 事件流：DOM 先捕获到目标元素，然后冒泡到最外层
 

### 事件对象
> 触发 DOM 上的某个事件时会产生一个事件对象 event，它包含着所有与事件有关的信息

  1. 属性：鼠标 / 键盘属性、IE 属性、标准 Event 属性
  2. 方法：stopPropagation、preventDefault
  3. 事件
    * 鼠标事件：`click、dbclick、mousedown、mousemove、mouseout、mouseover、mouseup`
    * 键盘事件：`keydown、keypress、keyup`
    * HTML事件：`load、unload、resize、change、scroll、focus、blur、select、reset、submit`
  
  ```js
    var Event = {

      // 页面加载完成后
      readyEvent: function(fn) {  
          if (fn == null) { 
              fn = document;
          } 
          var oldonload = window.onload; 
          if (typeof window.onload != 'function') {
              window.onload = fn; 
          }else{
              window.onload = function() { 
                  oldonload(); 
                  fn();
              }
          }
      }, 

      // 绑定事件
      addEvent: function(element, type, handler) { 
          if (element.addEventListener) {    
                element.addEventListener(type, handler, false); // DOM2
          }else if (element.attachEvent) { 
              element.attachEvent('on' + type, function() {
                    handler.call(element);     // 兼容IE
              }); 
          }else { 
              element['on' + type] = handler;  // DOM0
          }
      },

      // 移除事件 
      removeEvent: function(element, type, handler) {
          if (element.removeEventListener) {
              element.removeEventListener(type, handler, false); 
          }else if (element.datachEvent) { 
              element.datachEvent('on' + type, handler); 
          }else{
              element['on' + type] = null;
          }
      },

      // 获取应用到元素上的所有样式
      getStyle: function(obj){
          var style = null;
          if(window.getComputedStyle){
              style = window.getComputedStyle(obj,null);  // W3C
          }else{
              style = obj.currentStyle;   // IE
          }
          return style;
      },

      // 获取事件对象，确保随时可以使用
      getEvent: function(e) { 
          var ev = e || window.event;
          if(!ev){ 
              var c = this.getEvent.caller; 
              while(c) { 
                  ev = c.argument[0]; 
                  if (ev && Event == ev.constructor) {
                          break; 
                  } 
                  c = c.caller; 
              } 
          } 
          return ev; 
      },

      // 获取触发事件的元素 
      getTarget: function(event) { 
          return event.target || event.srcElemnt; 
      },

      // 阻止冒泡，比如 父子元素都有事件时阻止同时触发
      stopPropagation: function(ev) { 
          if (ev.stopPropagation) { 
              ev.stopPropagation(); 
          }else { 
              ev.cancelBubble = true;
          }
      }, 
      stop_propagation: function() { 
          var e = window.event || arguments.callee.caller.arguments[0];
          if(e && e.stopPropagation){ 
              e.stopPropagation();   
          }else if(window.event){ 
              window.event.cancelBubble = true;  
          }
      }, 

      // 阻止浏览器默认行为，比如 点击提交按钮时阻止默认提交表单、a链接阻止默认跳转
      preventDefault: function(ev) {
          if (ev.preventDefault) { 
              ev.preventDefault(); 
          }else{
              ev.returnValue = false; 
          }
      } 
  }
  ```


### 事件委托
> 利用事件冒泡原理，将本该元素执行的事件委托给了它的父元素执行  

  1. 优势
    * 节省内存，提升性能
    * 减少DOM操作，运行效率更高
  2. 适用场景
    * 给多个同类元素绑定相同事件
    * 给动态生成的新元素绑定事件
  3. 实现代码
  ```js
  // 为三个同级的 input 绑定点击事件
  var box = document.getElementById("box");
  // box.on("click", "input", callback) 
  box.onclick = function (ev) {
      var ev = ev || window.event;
      var target = ev.target || ev.srcElement;

      // 判断元素：target.className == "box"
      if(target.nodeName.toLocaleLowerCase() == 'input'){
          switch(target.id){
              case 'add' :
                  console.log('添加');
                  break;
              case 'remove' :
                  console.log('删除');
                  break;
              case 'select' :
                  console.log('选择');
                  break;
              default:
                  break;
          }
      }
  }

  // 为添加的子元素绑定事件
  var btn = document.getElementById("btn");
  var oUl = document.getElementById("ul1");
  oUl.addEventListener('mousedown', function(ev){
      var ev = ev || window.event;
      var target = ev.target || ev.srcElement;
      if(target.nodeName.toLocaleLowerCase() == 'li'){
          ev.target.style.backgroundColor="black";
      }
  });
  btn.onclick = function(){
      var oLi = document.createElement('li');
      oLi.innerHTML = 4;
      oUl.appendChild(oLi);
  };
  ```

 

# 四、BOM
> 浏览器对象模型，用于操作浏览器本身的应用编程接口  

  <div align="center">
  <!-- bom.png -->
  ![BOM](/images/js/bom.png)
  </div> 


# 四、jQuery

> 一个 javascript 库，它把常用方法封装到一个js文件中，需要时直接调用即可

##  入口函数
  1. js
    * 主流：`window.onload = function(){ }`
  2. jquery
    * 主流：`$("document").ready(function(){ })`   
    * 简化：`$(function(){ })`
  3. 区别
    * 书写个数不同：前者只能出现一次并且会被覆盖，后者可出现任意多次且不存在事件覆盖
    * 执行时机不同：前者在文档树加载完成之后还必须 等待图片等所有资源加载完成后才会执行，而后者在文档树加载完成时执行


## $ 符号
<div style="text-indent: 2em"> jQuery 的别名，本质是一个函数，调用时通过传入不同参数而实现不同功能，可传参数如下：</div>
  
  * 字符串：`$("#id")`
  * DOM 对象：`$(domObj)` 
  * function：`$(function(){ })`


## 基础操作

### 对象转换   
  * DOM 转为 jq：`var $btn = $(btn)`
  * jq 转为 DOM：`var btn = $btn[0] / $btn.get(0)`

### 动画实现
  * 显示隐藏：`show/hide(speed, callback)`
  * 滑入滑出：`slideDown/Up/Toggle(speed, callback)`
  * 淡出淡入：`fadeIn/Out/Toggle(speed, callback)`
  * 自定义动画：`animate(prop, speed, easing, callback)` 

### 操作样式
  * css操作
    * 获取单个样式：`css("width")`
    * 设置单个样式：`css("width", "20")`
    * 设置多个样式：`css({"color": "red", "w": "10px"})`
  * class操作
    * 添加：`addClass()`   
    * 移除：`removeClass()`，不传参数则移除所有的样式
    * 切换：`toggleClass()`，没有则添加
    * 判断：`hasClass()、is()`

### 操作 DOM

  * 创建：`var $h3 = $('h3标签')`
  * 插入
    * `$('父').append/prepend('子')`
    * `$('子').appendTo('父')`
    * `$('同胞').before/after('插入同胞')` 
    * `$('插入同胞').insertBefore/After('同胞')`
  * 删除：`$('#box').remove()、$('ul').remove('l1')`
  * 克隆：`$('h3').clone()`，传入 true 时克隆结构加事件，否则只克隆结构。
  * 清空子元素：`empty()、html("")`，后者不会清理子元素事件而造成内存泄漏，不推荐使用。


### 操作属性
  * 读取属性：`attr(name)`
  * 移除属性：`removeAttr(name)` 
  * 设置单个属性：`$("img").attr(‘src’, ‘test.jpg’)`
  * 设置多个属性：`$('div').attr({'class': 'a', 'style': 'color: red;'})`
  * 方法区别
    * 操作元素的固有属性：`prop`
    * 处理元素的自定义属性：`attr`

   
### 操作内容
  * 表单元素：`val(value)`
  * 普通元素：`html(str)、text(str)` 


## 事件机制

### 发展历程
  1. 简单绑定：一次只能绑定一个事件，`click(handler)、scroll(handler)`
  2. bind 绑定：不支持动态创建的元素绑定事件，`$("p").bind("click mouseenter", handler)`
  3. on 绑定
    * 自身绑定：`on(事件名称, 事件处理函数)`
    * 事件委托`on(事件名称, 可选后代元素, 传递数据, 事件处理函数)`
    * 事件解绑
      * 解绑匹配元素的所有事件：`off()`
      * 解绑匹配元素的所有 click 事件：`off(“click”)`
      * 解绑元素所有代理的 click 事件但不解绑自身事件：`off( “click”, “**” )`
    * 先解绑再绑定
      * 功能：防止事件累加，导致点击一次而事件执行多次
      * 实现：`$("#btn").off("click").on("click", callback)`


### 事件触发
  * 直接调用：`$("div").click()`
  * trigger：会触发浏览器默认操作，`$("input").trigger("focus")`
  * triggerHandler：不会触发浏览器的默认行为，`$("input").triggerHandler("focus")`


### 事件委托
  1. 把事件绑定在父元素上。
  2. 点击子元素时会触发事件冒泡。
  3. 父元素的事件响应时获取触发该事件的元素。
  4. 如果该元素和 on 绑定的元素相匹配则触发事件处理函数。


## 编程思想

  * js 与 jquery
    * 可共存：`$('div').html()、div.innerHTML`
    * 不可混用：`div.html()、$('div').innerHTML`
    * 对应关系：`onclick 和 click()、innerHTML 和 html()`
    * this 绑定：`fn(obj){ var $this = $(obj) }`
  * 链式编程
    * 原理：`return this`
    * 示例：`$('li').parent().css("width", "10px").end().next().hide()`
  * 隐式迭代
    * 理解：方法内部为所有匹配元素进行循环遍历
    * 注意：设置的是全部元素，获取的是第一个元素的值
    * 示例：`$('div').css('color', 'red')、$('li').css('width')`
  * each 遍历
    * 数组：`$.each(arr, function(i, v){ })`     
    * 对象：`$.each(obj, function(key, val){ })`   
    * 元素：`$('div').each(function(i, obj){ })`
  * 多库共存
    * 问题：如果引用的其他库也用到 $，则前面引入库中的 $ 会被覆盖
    * 解决：若想让其他库使用 $ 则可以把 jQuery 的 $ 给释放掉。同时存在多个版本的 jQuery 则可以使用 noConflict 来区分。


## 插件机制
> 为 jQuery 原型添加功能函数来扩展功能

### 插件开发
  1. 类级别  
    ```js
    // 调用：$.hello()
    (function($){
        $.extend({
            hello: function(){
              console.log("hello world")
            }
        })
    })(jQuery)

    // 调用：$.myExtend.hello() 
    (function($){
        $.myExtend({
            hello: function(){
              console.log("hello world")
            } 
        })
    })(jQuery)
    ```
  2. 对象级别
    ```js
    // 调用：$("#box").myAnimate()
    (function($){
        // 写法一
        $.fn.extend({
            myAnimate: function(){ } 
        })
        // 写法二
        $.fn.myAnimate = function(){ }
    })(jQuery) 
    ```


### 插件模板
  1. 分号：开头添加是为了避免别人的代码不规范引起错误，结尾添加是为了 避免压缩出错
  2. 传参
    * 没有第四个参数
    * undefined：保证原生，防止他人把其定义为别的
    * window、document：快速查找，而且也便于代码压缩，比如 window 可能被压缩为 w  
    ```js
    ;(function(win, doc, $, undefined){ 
        // 写法一
        $.fn.extend({
            "pluginName": function(opt){}
        })

        // 写法二
        var defaults = { }
        $.fn.pluginName = function(opt){
          // 合并默认配置和用户配置
          var set = $.extend({}, defaults, opt)

          // 支持链式调用
          return this; 
        } 
    }(window, document, jQuery))
    ```

 
### 方法
  * `$.extend( obj )`：扩展 jquery 类本身，只有通过 jq/$ 类来调用
  * `$.fn.extend( obj )`：扩展 jquery 原型对象，每个实例化的 jq 对象都可以调用
  * `$.extend( target, [objN])`：使用一个或多个其他对象来扩展第一个对象
  * 关系：`$.fn.pluginName = $.fn.extend(pluginName) = $.prototype.extend(pluginName)`


# 五、JS 算法
  * 排序算法
    * __冒泡排序__：比较任何两个相邻元素，如果第一个比第二个大则交换位置。元素向上移动到正确顺序，类似气泡上升至表面而得名。
    * __选择排序__：每次从元素中选出最小或最大值，存放在序列的起始位置，以此循环至排序完毕。
    * __插入排序__：将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，适用于少量数据的排序。
    * __归并排序__：将原始序列切分成较小的序列直到无法再切分，然后将小序列排序后归并成大序列，直到最后只有一个排序完毕的大序列。
    * __快速排序__：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行上述递归排序，以此达到整个数据变成有序序列。
  * 搜索算法
    * __顺序搜索__：让目标元素与列表中的每一个元素逐个比较，直到找出与给定元素相同的元素为止，缺点是效率低下。
    * __二分搜索__：在一个有序列表，以中间值为基准拆分为两个子列表，拿目标元素与中间值作比较从而再在目标的子列表中递归此方法，直至找到目标元素。
  * 其他
    * __贪心算法__：在对问题求解时，不考虑全局，总是做出局部最优解的方法。
    * __动态规划__：在对问题求解时，由以求出的局部最优解来推导全局最优解。
    * __复杂度__：一个方法在执行的整个生命周期所需要占用的时间、空间等资源。


## 冒泡排序
  ```js
  Array.prototype.bubbleSort = function() {
      for (let i = 0; i < this.length; i++) {
          for (let j = 0; j < this.length - 1 - i; j++) {
              if (this[j] > this[j + 1]) {
                  let temp = this[j]
                  this[j] = this[j + 1]
                  this[j + 1] = temp
              }
          }
      }
  }
  ```


## 选择排序
  ```js
  Array.prototype.selectionSort = function() {
      let indexMin
      for (let i = 0; i < this.length - 1; i++){
          indexMin = i
          for (var j = i; j < this.length; j++){ 
              if(this[indexMin] > this[j]) {
                  indexMin = j
              }
          } 
          if (i !== indexMin){
              let aux = this[i]
              this[i] = this[indexMin]
              this[indexMin] = aux
          }
      }
      return this
  }
  ```


## 插入排序
  ```js
  Array.prototype.insertionSort = function() {
      let j
      let temp
      for (let i = 1; i < this.length; i++) {
          j = i
          temp = this[i]
          while (j > 0 && this[j - 1] > temp) {
              this[j] = this[j - 1]
              j--
          } 
          this[j] = temp
          console.log(this.join(', '))
      }
      return this
  }
  ```


## 归并排序
  ```js
  Array.prototype.mergeSort = function() {
      const merge = (left, right) => {
          const result = []
          let il = 0
          let ir = 0
          while(il < left.length && ir < right.length) {
              if(left[il] < right[ir]) {
                  result.push(left[il++])
              } else {
                  result.push(right[ir++])
              }
          }
          while (il < left.length) {
              result.push(left[il++])
          }
          while (ir < right.length) {
              result.push(right[ir++])
          }
          return result
      }
      const mergeSortRec = array => {
          if (array.length === 1) {
              return array
          }
          const mid = Math.floor(array.length / 2)
          const left = array.slice(0, mid)
          const right = array.slice(mid, array.length)
          return merge(mergeSortRec(left), mergeSortRec(right))
      }
      return mergeSortRec(this)
  }
  ```


## 快速排序
  ```js
  Array.prototype.quickSort = function() {
      const partition = (array, left, right) => {
          var pivot = array[Math.floor((right + left) / 2)]
          let i = left
          let j = right
          while (i <= j) {
              while (array[i] < pivot) {
                  i++
              }
              while (array[j] > pivot) {
                  j--
              }
              if (i <= j) {
                  let aux = array[i]
                  array[i] = array[j]
                  array[j] = aux
                  i++
                  j--
              }
          }
          return i
      }
      const quick = (array, left, right) => {
          let index
          if (array.length > 1) {
              index = partition(array, left, right)
              if (left < index - 1) {
                  quick(array, left, index - 1)
              }
              if (index < right) {
                  quick(array, index, right)
              }
          }
      }
      quick(this, 0, this.length - 1)
      return this
  }
  ```


## 顺序搜索
  ```js
  Array.prototype.sequentialSearch = function(item) {
      for (let i = 0; i < this.length; i++) {
          if (item === this[i]) return i
      }
      return -1
  }
  ```


## 二分搜索
  ```js
  Array.prototype.binarySearch = function(item) {
      this.quickSort()
      let low = 0
      let mid = null
      let element = null
      let high = this.length - 1
      while (low <= high){
          mid = Math.floor((low + high) / 2)
          element = this[mid]
          if (element < item) {
              low = mid + 1
          } else if (element > item) {
              high = mid - 1
          } else {
              return mid
          }
      }
      return -1
  }
  ```


## 动态规划
> 美国硬币：d1=1, d2=5, d3=10, d4=25，如果要找36美分的零钱，我们可以用 1个25美分、1个10美分和1个便士（ 1美分)
最少硬币找零的解决方案是找到 n 所需的最小硬币数

  ```js
  class MinCoinChange {

    constructor(coins) {
      this.coins = coins
      this.cache = {}
    }

    makeChange(amount) {
      if (!amount) return []
      if (this.cache[amount]) return this.cache[amount]
      let min = [], newMin, newAmount
      this.coins.forEach(coin => {
          newAmount = amount - coin
          if (newAmount >= 0) {
              newMin = this.makeChange(newAmount)
          }
          if (newAmount >= 0 && 
                (newMin.length < min.length - 1 || !min.length) && 
                (newMin.length || !newAmount)) {
              min = [coin].concat(newMin)
          }
      })
      return (this.cache[amount] = min)
    }
  }
  const rninCoinChange = new MinCoinChange([1, 5, 10, 25])
  console.log(minCoinChange.makeChange(36)) // [1, 10, 25]

  const minCoinChange2 = new MinCoinChange([1, 3, 4])
  console.log(minCoinChange2.makeChange(6))  // [3, 3]
  ```


## 贪心算法
> 通过贪心算法得出上述解决方案

  ```js
  class MinCoinChange {

    constructor(coins) {
      this.coins = coins
    }

    makeChange(amount) {
      const change = []
      let total = 0
      this.coins.sort((a, b) => a < b).forEach(coin => {
          while ((total + coin) <= amount) {
            change.push(coin)
            total += coin
          }
      })
      return change
    }
  }
  const rninCoinChange = new MinCoinChange ( [ 1, 5, 10, 2 5])
  console. log (rninCoinChange. rnakeChange (36))
  ```


