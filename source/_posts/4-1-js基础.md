---
title: Javascript 主要内容
tags:
  - Javascript
categories: Javascript 
top: false
keywords:
  - js
date: 2019-03-10 00:11:13
description: ECMAScript、DOM、BOM
---

# 一、Javascript 
> JavaScript 由对象组成，一切皆为对象

## 组成部分
  * __ECMAScript__：核心，描述了JS的语法和基本对象
  * __DOM__：文档对象模型，处理网页内容的方法和接口
  * __BOM__：浏览器对象模型，与浏览器交互的方法和接口


## 语言特点
  * 解释型的脚本语言：在程序的运行过程中逐行进行解释
  * 语法简单：使用弱类型的变量，对数据类型也没有严格要求
  * 事件驱动：通过事件对用户操作做出响应
  * 跨平台性：不依赖于操作系统，只需要兼容浏览器即可


## 历史演变
  * 始于1995年，前身为网景公司开发的 LiveScript，用来处理 以前由服务端负责的数据验证
  * 后更名为JavaScript，功能演变为：前后端数据交互、页面特效、服务端开发 NodeJS
  * JS 的很多语法和 Java、C# 语法相似，和 Java 毫无关系


# 二、ECMAScript
> 一种根据 ECMA-262 标准制定的通用脚本语言规范，JavaScript 是遵守该标准实现的一种脚本语言


## 变量

### 命名
  * 方法：匈牙利命名法、驼峰命名法
  * 规则
    * 首字符：英文字母、下划线
    * 组成：英文字母、下划线、数字
    * 禁忌：关键字、保留字

### 声明
  * 显式声明：`var 变量名`
  * 错误用法：没有类型、重复声明、隐式声明、不声明直接使用
  * 正确用法：先声明后读写、先赋值后运算


### 作用域
1. 全局变量
  * 包含：在函数外定义的变量，没有使用 var 的变量
  * 调用：任何位置
2. 局部变量
  * 包含：在函数内使用 var 声明的变量，函数的参数变量
  * 调用：当前函数体内
3. 优先级
  * 局部变量 > 同名参数变量 > 同名全局变量
4. 特性
  * 忽略块级用域
    * ES6之前，js的作用域只有 函数作用域和全局作用域
    * ES6中定义了块级作用域，有“暂时性死区”的特性（声明前不可用）
  * 作用域链
    * 内层函数可以访问外层函数的局部变量
    * 外层函数不能访问内层函数的局部变量
  生命周期
    * 全局变量除非被显式删除，否则一直存在
    * 局部变量从声明开始到函数运行完毕或被显式删除
    * 回收机制有 标记清除、引用计数


### 面试题
  ```js
  var obj = {
        say: function(){
            console.log(say)
        }
  }
  obj.say()   // 报错，没有在函数作用域内创建 fn


  var a = 1;
  function test() {
    var a = 2;
    console.log(a);   // 2，遵循就近原则
  }
  test();

  var a = 1;
  function test2() {
    console.log(a);   // undefined，变量提升
    var a = 2;
  }
  test2(); 

  var a = 1; 
  function test3() {
    console.log(a);   // 1，重新赋值而未重新声明
    a = 2;
  }
  test3();

  let b = 1;
  function test4() {
    console.log(b); // 报错，let 不能变量提升
    let b = 2;
  }
  test4();

  function test5() {
    let a = 1;
    { let a = 2; }
    console.log(a);  // 1，console不在块级作用域中
  }
  test5();
  ```


## 数据类型
> 分为原始数据和引用数据，js 变量的类型会根据其所赋值的数据类型来决定

### 基本数据
  * 即原始值：`Number、String、Boolean、undefined、Null`
  * 6 个假值：`0、" "、undefined、null、NaN、false`
  * 存储方式：存储在栈中的简单数据段。js 可按值访问其实际保存的值，复制时则会创建其副本
  * 检测方法：`typeof`
      
### 引用数据
  * 即引用值：`Object`
  * 存储方式：存储在堆中的对象。js按引用访问其值，即访问时先从栈中读取内存地址（大小固定，保存于栈中），然后再找到保存在堆内存中的值。复制时只是复制了地址，两个对象实际指向的都是同一个值。
  * 检测方法：`instanceof`

  
### 栈和堆
  * __栈 stack__：可理解为一个无盖水缸，它会自动分配内存空间和释放。用于存储基本数据类型，具有空间大小固定和先进后出的特点。
  * __堆 heap__：可理解为封闭盒子，动态分配内存，大小不固定而且不会自动释放。用于存储基本数据类型包装起来的类，实际上保存的不是变量本身，而是指向该对象的指针。

### 类型转换
  * 强制转换：`Boolean()、Number()、String()`
  * 普通转换：`parseInt()、parseFloat()、num.toString()`


## 运算符
  * 算术运算符：`+、-、*、/、%、++、--`
  * 赋值运算符：`=、+=、-=、*=、/=`
  * 字符串运算符：`+、+=`
  * 比较运算符：`>、<、>=、<=、==、!=、===、!==`
  * 逻辑运算符：`&&、||、!`
  * 三元运算符：`?:`


## 流程语句

### 循环语句
  * while：`while(条件表达式) { 代码段 }`
  * do-while：`do{ 代码段 } while(条件表达式)`
  * for：`for(循环变量 = 初值; 循环条件; 递增/递减){ 代码段 }`
  * for-in：`for(声明变量 in 对象){ 代码段 }`

### 跳转语句
  * return：终止函数体的运行，并返回一个值
  * break：终止整个循环，不再判断
  * continue：结束本次循环，判断是否执行下次循环

### 选择语句
  * if：`if(条件1){ } else if(条件2){ } else{ }`
  * switch：`switch(条件){ case 1: break; default: break; }`
  * 三元表达式：`var res = x>0 ? 1 : (x=0 ? -1 : 2)`

### 异常处理语句
  * throw：主动抛出异常
  * try：指明需要处理的代码段
  * catch：捕获异常
  * finally：后期处理



## 函数
> 一段可以反复调用的代码块

### 分类
  * 普通函数
  * 构造函数：类，可分为 内置类和自定义类
  * 函数对象：通过 new Function() 创建的对象


  ```js
  // 1、普通函数

  // 函数声明
  function f1(){  } 

  // 函数表达式    
  var f2 = function(){ }  

  // 回调函数 callback：特定条件下调用
  function f(num, callback){   
    if(num == 3){
        callback();
    }
  }

  // 自执行函数 IIFE：独立作用域而不会污染全局环境
  (function(x, y){
      console.log(x + y);
  })(2, 3);
  ;(function(){ 
      console.log(111);
  })();


  // 2-1、内置类
  var f3 = new Function('a','b','c','return a+b');
  console.log(f3.constructor);   // 当前实例所属类


  // 2-2、自定义类
  function Person(name, age){ 
      this.name = name;
      this.age = age;
      return 1;  // return 基本类型则被忽略
      // return { 'Jack': 18 }; // return 引用类型则被返回
  }
  Person.prototype.eat = function(){ };  
  var p = new Person('Tom', 20);  
    

  // 3、函数对象
  var f4 = new Function('str', 'console.log(str)');
  ```


### 调用
  * 函数模式：`fn()`
  * 方法模式：`obj.fn()、绑定 html 标签`
  * 构造器模式：`new`
  * 上下文模式：`call / apply`


  ```js
  function foo(m, n){
      console.log(this);
      return m + n;
  }
  // 函数调用
  var f1 = foo(1, 5);
  // 以 window 为上下文调用
  var f1 = foo.apply(null, [1, 5])
  var f1 = foo.call(null, 1, 5);

  
  var obj = {
      age: 20,
      getAge: function(){
          return this.age;
      }
  }
  // 方法调用
  var f2 = obj.getAge();
  //  以 obj 为上下文调用
  var f2 = obj.getAge.apply(obj);
  var f2 = obj.getAge.call(obj);
  ```


### apply 和 call
  ```js
  // 1、改变 this 指向
  var obj = {
      name: 'linxin'
  }
  function foo(){
      console.log(this.name);
  }
  foo.call(obj);   // linxin
  // obj 作为参数传给了 foo，此时函数中的 this 便指向了 obj。foo函数里相当于
  function func(){
      console.log(obj.name);
  }


  // 2、借用别的对象的方法
  var Person1  = function(){
      this.name = 'linxin';
  }
  var Person2 = function(){
      this.getname = function(){
          console.log(this.name);
      }
      // 使用 Person1 对象代替 this 对象，所以 Person2 继承了 Person1 的属性和方法
      Person1.call(this);
  }
  var person = new Person2();
  person.getname();  // linxin


  // 3、调用函数
  function fn() {
      console.log('linxin');
  }
  fn.call();  // linxin
  ```

### this 指向
  ```js
  var obj = {
        name: 'tom',
        getName: function () {
            return this.name;
        }
    };
  var obj2 = { name: 'tony' }
  console.log(obj.getName());  // tom，this 指向对象本身
  var getName = obj.getName;
  console.log(getName());      // 空，此时方法中的 this 指向 window 对象
  console.log(getName.apply(obj2))    // tony，this 指向了 obj2 对象
  ```


### 函数前置
<div style="text-indent: 2em">函数声明会被 js解析器 优先读取，有重名的只留一个（变量和函数重名只留函数）。表达式只有在执行该语句时才会被逐行解析，而函数只有在被调用时才执行内部封装的函数体。</div>

  ```js
  f1() 
  var f1 = function(){ }   //报错

  f2() 
  function f2(){ }        // 正常 
  ```


### 函数标识
  * this：指向当前操作对象
  * callee：指向参数集合所属对象
  * prototype：指向函数附带的原型对象
  * constructor：指向创建该对象的构造函数


### 闭包
> 指有权访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数，主要是用来设计私有的方法和变量

<div style="text-indent: 2em">局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量以便反复使用，但又不会造成全局污染。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</div>

  * 特性
    * 函数嵌套函数 
    * 函数内部可以引用外部的参数和变量 
    * 参数和变量不会被垃圾回收机制回收
  * 用途：
    * 数据缓存
    * 封装私有变量
    * 封装自定义插件
    * 实现类和继承

  ```js  
  // 异步获取数据并缓存
  const getList = (function() {
      let data = {};
      const getData = () => {
          return new Promise((resolve, reject) => {
              let packageOptions = {
                  url: '/names',
                  params: {
                      normal: 1
                  },
                  success: function (rsp) {
                      data = rsp.data
                      resolve();
                  }
              };
              ajax(packageOptions);
          })
      }
      // 闭包存储data
      const result = async function (type) {
          if (JONS.stringify(data) === '{}') {
              await getData();
              return data;
          } else {
              return data;
          }
      }
      return result;
  })() 
  getList().then(res => {
      console.log(res);
  })


  // 封装私有变量
  var person = function(){     
      var name = "default";       
        
      return {    
          getName : function(){    
              return name;    
          },    
          setName : function(newName){    
              name = newName;    
        }    
      }    
  }();    
  console.log(person.name);       // undefined    
  console.log(person.getName());  // default  
  person.setName("chuang");    
  console.log(person.getName());  // chuang  
 

  // 封装插件：匿名自执行函数执行完后会立刻释放资源
  ;(function(document) { 
    var obj = {
          setColor: function(id, color) {
            document.getElementById(id).style.color = color;
          }
    }
    window.view = obj;  // 暴露接口
  })(document);
  view.setColor('main','red');


  // 实现类和继承
  function Person(){    
    var name = "default";       
       
    return {    
       getName: function(){    
           return name;    
       },    
       setName: function(newName){    
           name = newName;    
       }    
    }    
  }
  var p = new Person();
  p.setName("Tom");
  console.log(p.getName());
  ```
            


## 正则表达式
> 使用 `RegExp` 对象表示并由元字符、字符串和量词组成，用于描述字符串的匹配规则

### 创建
  1. 方式
    * 字面量：`/pattern/attributes`，特殊字符不需要转义，不支持字符串拼接
    * 实例化：`new RegExp(“pattern”, “attributes”)`，特殊字符需要转义，支持字符串拼接
  2. 参数
    * pattern：正则表达式
    * attributes：匹配模式，`g、i、m` 分别表示 全局匹配、忽略大小写、多行匹配

  ```js
  var regExp = 'ab';

  // 字面量 
  var reg_1 = /regExp/;
  var reg_1 = /^[a-zA-Z0-9]{3,8}$/;

  // 实例化
  var reg_2 = new RegExp(regExp+'1');
  var reg_2 = new RegExp(“[a-zA-Z0-9]{3,8}”);
  ```

### 基础语法
<div align="center"> 
  ![regExp](/images/js/regExp.png)
</div> 



## 全局对象
> Window 对象，表示允许 JavaScript 代码访问的 Web 浏览器窗口

### 全局函数
  * 编码：`encodeURI、encodeURIComponent、escape`
  * 解码：`decodeURI、decodeURIComponent、unescape`
  * 检测：`isNaN、isFinite`
  * 转换：`eval、String、Number`
  * 解析：`parseInt、parseFloat`

### 全局属性
  * NaN：不是数字值
  * undefined：未定义的值
  * Infinity：正无穷大的数值 


## 计时器
<div style="text-indent: 2em">requestAnimationFrame 采用系统时间间隔来保持最佳绘制效率而不需要手动设置，这样就不会因间隔时间过短而会造成 过度绘制并增加开销，也不会因时间太长则导致 动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</div>

  * __setTimeout__：延时执行指定代码, 取消时使用 clearTimeout
  * __setInterval__：间隔时间重复执行代码, 取消时使用 clearInterval
  * __requestAnimationFrame__：在浏览器每次刷新页面之前执行代码，时间间隔由浏览器刷新频率决定，取消时使用 cancelAnimationFrame

  ```js
  var box = document.getElementById("box");
  var timer = requestAnimationFrame(function step(){
        var width = parseInt(box.style.width);
        if(width < 500){
            box.style.width = width + 10;
            requestAnimationFrame(step);
        }else{
            cancelAnimationFrame(timer);
        } 
  })
  ```



# 三、DOM
> 文档对象模型，用于操作 HTML 和 XML 文档（浏览器内容）的编程接口

## 节点
<div style="text-indent: 2em">DOM 将整个文档（XML文档和HTML文档）看作一个树形结构，并用document对象表示该文档，并规定其中每个成分都是一个节点（Node），JavaScript 通过 DOM API 可以操作到每个节点。</div>

### 节点信息
  * `nodeType`：节点类型
  * `nodeName`：节点名称
  * `nodeValue`：节点值

### 节点类型
  * 文档节点：整个文档
  * 注释节点：文档注释
  * 元素节点：html 标签
  * 文本节点：元素/属性节点中的文本内容
  * 属性节点：元素节点的属性

  <div align="center"> 
    ![节点类型](/images/js/domNodes.png) 
  </div> 


### 文档节点
  * 标签：`document.documentElement/body/forms`
  * 信息：`document.URL/domain/readyState`
  * 方法：`document.write/writeln/open/close`


### 元素节点
> 文本节点、属性节点都属于元素节点的子节点，操作时都需要先获取 元素节点

  1. 获取
    * document
      * `document.getElementById/TagName/ClassName/Name`
      * `document.querySelector [All]`
      * `document.documentElement`
      * `document.body`
      * `document.forms` 
    * 节点指针
      * 父节点：`parentNode`
      * 同级节点：`previousSibling、nextSibling`
      * 子节点：`firstChild、lastChild、childNodes、children`
  2. 操作
    * 创建：`createElement、createAttribute、createTextNode`
    * 插入：`appendChild、insertBefore`
    * 替换：`replaceChild`
    * 复制：`cloneNode`
    * 删除：`removeChild` 
    * 样式：`dom.style.样式名`
      * 样式名必须使用驼峰命名法
      * 修改 class 时必须使用 className
  3. 属性
    * 获取：`getAttribute`
    * 设置：`setAttribute`
    * 移除：`removeAttribute`
  4. 文本
    * 获取：`innerHTML / innerText`
    * 设置：`dom.innerHTML / innerText = "new"`
    * 表单元素：`input.value、input.value = “new”`

 
  ```js
  // 设置元素属性
  var box = document.getElementById("box");
  box.setAttribute("title", "this is box");  
  console.log(box.getAttribute("title"));  
    
  // 创建属性节点
  var placeholder = document.createAttribute("placeholder");
  placeholder.nodeValue = "请输入姓名"; 
  box.setAttributeNode(placeholder);  
  ```


## 事件

### DOM0 级  
> 在 DOM 中直接绑定事件

  * 绑定：`DOM.onclick = function(){ }`
  * 移除：`DOM.onclick = null / ""`
  

### DOM2 级  
> 使用事件监听绑定事件，浏览器监听到用户执行相关操作做出响应

  1. 主流浏览器
    * 绑定：`DOM.addEventListener('click', fn, false)`
    * 移除：`DOM.removeEventListener('click', fn)`
    * 参数：false 时在冒泡阶段执行，true 则在捕获阶段执行
  2. IE8及以下
    * 绑定：`DOM.attachEvent('onclick', fn)`
    * 移除：`DOM.detachEvent('click', fn)`


  ```js
  // DOM0 级事件可能被覆盖：2，3，4
  var box = document.querySelector('#box')
  box.onclick = function() {
      alert(1)
  }
  box.onclick = function() {
      alert(2)
  }
  box.addEventListener('click', function() {
      alert(3)
  })
  box.addEventListener('click', function() {
      alert(4)
  })  
  ```

### 事件流
> 事件的执行顺序

  * 事件冒泡：事件从事件目标元素开始触发，向上触发到最外层的 document 对象
  * 事件捕获：与冒泡相反
  * DOM 事件流：DOM 先捕获到目标元素，然后冒泡到最外层
 

### 事件对象
> 触发 DOM 上的某个事件时会产生一个事件对象 event，它包含着所有与事件有关的信息

  1. 属性：鼠标 / 键盘属性、IE 属性、标准 Event 属性
  2. 方法：stopPropagation、preventDefault
  3. 事件
    * 鼠标事件：`click、dbclick、mousedown、mousemove、mouseout、mouseover、mouseup`
    * 键盘事件：`keydown、keypress、keyup`
    * HTML事件：`load、unload、resize、change、scroll、focus、blur、select、reset、submit`
  
  ```js
    var Event = {

      // 页面加载完成后
      readyEvent: function(fn) {  
          if (fn == null) { 
              fn = document;
          } 
          var oldonload = window.onload; 
          if (typeof window.onload != 'function') {
              window.onload = fn; 
          }else{
              window.onload = function() { 
                  oldonload(); 
                  fn();
              }
          }
      }, 

      // 绑定事件
      addEvent: function(element, type, handler) { 
          if (element.addEventListener) {    
                element.addEventListener(type, handler, false); // DOM2
          }else if (element.attachEvent) { 
              element.attachEvent('on' + type, function() {
                    handler.call(element);     // 兼容IE
              }); 
          }else { 
              element['on' + type] = handler;  // DOM0
          }
      },

      // 移除事件 
      removeEvent: function(element, type, handler) {
          if (element.removeEventListener) {
              element.removeEventListener(type, handler, false); 
          }else if (element.datachEvent) { 
              element.datachEvent('on' + type, handler); 
          }else{
              element['on' + type] = null;
          }
      },

      // 获取应用到元素上的所有样式
      getStyle: function(obj){
          var style = null;
          if(window.getComputedStyle){
              style = window.getComputedStyle(obj,null);  // W3C
          }else{
              style = obj.currentStyle;   // IE
          }
          return style;
      },

      // 获取事件对象，确保随时可以使用
      getEvent: function(e) { 
          var ev = e || window.event;
          if(!ev){ 
              var c = this.getEvent.caller; 
              while(c) { 
                  ev = c.argument[0]; 
                  if (ev && Event == ev.constructor) {
                          break; 
                  } 
                  c = c.caller; 
              } 
          } 
          return ev; 
      },

      // 获取触发事件的元素 
      getTarget: function(event) { 
          return event.target || event.srcElemnt; 
      },

      // 阻止冒泡，比如 父子元素都有事件时阻止同时触发
      stopPropagation: function(ev) { 
          if (ev.stopPropagation) { 
              ev.stopPropagation(); 
          }else { 
              ev.cancelBubble = true;
          }
      }, 
      stop_propagation: function() { 
          var e = window.event || arguments.callee.caller.arguments[0];
          if(e && e.stopPropagation){ 
              e.stopPropagation();   
          }else if(window.event){ 
              window.event.cancelBubble = true;  
          }
      }, 

      // 阻止浏览器默认行为，比如 点击提交按钮时阻止默认提交表单、a链接阻止默认跳转
      preventDefault: function(ev) {
          if (ev.preventDefault) { 
              ev.preventDefault(); 
          }else{
              ev.returnValue = false; 
          }
      } 
  }
  ```


### 事件委托
> 利用事件冒泡原理，将本该元素执行的事件委托给了它的父元素执行  

  1. 优势
    * 节省内存，提升性能
    * 减少DOM操作，运行效率更高
  2. 适用场景
    * 给多个同类元素绑定相同事件
    * 给动态生成的新元素绑定事件
  3. 实现代码
  ```js
  // 为三个同级的 input 绑定点击事件
  var box = document.getElementById("box");
  // box.on("click", "input", callback) 
  box.onclick = function (ev) {
      var ev = ev || window.event;
      var target = ev.target || ev.srcElement;

      // 判断元素：target.className == "box"
      if(target.nodeName.toLocaleLowerCase() == 'input'){
          switch(target.id){
              case 'add' :
                  console.log('添加');
                  break;
              case 'remove' :
                  console.log('删除');
                  break;
              case 'select' :
                  console.log('选择');
                  break;
              default:
                  break;
          }
      }
  }

  // 为添加的子元素绑定事件
  var btn = document.getElementById("btn");
  var oUl = document.getElementById("ul1");
  oUl.addEventListener('mousedown', function(ev){
      var ev = ev || window.event;
      var target = ev.target || ev.srcElement;
      if(target.nodeName.toLocaleLowerCase() == 'li'){
          ev.target.style.backgroundColor="black";
      }
  });
  btn.onclick = function(){
      var oLi = document.createElement('li');
      oLi.innerHTML = 4;
      oUl.appendChild(oLi);
  };
  ```

 

# 四、BOM
> 浏览器对象模型，用于操作浏览器本身的应用编程接口  

  <div align="center">
  <!-- bom.png -->
  ![BOM](/images/js/bom.png)
  </div> 



