---
title: 微信小程序入门
tags:
  - 微信
categories: 移动端
top: false
keywords:
  - 微信小程序
date: 2019-07-07 00:22:18
description: 简单入门、底层原理、视图层、逻辑层、组件化开发、路由功能
---

# 一、简单入门
> 微信朋友圈提供了好友之间沟通信息的手段，订阅号提供了面向粉丝推送信息的手段，而小程序则是提供了用户通过自己的操作而与服务实现互动的手段。小程序融合了原生 App 和 web 端，通过微信 APP 实现了多线程而且可以调用丰富的功能接口，同时又跨平台。需要注意的是，小程序基于浏览器内核重构的内置解析器，所以不能使用 DOM、BOM 的相关 API。


## 存在问题

  * 开发者不可以扩展新组件。
  * 暂时不支持 ipad 打开小程序
  * 小程序无法打开页面，无法拉起 APP。
  * 需要独立开发，不能在非微信环境运行。
  * 小程序使用 WebView 渲染，并非原生渲染。
  * WXSS 不支持级联选择器、less 等。
  * WXSS 中无法使用本地资源（图片、字体等）。
  * WXSS 转化成 js 而不是 css，是为了兼容 rpx。
  * 微信小程序不支持 cookie
    * 可使用 Reids 存储 session
    * 有些手机不支持 Object.assign 方法，使用报错时可以直接写一个合并对象的方法。
  * 小程序不能和公众号重名，于是小程序的名字就成了：自选股+、滴滴出行DiDi。
  * 依赖浏览器环境的 js 库不能使用，因为是在 JSCore 运行的，没有 window、document 对象。


## 主要特点

  * 前端组件化开发。
  * 基于微信跨平台，即用即走。
  * 全部使用 https，确保传输中安全。
  * 使用 Virtual DOM，进行局部更新。
  * 使用 rpx 单位，隔离设备尺寸，方便开发。
  * 视图层和逻辑层分离，通过数据驱动，不直接操作 DOM。
  * 拥有离线能力：页面返回时显示历史 View，退出小程序时不销毁 View 状态。
  * Native 预先新建 WebView，打开新页面时直接渲染默认数据然后进行局部更新。
  * 去中心化：微信不会提供类似小程序商店的地方，需要小程序提供者自己通过二维码、群分享的手段来传播。


## PWA 渐进式应用
> 全称是 Progressive Web Apps，它是结合了 web 和 原生应用中最好功能的一种体验。首次访问时，用户可以直接在浏览器中进行访问而不需要安装应用。随着时间的推移，当用户和应用逐渐建立了联系，它会变得越来越强大。它能够快速地加载，即使在弱网络环境下也能够推送相关消息，也可以像原生应用那样添加至主屏，能够有全屏浏览的体验。

* 主要特点
  * __渐进增强__：支持的新特性的浏览器获得更好的体验，不支持的保持原来的体验。
  * __离线访问__：通过 service workers 可以在离线或者网速差的环境下工作。
  * __类原生应用__：使用 app shell model 做到原生应用般的体验。
  * __可安装__：允许用户保留对他们有用的应用在主屏幕上，不需要通过应用商店。
  * __容易分享__：通过 URL 可以轻松分享应用。
  * __持续更新__：受益于 service worker 的更新进程，应用能够始终保持更新。
  * __安全__：通过 HTTPS 来提供服务来防止网络窥探，保证内容不被篡改。
  * __可搜索__：得益于 W3C manifests 元数据和 service worker 的登记，让搜索引擎能够找到 web 应用。
  * __再次访问__：通过消息推送等特性让用户再次访问变得容易。
* 功能模块
  * __Service Workers__：增强 Web 能力，主要用于实现资源离线缓存和更新。
  * __Web App Manifest__：使 Web 更像 Native，它以 JSON 的格式定义 Web 应用的相关配置（应用名称、图像链接、自定义特性、启动默认配置、全屏设置等）。
  * __App Shell__：提升显示效率的应用外壳，它是应用的用户界面所需的最基本的 HTML、CSS、JS，首次加载后立刻被缓存下来，不需要每次使用时都被下载，而是只异步加载需要的数据，以实现 UI 保持本地化。


## 区别 H5

  * __系统权限__：小程序可以获得更多的系统权限，如网络通信状态、数据缓存能力等。
  * __运行环境__：小程序基于浏览器内核重构的内置解析器，而 H5 的宿主环境是浏览器。所以小程序中没有 DOM、BOM 的相关 API。
  * __渲染机制__：小程序的逻辑层和渲染层分别在不同的线程中运行 (相互独立)，而 H5 页面的 UI 渲染、Js 脚本执行都在一个单线程 (互斥)。所以 H5 页面中长时间的脚本运行可能会导致页面失去响应。


## 程序限制

### 程序限制
  * 样式表不支持级联选择器。
  * 不支持 A 标签，无法打开普通网页。
  * 脚本内不能使用 window、document 等对象。
  * background-image 不能加载本地资源，可以是 网络图片、base64、标签。


### 数量限制
  * 一个应用同时只能打开 5 个页面。
  * wx.request 请求最开始最大并发数是 10 个。
  * 底部或顶部可以添加的 tab 按钮区域 tabBar 是一个数组，只能配置 2 ～ 5 个 tab。
  

### 大小限制
  * setStorage 本地缓存最大为 10MB。
  * setData 页面传递数据单次设置的数据不能超过 1024kB。
  * tabBar 的按钮路径为 iconPath，icon 大小限制为 40kb。
  * 为了提升体验流畅度，小程序源码编译后的代码包大小限制为 1MB。


## 使用 npm
> 因为小程序使用的是不完整的浏览器对象，所以很多 js 包无法使用。npm 可用来引入 moment 等插件，但是要注意不能通过 npm 引入没有 js 文件的 UI 库 weui，它可以通过直接下载文件并放到根目录，然后在 app.wxss 文件的开头引入。 

  1. 微信开发者工具、详情、使用 npm 模块。
  2. 项目的根目录打开命令行：npm init、npm i。
  3. 微信开发者工具、工具、构建 npm。此时小程序会将 node_modules 文件编译打包并生成新目录 miniprogram_npm。
  4. 对应页面的 js 文件引入后直接使用即可：const moment= require('moment')。
  5. 新建忽略文件 .gitignore，添加不需要上传的文件如 node_modules 、 package_lock.json。



# 二、底层原理

## 双线程模型
> 小程序框架由视图层和逻辑层两部分组成。两者分别在两个相互独立的线程中运行而实现了视图和逻辑的分离，它们通过 Native（系统层，即微信客户端）做中转实现通信，逻辑层发送网络请求也会经由 Native 转发，这种双线程通信方式是为了管控安全并避免操作 DOM，缺点是带来了无处不在的异步问题 (任何数据传递都是线程间的通信，数据需要转换为字符串并将数据内容拼接为 JS 脚本的形式，然后传递给两边的 evaluateJavascript 异步执行)。由于一个小程序存在多个界面，视图层存在多个 webview 线程。

  * __视图层__：渲染页面，运行的线程为 WKWebView (IOS) / XWeb (Android) / Chromium 60 Webview (开发者工具)。
  * __逻辑层__：运行 js 脚本，主要处理业务逻辑和数据，运行的线程为 JSCore (IOS) / V8 (Android) / NWJS (开发者工具)。
  * __系统层__：通过 JSBridge 向上提供微信的原生功能，向下实现视图层和逻辑层的双向交互 (视图层触发事件、逻辑层通知页面更新数据)。

  <div align="center"> 
    ![架构模型](/images/webchat/framework.png)
  </div>



## 渲染机制

  1. __渲染方式__：小程序使用第三种方式
    * web 渲染
    * Native 原生渲染
    * Hybrid 渲染：混合 web、Native
  2. __具体流程__：模版数据更新时容易影响性能，小程序使用 React 提出的虚拟 DOM 机制。
    1. 在视图层把 WXML 转化成对应的 JS 对象 (虚拟 DOM 树)。
    2. 在逻辑层发生数据变更时，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到视图层。
    3. 在视图层渲染出最新的虚拟 DOM，经过对比新旧两个 DOM 树获取差异，然后将差异应用在真实的 DOM 树从而更新界面。
  3. __页面渲染__
    * wxml 编译器：wcc，它将 wxml 文件转为 js 执行 wcc index.wxml。
    * wxss 编译器：wcsc，它将 wxss 文件转为 js 执行 wcsc index.wxss。

  <div align="center"> 
    ![渲染机制](/images/webchat/wxml_render.png)
  </div>


## 运行机制

  * __热启动__：假如用户已经打开过某小程序，然后在一定时间内再次打开，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动。
  * __冷启动__：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。
  * __销毁__：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。

  <div align="center"> 
    ![运行机制](/images/webchat/runing.png)
  </div>


## 更新机制

  * 开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也会在发布之后 24 小时之内下发新版本信息到用户。
  * 小程序每次冷启动时都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时使用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。
  * 如果想让用户使用最新版本的小程序，可以利用 wx.getUpdateManager 做个检查更新的功能：

  ```js
  checkNewVersion() {
    const updateManager = wx.getUpdateManager();
    updateManager.onCheckForUpdate((res) => {
      console.log('hasUpdate', res.hasUpdate);
      // 请求完新版本信息的回调
      if (res.hasUpdate) {
        updateManager.onUpdateReady(() => {
          this.setData({
            hasNewVersion: true
          });
        });
      }
    });
  }
  ```


## 组件系统

  * 基础组件
    * 基于 Exparser 框架实现组织管理的内置组件和自定义组件，包括视图容器、表单组件、导航组件等。
    * Exparser 内置在小程序基础库，为各种组件提供基础支持 (节点操作、自定义组件特性等)。
    * Exparser 基于 WebComponents 的 ShadowDOM 模型，但是不依赖其它库和浏览器的原生支持，而且可在纯 JS 环境中运行。
  * 原生组件
    * 由客户端原生实现的内置组件，包括 `camera、canvas、input(仅在focus时)、live-player\live-pusher、map、textarea、video`。
    * 它们脱离于 WebView 渲染流程之外，使用时有如下限制：
      * 层级最高，总是覆盖普通组件，后插入的原生组件覆盖之前插入的。
      * 不支持部分 CSS 样式：CSS 动画、position: fixed、overflow: hidden。
      * 不支持 bind:eventname 的事件监听、catch 和 capture 的事件绑定。
      * 遮挡 vConsole 弹出的调试面板，建议开发者在使用到原生组件时尽量在真机上调试。
    * 优点
      * 扩展 Web 的能力
      * 体验更好，减轻 WebView 的渲染工作
      * 绕过 setData、数据通信和重渲染流程，性能更好


## 基础库
> 它由 JavaScript 编写，可以被注入到视图层和逻辑层运行。

  * 功能
    * 在渲染层，提供各类组件来组件页面的元素。
    * 在逻辑层，提供各种API来处理各种元素。
    * 处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑。
  * 特点
    * 小程序的渲染层和逻辑层由两个线程管理，两个线程各自注入了基础库。
    * 基础库不会打包在小程序的代码中，它会被提前内置在微信客户端。这样做的优点是：可以降低业务小程序的代码包大小、可以单独修复基础库中的 Bug 而无需修改到业务小程序的代码包。

    


# 四、View 视图层
> 使用小程序组件来展示，包括 WXML、WXSS。将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。

## WXML 模版
  * 属于微信视图层的一套标签语言，类似 Vue 的模板语法。
  * 支持数据绑定和逻辑运算、支持模板及其引用、支持事件绑定。
  * 不支持 div、span 等标签，全部使用视图容器、基础内容等组件。


### 数据渲染

  ```xml
  <!-- 数据绑定 -->
  <view> {{name}} + a </view>
  <view id="item-{{id}}"> </view>
  <view hidden="{{status ? true : false}}"> Hidden </view>

  <!-- 条件渲染 -->
  <view wx:if="{{num > 5}}"> A </view>
  <view wx:elif="{{num > 2}}"> B </view>
  <view wx:else> C </view>

  <!-- 
    列表渲染
      一维数组：默认索引 index、选项 item 
      二/多维数组：等同于 <view wx:for="{{list}}" wx:for-item="x"></view>
  -->
  <view wx:for="{{arr}}" wx:key='{{index}}' id="{{index}}">
    <text>{{item.title}}</text>
  </view>
  <view wx:for="{{pList}}" >  
 　　{{item.id}} 
    <!-- wx:for 用于循环数组，wx:for-item 用于给列表赋别名 -->
　　<view wx:for="{{item.cList}}" wx:for-item="items" wx:for-index="idx">
      {{items.name}}：{{item.account}}
    </view> 
  </view>

  Page({
    data:{
      name: 'Mike',
      id: 0,
      status: false,
      arr: [1, 2, 3]
    }
  })
  ```


### 模板使用

  * 基础使用
    * name：定义模版名称
    * is：用于引用指定模版
    * data：用于传入模版数据
    ```xml
    <!-- 1.xml -->
    <template name="msgItem">
      <view>
        <text> {{index}}: {{msg}} </text>
        <text> Time: {{time}} </text>
      </view>
    </template>
    <template is="msgItem" data="{{...item}}" />
    Page({
      data: {
        item: {
          index: 0,
          msg: 'item msg',
          time: '2016-09-15'
        } 
      }
    })

    <!-- 2.xml -->
    <template name="content-item">
      <block wx:if="{{content.type == 'TEXT'}}">
        <view style="margin-top:30rpx">
          <text wx:if="{{content.type == 'TEXT'}}" class="text">
          {{content.content}}</text>
        </view>
      </block>
      <block wx:if="{{content.type == 'IMAGE'}}">
        <image class="media" 
            mode="aspectFill" 
            src="{{content.content}}" 
            bindtap="enterPreviewMode" 
            data-src="{{content.content}}">
        </image>
        <view style="margin-top: 10rpx">{{content.description}}</view>
      </block>
    </template>
    <view wx:for="{{diary.list}}" wx:for-item="content" class="content">
      <template is="content-item" data="{{content}}"></template>
    </view>
    ```
  * 页面引用
    * `import` 引用模版内容，不能多重引用
    * `include` 引用模版内容，就可以多重引用
    ```xml
    <!-- test.wxml -->
    <template name="test">
        <view>{{text}}</view>
    </template>

    <!-- index.wxml -->
    <import src="test.wxml" /> 
    <template is="test" data="{{text}}"></template>

    <include src="header.wxml"/>
    <view> body </view>
    <include src="footer.wxml"/>
    ```


### 事件绑定
  * 绑定：`bind/catch + 事件`，区别是 bind 不阻止冒泡而 catch 阻止
  * 事件：`touchstart、touchmove、touchend、touchcancel、longtap、tap`
    * 事件对象：event 包含 currentTarget、target 等事件触发的相关信息
    * 传参方式：`data-hi、dataset`，类似 html 的自定义属性 data-xxx
    * 点击事件：绑定时不能用 bindclick `<view bindtap="doTap"></view>`
  * 数据
    * 传递数据：`<view data-prop></view>`
    * 获取数据：`this.data[prop]`
    * 修改数据：`this.setData({ })`

  ```xml
  <view class="list" >
      <view class='box' 
          wx:for='{{list}}' 
          wx:key='{{index}}' 
          data-itemId='{{item.id}}' 
          bindtap='clickMe'>

          <text>{{item.title}}</text>
          <image src='{{item.img}}'></image>
      </view> 
  </view>
  Page({
    clickMe: function(e) {
      wx.navigateTo({
          url: '../../pages/test/test?id=${e.currentTarget.dataset.itemId}‘
      })
    }
  })
  ```


## WXSS 样式

  * 支持大部分 CSS 特性
  * 新增尺寸单位 rpx，可根据屏幕宽度自适应
  * 使用 @import 语句可以导入外联样式表
  * 支持 class、id、element、::before、::after  
  * 不支持 less、sass 等写法，不支持级联选择器，不支持多层选择器：避免被组件内结构破坏


## WXS 模块
> Weixin Script 脚本的简称，用于增强 WXML 的功能而可以直接调用 JS 方法，使用时将 wxs 文件或标签作为一个模块。

### 使用方式

  * __wxs 标签__：wxml 文件中直接使用
    ```xml
    <wxs moudle="tools">
      var a = require("./tools.wxs")

      function my_slice(str, a, b){
        return str.slice(a, b)
      }
      moudle.exports = {
        my_slice: my_slice,
        msg: "hello"
      }
    </wxs>
    <view>{{tools.my_slice("123456", 0, 5)}}</view>
    ```
  * __wxs 文件__：wxml 文件中引用
    ```xml
    <wxs src="../../utils/string.wxs" module="tools"></wxs>
    <view>{{tools.msg}}</view>
    ```


### 模块引用
> wxs 模块中可以通过 require 引用其它 wxs 文件，注意点如下

  * 只能引用 wxs 文件，并且必须使用相对路径
  * wxs 模块如果在定义后一直没有被引用，则不会被解析运行
  * wxs 模块都是单例，多处、多次引用时使用的都是同一个模块对象



# 四、App Service 逻辑层
> 将数据进行处理后发送给视图层，同时接受视图层的事件反馈。

  * 每个页面都有独立的作用域，并提供模块化能力。
  * App() 是小程序的入口，Page() 是页面的入口。
  * 小程序提供了丰富的 API，它们通过 JSBridge 和 Native 进行通信。
  

## 绑定
  
  * 数据绑定使用 Mustache 语法（双大括号）将变量包起来，动态数据均来自对应 Page 的 data，可以通过 setData 方法修改数据。
  * 事件绑定的写法为 `bind/catch + 事件类型 = "事件名"`，比如 bindtap, catchtouchstart，事件名需要在对应的 Page 中定义同名的函数。


## 生命周期

### App 应用
  <div align="center"> 
    ![App 应用生命周期](/images/webchat/app_life.png)
  </div>


### Page 页面
  <div align="center"> 
    ![Page 页面生命周期](/images/webchat/page_life.png)
  </div>

  
### 影响结果
  <div align="center"> 
    ![Page 页面生命周期](/images/webchat/app_to_page.png)
  </div>


## 数据请求
> 必须是 https 请求，需要到小程序的后台设置合法域名。

  ```js
  // 项目目录新建文件： utils/request.js
  const app = getApp()
  export default function request(url, options = {}) {
    return new Promise(function (resolve, reject) {
      wx.request({
        url: `${app.origin}${url}`,
        method: 'GET',
        ...options,
        data: options.data,
        header: {
          'content-type': 'application/json',
          'cookie': wx.getStorageSync("cookie")
        },
        success: function (res) {
          //重新授权登录
          if (res.statusCode === 401){
            wx.redirectTo({url: '/pages/login/index'})
            return
          }else if (res.statusCode !== 200) {
            reject({ error: '服务器忙，请稍后重试', code: 500 });
            return
          } else {
            if (url === '/api/cdz/user/weixin/login') {
              const cookie = res.header["set-cookie"] || res.header["Set-Cookie"];
  　　　　　　　　
              if (cookie) wx.setStorageSync("cookie", cookie);
            }
            resolve(res.data);
          }
        },
        fail: function (res) {
          if (url === '/api/cdz/user/weixin/login') {
            const cookie = res.header["set-cookie"] || res.header["Set-Cookie"];
            if (cookie) wx.setStorageSync("cookie", cookie);
          }
          reject({ error: '网络错误', code: 0 });
        }
      })
    })
  }

  // 封装 API
  import request from "../utils/request";

  export function testPost(data) {
    return request(`/api/test/post`, {
      method: 'PUT',
      data,
    })
  }

  export function testGet(data) {
    return request(`/api/test/get`)
  }
  ```




# 三、组件化开发
> 开发者可以将页面内的功能模块抽象成自定义组件，具有高内聚、可复用的特点。

## 官方组件
> 小程序不支持 html 标签，全部使用视图容器、基础内容等组件渲染页面

  <div align="center"> 
    ![小程序组件](/images/webchat/com.png)
  </div>


## block 标签
> block 仅仅是一个包装元素而并不是一个组件，它只接受控制属性，不会在页面中做任何渲染

  ```xml
  <block wx:if="{{true}}">
      <view> text </view>
  </block>

  <block wx:for="{{[1, 2, 3]}}">
      <view> {{index}}: {{item}}</view>
  </block>
  ```


## 自定义组件
> 开发者可以将页面内的功能模块抽象成自定义组件，具有高内聚、可复用的特点

  * 优点
    * 可以在不同的页面中重复使用
    * 可以将复杂的页面拆分成多个低耦合的模块有助于代码维护
  * 实现
    * 根目录新建文件夹 components 
    * components 目录下新建 Item 文件夹
    * Item 右键点击新建 Component 并命名 item
    * 编辑自动生成的组件组成文件：`json、wxml、wxss、js`
    ```js
    /**
     *  默认只能有一个 slot 插槽，需要使用多个时需要声明启用
     *  除继承样式外，全局样式、组件所在页面的的样式对自定义组件无效
    **/
    
    // item.json：配置文件
    {
      "component": true,      // 声明这个是组件
      "usingComponents": {}   // 表示在该组件中可使用其它组件
    }

    // item.js：逻辑交互文件，定义组件的属性、数据及方法
    Component({
      behaviors: [],  // 类似 vue mixins、traits 的组件间代码复用机制
      relations: {},  // 定义关联
      options: {
        multipleSlots: true    // 启用多 slot 支持
        addGlobalClass: true,  // 使组件接受全局样式，尽量避免
      },
      properties: {    // 对外定义的接收属性
        innerText: {
          type: String,  // String、Number、Boolean、Object、Array、null
          value: "",     // 默认值
          observer(newVal, oldVal, changedPath){ }  // 属性被改变时执行的函数
        }
        message: String    // 简写方式
      },
      data: {   // 私有数据，组件的初始数据
        isShow: false
      },
      methods: {
        showData(){
          this.setData({
            isShow: !this.data.isShow
          })
        },
        // 内部私有方法建议以下划线开头
        // triggerEvent 用于触发事件
        _confirmEvent(){
          this.triggerEvent("confirmEvent");
        }
      },
      externalClasses: ['tag-class'],  // 使用外部类名样式，尽量避免
      lifetimes: {        // 生命周期函数
        created(){},
        attached(){},     // vue beforeMount
        ready(){},        // vue mounted
        moved(){},        // 组件位置更新
        detached(){}      // 组件卸载
      },
      pageLifetimes: {   // 组件所在页面的生命周期函数
        show() { },
        hide() { },
        resize() { },
      },
      definitionFilter: {}     // 组件扩展
    })
    
    // item.wxss：样式文件，注意只能通过类名指定
    @import "../../app.wxss";  // 引入公共样式
    .inner{
      color: red;
    }

    // item.wxml：模版文件
    <view class="inner">
        <view catchtap='_confirmEvent'>{{innerText}}</view>
    </view>
    <slot>单个插槽</slot>

    <view class="wrapper">
      <slot name="before">插槽 before</slot>
      <view class="inner">{{innerText}}</view>
      <slot name="after">插槽 after</slot>
    </view>
    ```
  4. 页面文件中使用
    ```js
    // index.json
    {
      "navigationBarTitleText": "index 页面",
      "usingComponents": {
        "myItem": "/components/item/item"
      }
    }

    // index.wxml
    <view class="wrapper">
      <myItem 
        innerText="确定"
        bind:confirmEvent="_confirmEvent">
        <view>插入到卡槽</view>
      </myItem>
      <button type="primary" bindtap="showData"> ClickMe </button>
    </view>

    <view class="wrapper">
      <view slot="before">插入到卡槽 before</view>
      <view slot="after">插入到卡槽 after</view>
    </view>

    // index.js
    const app = getApp()
    Page({
      onReady: function () {
        this.item = this.selectComponent("#item");
      },
      showData(){
        this.item.showData();
      },
      _confirmEvent(){
        this.item.hideData();
      }
    })
    ```


## 组件通信

### 父传子：数据绑定
  * 父组件 wxss 子组件标签添加属性：`	<submit-bar id="{{id}}"></submit-bar>`
  * 子组件 js 通过 properties 接收：`properties: { id: Number }`


### 子传父：事件触发
  * 子组件触发事件
    * `this.triggerEvent('myevent', { id: 1 }, myEventOption)`
    * 自定义事件名、传递数据的 detail 对象、事件选项（是否冒泡等）
  *  父组件捕获事件
    * 子组件标签绑定自定义事件：`	<submit-bar bind:submit="submit"></submit-bar>`
    * 监听事件执行并接收数据：`submit(event){ event.detail.id }`


### 父组件获取子组件实例
  * `<compontent id="modal"></compontent>`
  * `var modal = this.setlectComponet('#modal')`

 
## 组件共享
> behaviors 用于组件间代码共享一组属性、数据、生命周期函数和方法，类似 mixins

  ```js
  // 新建 my-behavior.js
  module.exports = Behavior({
    behaviors: [],
    properties: {
      carModel: String,
      price: Number,
      sale: Boolean
    },
    data: {
      behaviorData1: "eyes on me"
    },
    attached: function() { },
    methods: {
      behaviorMethod: function() { }
    }
  })

  // 组件中使用
  
  // com.js
  Component({
    behaviors: [myBehavior],  // 挂载 Behavior
    properties: {},
    data: {
      me: '组件自身数据'
    },
    methods: {}
  })

  // com.wxml
  <view class="container">
    <view>组件 data：{{me}}</view>
    <view>共有 data：{{behaviorData1}}</view>
    <view>共有 property：{{price}}</view>
    <button bindtap="behaviorMethod">共有方法</button>
  </view>
  ```


# 五、路由功能

## 页面跳转
  * __实现 API__
    * `wx.navigateTo`：保留当前页面，跳转到应用内的某个页面
    * `wx.redirectTo`：关闭当前页面，跳转到应用内的某个页面
    * `wx.navigateBack`：关闭当前页面，回退前一页面
  * __接口说明__
    * 如果某页面设置为 tab 页，则只支持 wx.switchTab
    * wx.navigateTo 全局最多调用 5 次
  * __接口使用__
    * 对于可逆操作，使用 wx.navigateTo，比如从首页跳转到二级页面，从二级页面返回是不需要重新渲染首页。
    * 对于不可逆操作，使用 wx.redirectTo，比如用户登录成功后关闭登录页面，不能返回到登录界面。
    * 对于一些介绍性等不常用页面，使用 wx.redirectTo、wx.navigatrBack
    * 不要在首页使用 wx.redirectTo，这样会导致应用无法返回首页
  * __应用场景__
    * 小程序启动，初始化第一个页面
    * 打开新页面，调用 API wx.navigateTo 或使用 navigator 组件
    * 页面重定向，调用 API wx.redirectTo 或使用 navigator 组件
    * 页面返回，调用 API wx.navigateBack 或用户按左上角返回按钮
    * tarbar 切换  


  ```js
  // API
  wx.navigateTo({
    url: 'pages/logs/index',
    success: function(res){ },
    ...
  })

  wx.redirectTo({
    url: 'pages/logs/index',
    success: function(res){ },
    ...
  })

  /**
   * 用户点击左上角返回按钮，或调用 wx.navigateBack 返回上一页
   * delta 为 1 时表示返回上一页，为 2 时表示上上一页，以此类推
   * 如果 dalta 大于已打开的页面总数，则返回到首页。返回后元界面会销毁
  **/
  wx.navigateBack({
      delta: 1
  })

  /**
   * 组件
   *     默认 redirect: false，等同于 wx.navigateTo 接口
   *     添加 redirect 属性时，等同于 wx.redirectTo 接口
  **/
  <navigator url="pages/logs/index" hover-class="navigator-hover">跳转</navigator>
  ```

 
## 页面栈
  * 页面栈以栈（先进后出）的形式维护页面与页面之间的关系
  * 小程序提供了 getCurrentPages() 函数获取页面栈，第一个元素为首页，最后一个元素为当前页面
  * 页面跳转对页面栈大小的影响
    * `wx.redirectTo`
      * 不会增加页面栈大小
      * 从四级页面重定向到二级页面，此时会将关闭四级页面，并使用二级页面替换四级页面，但两个页面状态独立。此时的页面栈大小不变
    * `wx.navigateTo`
      * 每新开一个页面，页面栈大小加 1 直到为 5 为止
      * 从四级页面跳转到二级页面，此时会在页面栈顶添加一个二级页面的初始状态界面，但两个页面状态独立。页面栈大小加 1，如果是 5 则 wx.navigateTo 无效
    * `wx.navigateBack`：会减少页面栈大小，直到页面栈大小为 1

  <div align="center"> 
    ![页面跳转与页面栈](/images/webchat/page_stack.png)
  </div>


## 页面传值

### 事件传参

  ```js
  // view data-id='{{id}}' data-list='list' bindtap='clickMe'
  Page({
    clickMe: function(event) {
      // 字符串
      let id = e.currentTarget.dataset.id
      // 数组
      var albumList = e.currentTarget.dataset.list.split(",");
    }
  })
  ```


### 路由传参
> 适用于传递少量数据，注意 wx.switchTab 中的 url 不能传参

  ```js
  // A 页面传递数据：wxml 标签、js
  <navigator url="../detail/detail?name={{name}}&id=1"></navigator>
  
  wx.navigateTo({
    url: `/pages/detail/detail?id=${e.currentTarget.dataset.id}`,
    url: '/pages/detail/detail?name=' + this.data.name
  })
  

  // B 页面接收数据：pages/detail/detail.js
  Page({
    onLoad: function(option){
      this.setData({
          detail_id: options.id,
          detail_name: options.name
      })
    }
  })
  ```


### 全局变量
> 通过在 App.js 中设置 globalData 

  ```js
  // App.js：初始值
  App({
    globalData:{
      appid: '1wqas2342dasaqwe232342xxx',
      secret: 'e0dassdadef2424234209bwXXX',
      openid: '你好',
      deviceInfo: null,    // 设备信息，主要用于获取屏幕尺寸而做适配
    },
    // 获取日记列表
    getDiaryList(cb) {
      if (this.globalData.diaryList) {
        typeof cb == 'function' && cb(this.globalData.diaryList)
      } else {
        // 模拟数据 diaries.js：module.exports = { }
        const diaries = require('demo/diaries')
        list.push(...diaries)
        this.globalData.diaryList = list
        typeof cb == 'function' && cb(this.globalData.diaryList)
      }
    },
  })

  // test.js：可修改
  let app = getApp();
  Page({
    getDiary(params){
      app.globalData.openid = "12345";
      app.getDiaryList(list => {
        if (typeof id === 'undefined') {
          diary = list[0];
        } else {
          diary = list[id];
        }
      })
    }
  })
  ```


### 本地缓存
> 单个密钥允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB

  ```js
  // 1. 添加缓存
  set() {
    // 异步存储
    wx.setStorage({
        key: 'user',
        data: 'cck',
        success: ()=> {
          console.log('存储成功');
        }
    })
    // 同步存储
    try {
        wx.setStorageSync('user', 'cck')
    } catch (e) { 

    }
  }

  // 2. 获取缓存
  get(){
    // 异步
    wx.getStorage({
      key: 'user',
      success (res) {
        console.log(res.data)
      }
    })
    // 同步
    try {
      var value = wx.getStorageSync('user')

    } catch (e) {}
  }

  // 3. 移除缓存
  remove(){
    // 异步
    wx.removeStorage({
      key: 'user',
      success (res) {
        console.log(res.data)
      }
    })

    // 同步
    try {
      wx.removeStorageSync('user')

    } catch (e) { }
  }
  ```


### 页面栈
> 首页 index 进入列表页 list，然后进入详情页 detail，此时如果需要从 detail 页一键返回到 index 页并且传值给 index 页，这里就可以用页面栈来实现

  * 不要尝试修改页面栈，会导致路由以及页面状态错误
  * 不要在 App.onLaunch 时调用 getCurrentPages()，此时 page 还没有生成


  ```js
  // 详情页：view bindtap='backToIndex'> 返回首页
  Page({
    data: {
      tag: '土豆'
    },
    backToIndex () {
      // 获取当前的页面栈实例，pages 是一个根据栈的顺序存储了所有页面的数组
      let pages = getCurrentPages()
      
      wx.navigateBack({
        delta: 2,
        success () {
          pages[0].setData({
            tag: this.data.tag
          })
        }
      })
    },
  })

  // 首页：<view> {{tag}}
  Page({
    data: {
      tag: ''
    }
  })
  ```


### input 搜索传值
  * `<input auto-focus bindinput="bindKeyInput" bindconfirm='goSearch' />`
  * __bindinput__：键盘输入时触发，`event.detail = {value, cursor, keyCode}`
  * __bindconfirm__：点击完成按钮时触发，`event.detail = {value: value}`

  ```js
  // pages/search/search.js 
  Page({ 
    data: {
      inputValue: ''
    }, 

    bindKeyInput(e) {
      this.setData({
        inputValue: e.detail.value
      })
    },

    // 进入搜索结果页
    goSearch() {
      let content = this.data.inputValue
      if (!content) { return } 

      wx.navigateTo({
        url: `/pages/list/list?content=${content}`,
      })
    }
  })
  ```




