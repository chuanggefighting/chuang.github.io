---
title: 微信小程序入门
tags:
  - 微信小程序
categories: 微信小程序
top: false
keywords:
  - 微信小程序
date: 2019-07-07 00:22:18
description: 简单了解小程序的特点、语法、功能
---

# 一、入门简介
  <div style="text-indent: 2em;">小程序是一套特殊的东西，融合了原生和 web 端。它是一个不完整的浏览器对象，所以很多 DOM、BOM 的东西无法使用，但是它又通过微信APP实现了多线程。小程序的思想是：小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。框架提供了自己的视图层描述语言 WXML、WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。</div>


## 主要特点

  * 使用轻便。它不需要安装而是通过扫描二维码等打开后直接执行，用完后也不需要卸载
  * 微信不会提供类似小程序商店的地方，需要小程序提供者自己通过二维码，群分享的手段来传播，这就是去中心化的形态
  * 微信朋友圈提供了好友之间沟通信息的手段，订阅号提供了面向粉丝推送信息的手段，而小程序则是提供了用户通过自己的操作而与服务实现互动的手段。
  * 小程序就是将微信官方提供的 20+ 个基础组件（目前有26个）进行排列组合，然后加上一些css样式，对用户的操作进行反馈（调微信官方提供的60+个api）


## 语法特点

  * __标签__
    * 小程序不支持 div、span 等标签，全部使用视图容器、基础内容等组件
  * __样式__
    * 推荐使用 rpx 为单位，可以根据屏幕宽度进行自适应
    * 不支持 less、sass 等写法
    * 不支持 p:last-child 等级联选择器 
    * 支持 ::before、::after
  * __交互__：采用 js 语法，但是不能获取和操作 dom
    * 绑定：`bind、catch`，区别是 bind 不阻止冒泡而 catch 阻止
    * 事件：`touchstart、touchmove、touchend、touchcancel、longtap、tap`
      * 事件对象：event 包含 currentTarget、target 等事件触发的相关信息
      * 传参方式：`data-hi、dataset`，类似 html 的自定义属性 data-xxx
    * 样式
      * 不能直接获取 dom 控制样式
      * 只能通过 data 里的属性控制样式的变化
    * 请求
      * 小程序里称为 `wx.request`，用法类似于 ajax
      * 注意请求必须是 https 请求，并且需要到小程序的后台里设置合法域名
    ```js
    wx.request({
      url: '',
      data: { id: 1 }, 
      method: "GET", 
      dataType: "json", 
      success: function (res) { 
        // 如果 ajax 获取的图片数据不能正常显示，则给图片添加属性 lazy-onLoad
        this.datas = res.data
      },
      fail: function (err) { 
      },
      complete: function (res) { 
      }
    })
    ```


## 程序限制

### 程序限制
  * 样式表不支持级联选择器
  * 不支持 A 标签，无法打开普通网页
  * 脚本内不能使用 window、document 等对象
  * background-image 不能加载本地资源，可以是 网络图片、base64、标签


### 数量限制
  * 一个应用同时只能打开 5 个页面
  * 底部或顶部可以添加的 tab 按钮区域 tabBar 是一个数组，只能配置 2 ～ 5 个 tab
  * wx.request 请求最开始最大并发数是 10 个


### 大小限制
  * tabBar 的按钮 iconPath 图片路径，icon 大小限制为 40kb
  * setData 页面传递数据单次设置的数据不能超过1024kB
  * setStorage 本地缓存最大为 10MB
  * 小程序源码打包后的大小限制为 1M




# 二、基础语法

## WXML 视图
> 属于微信视图层的一套标签语言，类似于 Vue 的模板语法


### 数据渲染

  ```xml
  <!-- 数据绑定 -->
  <view> {{name}} + a </view>
  <view id="item-{{id}}"> </view>
  <view hidden="{{status ? true : false}}"> Hidden </view>

  <!-- 条件渲染 -->
  <view wx:if="{{num > 5}}"> A </view>
  <view wx:elif="{{num > 2}}"> B </view>
  <view wx:else> C </view>

  <!-- 列表渲染：默认索引 index、选项 item -->
  <view wx:for="{{arr}}" wx:key='{{index}}'>
    <text>{{item.title}}</text>
  </view>

  Page({
    data:{
      name: 'Mike',
      id: 0,
      status: false,
      arr: [1, 2, 3]
    }
  })
  ```


### 模板定义
> name 定义模版名称、is 用于引用指定模版、data 用于传入模版数据

  ```xml
  <template name="msgItem">
    <view>
      <text> {{index}}: {{msg}} </text>
      <text> Time: {{time}} </text>
    </view>
  </template>

  <template is="msgItem" data="{{...item}}" />
  Page({
    data: {
      item: {
        index: 0,
        msg: 'item msg',
        time: '2016-09-15'
      } 
    }
  })
  ```


### 模块引用
  * import 引用模版内容，不能多重引用
  * include 引用模版内容，就可以多重引用

  ```xml
  <!-- test.wxml -->
  <template name="test">
      <view>{{text}}</view>
  </template>

  <!-- a.wxml -->
  <import src="test.wxml" /> 
  <template is="test" data="{{text}}">
  </template>


  <!-- 引用 header -->
  <include src="header.wxml"/>
  <view> body </view>
  <include src="footer.wxml"/>
  ```


### 事件绑定

  * 绑定：`bind/catch + 事件`，区别是 bind 不阻止冒泡而 catch 阻止
  * 事件名：`touchstart、touchmove、touchend、touchcancel、longtap、tap`
  * 注意：绑定点击事件时不能用 bindclick：`<view bindtap="doTap"></view>`
  * 数据
    * 传递数据：`<view data-prop></view>`
    * 获取数据：`this.data[prop]`
    * 修改数据：`this.setData({ })`

  ```xml
  <view class="list" >
      <view class='box' 
          wx:for='{{list}}' 
          wx:key='{{index}}' 
          data-itemId='{{item.id}}' 
          bindtap='clickMe'>

          <text>{{item.title}}</text>
          <image src='{{item.img}}'></image>
      </view> 
  </view>
  Page({
    clickMe: function(e) {
      wx.navigateTo({
          url: '../../pages/test/test?id=${e.currentTarget.dataset.itemId}‘
      })
    }
  })
  ```


## WXS 模块
> Weixin Script 脚本的简称，用于增强 WXML 的功能而可以直接调用 JS 方法，使用时将 wxs 文件或标签作为一个模块

### 模块引用
> wxs 模块中可以通过 require 引用其它 wxs 文件，注意点如下

  * 只能引用 wxs 文件，并且必须使用相对路径
  * wxs 模块如果在定义后一直没有被引用，则不会被解析运行
  * wxs 模块都是单例，多处、多次引用时使用的都是同一个模块对象


### 使用方式

  * wxs 标签：wxml 文件中直接使用
    ```xml
    <wxs moudle="tools">
      var a = require("./tools.wxs")

      function my_slice(str, a, b){
        return str.slice(a, b)
      }
      moudle.exports = {
        my_slice: my_slice,
        msg: "hello"
      }
    </wxs>
    <view>{{tools.my_slice("123456", 0, 5)}}</view>
    ```
  * wxs 文件：wxml 文件中引用
    ```xml
    <wxs src="../../utils/string.wxs" module="tools"></wxs>
    <view>{{tools.msg}}</view>
    ```


## 生命周期

### App 应用
  <div align="center"> 
    ![App 应用生命周期](/images/webchat/app_life.png)
  </div>


### Page 页面
  <div align="center"> 
    ![Page 页面生命周期](/images/webchat/page_life.png)
  </div>

  
### 影响结果
  <div align="center"> 
    ![Page 页面生命周期](/images/webchat/app_to_page.png)
  </div>


## 数据请求

  ```js
  // 项目目录新建文件： utils/request.js
  const app = getApp()
  export default function request(url, options = {}) {
    return new Promise(function (resolve, reject) {
      wx.request({
        url: `${app.origin}${url}`,
        method: 'GET',
        ...options,
        data: options.data,
        header: {
          'content-type': 'application/json',
          'cookie': wx.getStorageSync("cookie")
        },
        success: function (res) {
          //重新授权登录
          if (res.statusCode === 401){
            wx.redirectTo({url: '/pages/login/index'})
            return
          }else if (res.statusCode !== 200) {
            reject({ error: '服务器忙，请稍后重试', code: 500 });
            return
          } else {
            if (url === '/api/cdz/user/weixin/login') {
              const cookie = res.header["set-cookie"] || res.header["Set-Cookie"];
  　　　　　　　　
              if (cookie) wx.setStorageSync("cookie", cookie);
            }
            resolve(res.data);
          }
        },
        fail: function (res) {
          if (url === '/api/cdz/user/weixin/login') {
            const cookie = res.header["set-cookie"] || res.header["Set-Cookie"];
            if (cookie) wx.setStorageSync("cookie", cookie);
          }
          reject({ error: '网络错误', code: 0 });
        }
      })
    })
  }

  // 封装 API
  import request from "../utils/request";

  export function testPost(data) {
    return request(`/api/test/post`, {
      method: 'PUT',
      data,
    })
  }

  export function testGet(data) {
    return request(`/api/test/get`)
  }
  ```


## 使用 npm
> 因为小程序使用的是不完整的浏览器对象，所以很多 js 包无法使用。npm 可用来引入 moment 等插件，但是要注意不能通过 npm 引入没有 js 文件的 UI 库 weui，它可以通过直接下载文件并放到根目录，然后在 app.wxss 文件的开头引入。 

  1. 微信开发者工具、详情、使用 npm 模块
  2. 项目的根目录打开命令行：npm init、npm i
  3. 微信开发者工具、工具、构建 npm。此时小程序会将 node_modules 文件编译打包并生成新目录 miniprogram_npm
  4. 对应页面的 js 文件引入后直接使用即可：const moment= require('moment')
  5. 新建忽略文件 .gitignore，添加不需要上传的文件如 node_modules 、 package_lock.json


# 三、路由功能

## 页面跳转
  * __微信接口__
    * `wx.navigateTo`：保留当前页面，跳转到应用内的某个页面
    * `wx.redirectTo`：关闭当前页面，跳转到应用内的某个页面
    * `wx.navigateBack`：关闭当前页面，回退前一页面
  * __接口说明__
    * 如果某页面设置为 tab 页，则只支持 wx.switchTab
    * wx.navigateTo 全局最多调用 5 次
  * __接口使用__
    * 对于可逆操作，使用 wx.navigateTo，比如从首页跳转到二级页面，从二级页面返回是不需要重新渲染首页
    * 对于不可逆操作，使用 wx.redirectTo，比如用户登录成功后关闭登录页面，不能返回到登录界面
    * 对于一些介绍性等不常用页面，使用 wx.redirectTo、wx.navigatrBack
    * 不要在首页使用 wx.redirectTo，这样会导致应用无法返回首页
  * __应用场景__
    * 小程序启动，初始化第一个页面
    * 打开新页面，调用 API wx.navigateTo 或使用 navigator 组件
    * 页面重定向，调用 API wx.redirectTo 或使用 navigator 组件
    * 页面返回，调用 API wx.navigateBack 或用户按左上角返回按钮
    * tarbar 切换  


  ```js
  // API
  wx.navigateTo({
    url: 'pages/logs/index',
    success: function(res){ },
    ...
  })

  wx.redirectTo({
    url: 'pages/logs/index',
    success: function(res){ },
    ...
  })

  /**
   * 用户点击左上角返回按钮，或调用 wx.navigateBack 返回上一页
   * delta 为 1 时表示返回上一页，为 2 时表示上上一页，以此类推
   * 如果 dalta 大于已打开的页面总数，则返回到首页。返回后元界面会销毁
  **/
  wx.navigateBack({
      delta: 1
  })

  /**
   * 组件
   *     默认 redirect: false，等同于 wx.navigateTo 接口
   *     添加 redirect 属性时，等同于 wx.redirectTo 接口
  **/
  <navigator url="pages/logs/index" hover-class="navigator-hover">跳转</navigator>
  ```

 
## 页面栈
  * 页面栈以栈（先进后出）的形式维护页面与页面之间的关系
  * 小程序提供了 getCurrentPages() 函数获取页面栈，第一个元素为首页，最后一个元素为当前页面
  * 页面跳转对页面栈大小的影响
    * `wx.redirectTo`
      * 不会增加页面栈大小
      * 从四级页面重定向到二级页面，此时会将关闭四级页面，并使用二级页面替换四级页面，但两个页面状态独立。此时的页面栈大小不变
    * `wx.navigateTo`
      * 每新开一个页面，页面栈大小加 1 直到为 5 为止
      * 从四级页面跳转到二级页面，此时会在页面栈顶添加一个二级页面的初始状态界面，但两个页面状态独立。页面栈大小加 1，如果是 5 则 wx.navigateTo 无效
    * `wx.navigateBack`：会减少页面栈大小，直到页面栈大小为 1

  <div align="center"> 
    ![页面跳转与页面栈](/images/webchat/page_stack.png)
  </div>


## 页面传值

### 事件传参

  ```js
  // view data-id='{{id}}' data-list='list' bindtap='clickMe'
  Page({
    clickMe: function(event) {
      // 字符串
      let id = e.currentTarget.dataset.id
      // 数组
      var albumList = e.currentTarget.dataset.list.split(",");
    }
  })
  ```


### 路由传参
> 适用于传递少量数据，注意 wx.switchTab 中的 url 不能传参

  ```js
  // A 页面传递数据：wxml 标签、js
  <navigator url="../detail/detail?name={{name}}&id=1"></navigator>
  
  wx.navigateTo({
    url: `/pages/detail/detail?id=${e.currentTarget.dataset.id}`,
    url: '/pages/detail/detail?name=' + this.data.name
  })
  

  // B 页面接收数据：pages/detail/detail.js
  Page({
    onLoad: function(option){
      this.setData({
          detail_id: options.id,
          detail_name: options.name
      })
    }
  })
  ```


### 全局变量
> 通过在 App.js 中设置 globalData 

  ```js
  // App.js：初始值
  App({
    globalData:{
      appid: '1wqas2342dasaqwe232342xxx',
      secret: 'e0dassdadef2424234209bwXXX',
      openid: '你好'
    }
  })

  // test.js：可修改
  let app = getApp();
  app.globalData.openid = "12345";
  ```


### 本地缓存
> 单个密钥允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB

  ```js
  // 1. 添加缓存
  set() {
    // 异步存储
    wx.setStorage({
        key: 'user',
        data: 'cck',
        success: ()=> {
          console.log('存储成功');
        }
    })
    // 同步存储
    try {
        wx.setStorageSync('user', 'cck')
    } catch (e) { 

    }
  }

  // 2. 获取缓存
  get(){
    // 异步
    wx.getStorage({
      key: 'user',
      success (res) {
        console.log(res.data)
      }
    })
    // 同步
    try {
      var value = wx.getStorageSync('user')

    } catch (e) {}
  }

  // 3. 移除缓存
  remove(){
    // 异步
    wx.removeStorage({
      key: 'user',
      success (res) {
        console.log(res.data)
      }
    })

    // 同步
    try {
      wx.removeStorageSync('user')

    } catch (e) { }
  }
  ```


### 页面栈
> 首页 index 进入列表页 list，然后进入详情页 detail，此时如果需要从 detail 页一键返回到 index 页并且传值给 index 页，这里就可以用页面栈来实现

  * 不要尝试修改页面栈，会导致路由以及页面状态错误
  * 不要在 App.onLaunch 时调用 getCurrentPages()，此时 page 还没有生成


  ```js
  // 详情页：view bindtap='backToIndex'> 返回首页
  Page({
    data: {
      tag: '土豆'
    },
    backToIndex () {
      // 获取当前的页面栈实例，pages 是一个根据栈的顺序存储了所有页面的数组
      let pages = getCurrentPages()
      
      wx.navigateBack({
        delta: 2,
        success () {
          pages[0].setData({
            tag: this.data.tag
          })
        }
      })
    },
  })

  // 首页：<view> {{tag}}
  Page({
    data: {
      tag: ''
    }
  })
  ```


### input 搜索传值
  * `<input auto-focus bindinput="bindKeyInput" bindconfirm='goSearch' />`
  * __bindinput__：键盘输入时触发，`event.detail = {value, cursor, keyCode}`
  * __bindconfirm__：点击完成按钮时触发，`event.detail = {value: value}`

  ```js
  // pages/search/search.js 
  Page({ 
    data: {
      inputValue: ''
    }, 

    bindKeyInput(e) {
      this.setData({
        inputValue: e.detail.value
      })
    },

    // 进入搜索结果页
    goSearch() {
      let content = this.data.inputValue
      if (!content) { return } 

      wx.navigateTo({
        url: `/pages/list/list?content=${content}`,
      })
    }
  })
  ```



# 四、组件化开发
> 开发者可以将页面内的功能模块抽象成自定义组件，具有高内聚、可复用的特点。可以在不同的页面中重复使用，也可以将复杂的页面拆分成多个低耦合的模块有助于代码维护。

## 小程序组件
  <div align="center"> 
    ![小程序组件](/images/webchat/com.png)
  </div>


## 自定义组件
> 一个组件包括 json、wxml、wxss、js 四个文件，如下 item 组件

  1. 根目录新建文件夹 components 
  2. 新建自定义组件目录 item
  3. 编辑组件的组成文件
    ```js
    /**
     *  默认只能有一个 slot 插槽，需要使用多个时需要声明启用
     *  除继承样式外，全局样式、组件所在页面的的样式对自定义组件无效
    **/
    
    // item.json：配置文件
    {
      "component": true,      // 声明这个是组件
      "usingComponents": {}   // 表示在该组件中可使用其它组件
    }

    // item.js：逻辑交互文件，定义组件的属性、数据及方法
    Component({
      behaviors: [], // 类似 vue 的 mixins、traits 的组件间代码复用机制
      relations: {}, // 定义关联
      options: {
        multipleSlots: true    // 启用多 slot 支持
        addGlobalClass: true,  // 使组件接受全局样式，尽量避免
      },
      properties: {    // 对外定义的接收属性
        innerText: {
          type: String,  // String、Number、Boolean、Object、Array、null
          value: 'hello world',    // 默认值
          observer(newVal, oldVal, changedPath){ }  // 属性被改变时执行的函数
        }
        message: String    // 简写方式
      },
      data: {},
      methods: {},
      externalClasses: ['tag-class'],  // 使用外部类名样式，尽量避免
      lifetimes: {        // 生命周期函数
        created(){},
        attached(){},     // vue beforeMount
        ready(){},        // vue mounted
        moved(){},        // 组件位置更新
        detached(){}      // 组件卸载
      },
      pageLifetimes: {   // 组件所在页面的生命周期函数
        show() { },
        hide() { },
        resize() { },
      },
      definitionFilter: {}     // 组件扩展
    })
    
    // item.wxss：样式文件，注意只能通过类名指定
    @import "../../app.wxss";  // 引入公共样式
    .inner{
      color: red;
    }

    // item.wxml：模版文件
    <view class="inner">{{innerText}}</view>
    <slot>单个插槽</slot>

    <view class="wrapper">
      <slot name="before">插槽 before</slot>
      <view class="inner">{{innerText}}</view>
      <slot name="after">插槽 after</slot>
    </view>
    ```
  4. 组件使用
    ```js
    // 引用组件的页面文件

    // index.json
    {
      "navigationBarTitleText": "index 页面",
      "usingComponents": {
        "myItem": "/components/item/item"
      }
    }

    // index.wxml：<view class="wrapper">
    <myItem bindtap="confirm">
      <view>插入到卡槽</view>
    </myItem>
    </view>

    <view class="wrapper">
      <view slot="before">插入到卡槽 before</view>
      <view slot="after">插入到卡槽 after</view>
    </view>
    ```


## 组件通信

### 父传子：数据绑定
  * 父组件 wxss 子组件标签添加属性：`	<submit-bar id="{{id}}"></submit-bar>`
  * 子组件 js 通过 properties 接收：`properties: { id: Number }`


### 子传父：事件触发
  * 子组件触发事件
    * `this.triggerEvent('myevent', { id: 1 }, myEventOption)`
    * 自定义事件名、传递数据的 detail 对象、事件选项（是否冒泡等）
  *  父组件捕获事件
    * 子组件标签绑定自定义事件：`	<submit-bar bind:submit="submit"></submit-bar>`
    * 监听事件执行并接收数据：`submit(event){ event.detail.id }`


### 父组件获取子组件实例
  * `<compontent id="modal"></compontent>`
  * `var modal = this.setlectComponet('#modal')`

 
## 组件共享
> behaviors 用于组件间代码共享一组属性、数据、生命周期函数和方法，类似 mixins

  ```js
  // 新建 my-behavior.js
  module.exports = Behavior({
    behaviors: [],
    properties: {
      carModel: String,
      price: Number,
      sale: Boolean
    },
    data: {
      behaviorData1: "eyes on me"
    },
    attached: function() { },
    methods: {
      behaviorMethod: function() { }
    }
  })

  // 组件中使用
  
  // com.js
  Component({
    behaviors: [myBehavior],  // 挂载 Behavior
    properties: {},
    data: {
      me: '组件自身数据'
    },
    methods: {}
  })

  // com.wxml
  <view class="container">
    <view>组件 data：{{me}}</view>
    <view>共有 data：{{behaviorData1}}</view>
    <view>共有 property：{{price}}</view>
    <button bindtap="behaviorMethod">共有方法</button>
  </view>
  ```


# 五、疑问汇总

  1. __为什么脚本内不能使用 window 等对象__
    * 页面的脚本逻辑是在 JsCore 中运行，JsCore 是一个没有窗口对象的环境，所以不能在脚本中使用 window，也无法在脚本中操作组件
  2. __为什么 zepto/jquery 无法使用__：zepto/jquery 会使用到 window、document 对象
  3. __wx.navigateTo 无法打开页面__
    * 一个应用同时只能打开 5 个页面，然后 wx.navigateTo 就不能再正常打开新页面。请避免多层级的交互方式，或者使用 wx.redirectTo
  4. __样式表不支持级联选择器__：WXSS 支持类名选择器
  5. __本地资源无法通过 css 获取__：background-image 可以使用网络图片、base64、image 标签
  6. __如何修改窗口的背景色__：使用 page 标签选择器可以修改顶层节点的样式
  7. __为什么上传不成功__：为了提升体验流畅度，编译后的代码包大小需小于 1MB
  8. __HTTPS 请求不成功__：tls 仅支持 1.2 及以上版本
  9. __微信小程序是否支持 fetch、promise__：fetch 客户端不支持，promise 工具目前不支持
  10. __wx.request POST 方法的参数传输服务器接收不到的 bug__
    * content-type 默认为 `application/json`
    * 如果服务器没有用到 json 解释，可设置 `content-type: "application/x-www-form-urlencoded"`
  11. __wx.uploadFile 在手机上返回 http 码 403__：安卓的微信升级到6.5.2及其以上版本
  12. __小程序 SVG 支持吗__：image src 放远程 svg 可以，background-image 里也可以
  13. __ipad 不能使用小程序__：暂时不支持 ipad 打开小程序
  14. __小程序页内不能长按保存图片或分享图片__：目前不支持
  15. __微信小程序不支持 cookie__
    * 可使用 Reids 存储 session
    * 有些手机不支持 Object.assign 方法，使用报错时可以直接写一个合并对象的方法










