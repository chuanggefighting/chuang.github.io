---
title: 移动端的 flex 布局和事件
tags:
  - 布局和动画
categories: 移动端
top: false
keywords:
  - flex
date: 2019-05-11 23:16:17
description: flex 布局、事件类型
---

# 一、Flex 布局
> 如果想让一个盒子变成弹性盒子可以用 `display: flex`，弹性盒子中有主轴(横轴row) 和副轴(纵轴column)，可以根据需要设置盒子的容器(父元素)和项目(子元素)。

## 基础属性
  ```scss
  // 容器属性
  .parent{
    display: flex;

    // 元素排列方向(左右和上下)，切换主副轴
    flex-direction: row | row-reverse | column | column-reverse;

    // 是否换行：reverse 往上一行换行
    flex-wrap: nowrap | wrap | wrap-reverse;

    // 复合属性，无顺序关系
    flex-flow: flex-direction flex-wrap; 

    // 副轴上(即子项垂直) 的对齐方式
    align-items: stretch | flex-start | flex-end | center | baseline;

    // 主轴上(即子项水平) 的对齐方式
    justify-content: flex-start | flex-end | center | space-between | space-around;

    // 多行垂直(副轴) 对齐方式, 默认 stretch
    align-content: flex-start | flex-end | center | space-between | space-around;
  }

  // 项目属性
  .child{
    // 定义排列顺序, 数字越大越靠后(可为负值)
    order: number;

    // 定义放大比例 (单行有多余空间时)
    flex-grow: number;

    // 定义缩小比例 (单行空间不足时)    
    flex-shrink: number;

    // 设置主轴上项目宽度(建议代替宽度)   
    flex-basis: %/px/rem;

    // 前三者复合属性，默认0 1 auto; 
    flex: grow [shrink] [basis];

    // 定义项目自己的对齐方式，可覆盖 align-items
    align-self: stretch | flex-start | flex-end | center | baseline;
  }
  ```


## 布局实例

  ```scss
  // div.box、span.item
  .box-1 {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .box-2 {
    display: flex;
    justify-content: space-between;
  }

  .box-3 {
    display: flex;
    .item:nth-child(2) {
      align-self: center;
    }
    .item:nth-child(3) {
      align-self: flex-end;
    }
  }

  .box-4 {
    display: flex;
    flex-flow: row-reverse wrap;
    justify-content: space-between;
    align-content: space-between;
  }

  // div.box、div.column 分别两个 span.item
  .box-5{
    display: flex;
    flex-wrap: wrap;
    align-content: space-between;

    .column{
      flex-basis: 100%;
      display: flex;
      justify-content: space-between;
    }
  }

  .box-6 {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-content: space-between;
  }
  .box-7 {
    display: flex;
    flex-flow: column wrap;
    justify-content: space-between;
    align-content: space-between;
  }

  // div.column 分别包含 2、1、3 个子元素
  .box-8{
    display: flex;
    flex-wrap: wrap;
    align-content: space-between;

    .column{
      flex-basis: 100%;
      display: flex;
      justify-content: space-between;
    }
    .column:nth-child(2){
      justify-content: center;
    }
  }
  ```

  &lt;div align="center"> 
    ![flex 布局](/images/mobile/flex.png)
  &lt;/div&gt; 


## 网格布局
> 平均分布，即在容器里面平均分配空间

  ```scss
  // 几个子元素就平分几份
  .box{
    display: flex;
    .item{
      flex: 1;
    }
  }

  // 某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间
  .box{
    display: flex;
    .item{
      // flex: 1 1 0%;
      flex: 1;

      &.fixed{
        flex: 0 0 20%;
      }
    }
  }
  ```


## 圣杯布局

  ```scss
  body{
    display: flex;
    min-height: 100vh;
    flex-direction: column;

    header, footer {
      flex: 1;
    }

    .content{
      flex: 1;
      display: flex;
      
      .main{
        flex: 1;
      }
      .left, .right{
        // 两个边栏的宽度设为 12em
        flex: 0 0 12em;
      }
      .left{
        order: -1;
      }
    }
  }

  // 小屏幕时内容区三栏自动变为垂直叠加
  @media (max-width: 768px) {
    .content {
      flex-direction: column;
      flex: 1;

      .left, .main, .right {
        flex: auto;
      }
    }
  }
  ```

  <div align="center"> 
    ![圣杯布局](/images/mobile/grail.png)
  </div>



## 流式布局
> 每行的项目数固定，会自动分行

  ```scss
  .parent {
    width: 200px;
    height: 150px;
    background-color: black;
    display: flex;
    flex-flow: row wrap;
    align-content: flex-start;
  }

  .child {
    box-sizing: border-box;
    background-color: white;
    flex: 0 0 25%;
    height: 50px;
    border: 1px solid red;
  }
  ```


## 固定底栏
> 页面内容太少时底栏会抬高到页面的中间，移动端 fixed 定位会导致输入内容的虚拟键盘会导致定位元素错位等问题

  ```scss
  body{
    display: flex;
    height: 100vh;
    flex-direction: column;

    // header、footer、div.content
    .content{
      flex: 1;
      width: 100%;
      height: auto;
      overflow-y: scroll;
      -webkit-overflow-scrolling: touch;
    }
  }

  // 隐藏滚动条
  ::-webkit-scrollbar{  
      width: 0px; 
      height: 0px;
      background-color: #fff;  
  }

  // absolute 方式
  .box{
    position: relative;
    height: 100%;

    .content{
      position: absolute;
      left: 0;
      right: 0;
      top: 100px;
      bottom: 100px;
      height: auto;
      overflow-y: scroll;
      -webkit-overflow-scrolling: touch;
    }
    footer{
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
    }
  }
  ```


## 样式布局

  ```scss
  // 输入框的前方添加提示，后方添加按钮
  .input-item{
    display: flex;

    input{
      flex: 1;
    }
  }

  // 主栏的左侧或右侧添加一个图片栏 (类似头像)
  .item{
    display: flex;
    align-items: flex-start;

    img{
      margin-right: 1em;
    }
    p{
      flex: 1;
    }
  }
  ```



# 二、事件类型

## 分类

### click
  <div style="text-indent: 2em">`单击事件`。移动端中连续 click 的触发有 200~300ms 的延迟，延迟来自判断双击和长按，因为只有默认等待时间结束以确定没有后续动作发生时才会触发 click 事件。所以触摸事件反应更快，体验更好，也可以通过 fastclick 库解决延迟问题。</div>


### touch
  <div style="text-indent: 2em">`触摸类事件`，分为四种触发方式：touchstart (触屏开始)、touchmove (拖拽)、touchend (触屏完成)、touchcancel (触屏取消)。触屏时如果有更高级别的事件发生，比如电话接入或弹出信息等，则触发 ontouchcancel 事件。</div>
    

### gesture
  <div style="text-indent: 2em">`手势类事件`，可分为三种：gesturestart (两/多根手指按下时)、gesturechange (两/多根手指按下且移动时)、gestureend (倒数第二根手指移开时)。手势的专有属性有：rotation (手指变化引起的旋转角度)、scale (手指之间的距离)。</div>


### tap
  <div style="text-indent: 2em">`触碰类事件`，一般用于代替 click 事件，分为四种：tap (手指触碰屏幕)、longTap (手指长按屏幕)、singleTap (手指单击屏幕)、doubleTap(手指双击屏幕)。</div>
       

### swipe
  <div style="text-indent: 2em">`滑动事件`，分为五种：swipe (滑动手指)、swipeLeft (左滑)、swipeRight (右滑)、swipeUp (上滑)、swipeDown (下滑)。</div>


## 触发

### 触发顺序
> 顺序: ontouchstart -- ontouchmove -- ontouchend -- onclick

  ```js
  function addEvent(dom, type, showAll) {
    type = type.split(' ')

    type.forEach(function(item) {
        dom.addEventListener(item, function(v) {
            console.log(showAll ? v : v.type)
        })
    })
  }
  // 查看触发顺序
  addEvent(dom, 'tap click touchstart touchmove', false)
  ```


### 事件对象

  * 获取：box.addEventListener("touchstart", function(event){ },true)
  * 属性
    * touches：当前跟踪的触摸操作的 touch 对象的数组
    * targetTouches：特定于事件目标的 touch 对象数组 (事件冒泡指出目标对象)
    * changedTouches：表示自上次触摸以来发生了什么改变的 touch 对象的数组
  * 特点
    * touchend 事件时 touches、targetTouches 信息会被删除，changedTouches 保存最后一次的信息，最好用于计算手指信息
    * 通过 jquery 不能获取以上三个属性，而通过 zepto.js (精简版的 jquery，现在用的不多) 可以正常获取
   


## 问题方案

### click 延迟
> 原因：移动端浏览器会优先判断用户是否要触发双击缩放、双击滚动等默认行为，用户碰触页面后需要等待 300ms 左右来判断是不是双击动作而不是立即响应。

  * 禁用缩放：`meta name="viewport" content="width=device-width, user-scalable=no"`
  * 设置 device-width：`meta name="viewport" content="width=device-width"`
  * CSS touch-action：`touch-action: none`，表示在该元素上的操作不会触发用户代理的任何默认行为
  * FastClick：`import fastclick from 'fastclick'、fastclick.attach(document.body)`


### 点击穿透
> 原生 touch 事件、框架的自定义 tap 事件都存在该问题，因为 touch 系列事件发生大约 300ms 后才会触发 click 事件。

  * 出现问题
    * 点击蒙层上的关闭按钮，蒙层消失后发现触发了按钮下面元素的 click 事件，如果有 a 标签则会触发页面跳转。
    * 直接点击页内按钮跳转至新页面，然后发现新页面中对应位置元素的 click 事件被触发
  * 解决方案
    * 不要混用 touch、click：只用一种事件就不会存在点击穿透问题
    * fastclick：引入库之后把页面内所有 touch 事件都换为 click
    * 阻止默认
      * 阻止默认滚动：`div class="mask" @touchmove.prevent`
      * 阻止默认行为：`div ontouchend = "e.preventDefault()"`


### touch、mouse

  <div style="text-indent: 2em">移动端中只有触屏事件完成后再次触发时，才会触发上一个事件的 mouseout 事件。即系统会在手指提起的瞬间判断接收到事件的元素是否被改变，若没有改变则会按照 mousedown、mouseup、click 的顺序依次触发，反之不会触发。</div>
 

### 点击状态处理
> 移动端 hover 不可用

  * 激活状态：常用于 a、button 等元素的伪类 :active
    * js：`document.body.addEventListener('touchstart', fn)`
    * html：`body ontouchstart`
  * 点击高亮：`a { tap-highlight-color: transparent; }`
  * touch 事件：动态增删 class 或绑定动画


### touch、gesture
  * 当一个手指放在屏幕上时会触发 touchstart 事件，如果另一个手指又放到了屏幕上则会触发 gesturestart 事件，然后触发基于该手指的 touchstart 事件。
  * 如果两个手指在屏幕上滑动将会触发 gesturechange 事件，但只要有一个手指移开则会触发 gestureend 事件，然后又触发 touchend 事件






