---
title: H5 前端性能测试
tags:
  - 项目开发
categories: 项目开发
top: false
keywords:
  - 性能测试
date: 2019-02-18 18:41:48
description: 浏览器渲染、测试关注指标、相关工具、性能优化方案、常见应用
---

# 一、浏览器
> 浏览器是 Html 解析和页面最终展示的工具


## 分层结构
> 浏览器的抽象分层结构图中将浏览器分成了以下子系统

  <div style="text-indent: 2em;">浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源并将其显示在浏览器窗口中，资源的格式一般有 HTML、PDF、image 等。在浏览器组成部分中，渲染引擎是用户直接相关并呈现用户所需页面的部分。</div>


  * __用户界面__：用于和用户进行交互的功能组件，如地址栏、返回、前进按钮等
  * __浏览器引擎__：用于查询和操作渲染引擎的界面
  * __渲染引擎__：负责显示请求的内容，如果请求 HTML 则它解析 HTML 和 CSS 并显示
  * __网络__：负责处理网络相关的事务，如 HTTP 请求等
  * __UI 后端__：负责绘制提示框等浏览器组件，底层使用操作系统的用户接口
  * __Js 解释器__：负责解析和执行 JavaScript 代码
  * __数据存储__：负责持久存储 cookie 和缓存等应用数据

  <div align="center"> 
    ![浏览器结构](/images/web/browserCom.png)
  </div> 


## 渲染流程
> 即渲染引擎工作流。DOM 树构建完成时触发 DOMContentLoaded 事件，页面加载完成时触发 load 事件

  1. 构建 DOM 树：将 HTML 的各种标签解析为 dom 树的各个节点，两者一一对应
  2. 构建 CSSOM 树：将 css 样式信息解析为渲染树，它由一些包含有颜色和大小等属性并按照顺序显示在屏幕的矩形组成
  3. 解析并执行 js 脚本代码
  4. 加载图标、图片等外部静态文件
  5. 渲染树布局和绘制：渲染树确定各个 dom 节点在屏幕的位置并根据颜色等信息绘制出网页

  <div align="center">
    ![浏览器渲染](/images/web/browerRender.png) 
  </div> 


## 渲染机制
  * 资源下载
    * 图片下载不会产生阻塞
    * css 下载时会阻塞渲染，但带有 media 属性除外
      * css 是由单独的下载线程异步下载的
      * css 加载不会阻塞 DOM 树解析，但会阻塞 render 树渲染（需要 css 信息）
    * 遇到 script 标签时，DOM 构建停止直到 js 脚本下载并执行完毕，此时浏览器一般会下载其他资源但不会解析。如果 js 中有对 CSSOM 的操作，还会先确保 CSSOM 已经被下载并构建。
  * 重绘重排导致重新进行渲染树的生成
    * 重绘：简单外观的改变就会引起重绘，比如颜色变化等。重排一定重绘。
    * 重排(回流)：重新计算布局，通常由元素的结构、增删、位置、尺寸变化引起。比如 img 下载成功后替换填充页面 img 元素而引起尺寸变化。也会由 js 的属性值读取引起，比如读取 offset、scroll、cilent、getComputedStyle 等信息。
  * 优化方法
    * 直接改变 className，如果动态改变样式则使用 cssText
    * 让要操作的元素进行离线处理，处理完后一起更新
      * 使用 `display: none`，只引发两次回流和重绘
      * 使用 `DocumentFragment` 进行缓存操作，引发一次回流和重绘
      * 使用 `cloneNode(true/false)、replaceChild`，引发一次回流和重绘



# 二、测试关注指标

## Http 相关

  * __Http 请求数量__：可通过雪碧图、js CSS 合并等方式控制数量
  * __组件是否压缩__
    * 组件压缩是一种一种增加CPU压缩解压缩时间来减少网络传输消耗的办法
    * 通过去掉 Js，CSS 的空格和回车进行压缩，然后经过 GZIP 压缩，效果较好
    * 注意不需要对图片音乐等资源设置压缩，因为它们已经被压缩，再次压缩徒增 CPU 负担
  * __图片格式和大小__
    * 常见格式有 webp、jpg、png，一般 webp 的图片最小但存在兼容问题
    * 获取图片尺寸时候应该考虑图片具体的展示场景，比如移动设备使用多个尺寸而非通过代码缩放
    * 图片已经被压缩，但可以通过 TinyPNG、Smush.it 等工具进一步压缩并且质量不变
  * __CSS 放在顶部__
    * 如果网页是动态生成的，则 head 代码完成后就可以输出页面，这样浏览器就会更快地解析出来 head 中的内容并开始下载CSS文件资源
    * css 放在底部会引起重新绘制，用户侧感受到“闪屏”的不好体验
  * __JS 放在底部__
    * JS 下载时会引起两个问题：阻止网页内容的展示并阻止其他资源下载
    * 各种资源的下载是并行的，根据不同域名不同浏览器内核并行数量不同，所以下载js时并行下载机制失效
    * js 操作可能改变页面布局的操作，所以渲染引擎会等待 js 下载完成再开始渲染，用户侧页面加载时间会因为等待而变得更长
  * __是否设置缓存__：Cache-Control
    * no-cache：请求或响应消息不能缓存
    * no-store：防止重要的信息被无意的发布
  * 避免非 200 返回值：返回状态码非 200 的请求没有意义
  * __使用 CDN__
    * CDN 内容分发网络将源站内容发布到最接近用户的 "边缘" 节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率
    * 解决因分布、带宽、服务器能力带来的访问延迟高问题，提供一系列加速解决方案


## 时间相关
  * 白屏时间：用户首次看到网页有内容的时间，即第一次渲染流程完成时间
  * 首屏时间：用户看到第一屏，即整个网页顶部大小为当前窗口的区域，显示完整的时间
  * 首资源下载时间：从开始下载到第一个资源均下载完成的时间，不包括页面绘制时间
  * 总资源下载时间：从开始下载到所有资源均下载完成的时间，不包括页面绘制时间
  * 用户可操作时间：从页面开始加载到用户操作可响应的时间


## WebView 相关
> android、IOS 上测试 H5 性能，测试员还应该关注因加载 H5 而引起的 app 常规性能指标

  * 内存：加载页面前后内存变化，可间接反映H5中资源数量和大小，如dom数量，图片大小
  * FPS：帧率尤其在有视频和动画效果的H5中，测试员应该重点关注，防止严重的卡顿流出
  * CPU：当页面中资源样式复杂，强调视觉效果时，测试员可观察CPU占用率来反映H5绘制质量。如果CPU长期处于高占用率，可考虑降低高计算量的视觉效果等手段



# 三、常用工具

  * 抓包工具：`Fiddler、Charles 等`
  * 平台型工具：`Page Speed、PCAP Web Performance Analyzer、WebPagetest`

  <div align="center">
    ![前端性能测试工具](/images/web/performance.png) 
  </div> 


# 四、优化方案

## PC 端优化
  * css 尽量层次简单并放到 head
  * 简化 DOM 结构，最好不深于六层
  * 尽量缓存 DOM 查找，查找器尽量简洁
  * 涉及多域名的网站，可以开启域名预解析
  * 动画尽量使用在 绝对/固定 定位 的元素上
  * 隐藏在屏幕外 或 页面滚动时，尽量停止动画
  * DOM 操作尽量通过缓存减少次数，避免过度触发回流
  * js 脚本放在页面 body 底部，减少对其他过程的阻塞
  * Js 修改元素样式操作尽量减少，使用类名修改或动画操作样式
  * 减少首次下载的文件数量大小，使用图片懒加载、js 按需加载等方式



## 移动端优化
  * 不滥用 Float：渲染页面时计算量比较大
  * 不滥用 Web 字体：需要下载、解析、重绘当前页面
  * 不声明过多的 Font-size：会影响 CSS 树的效率
  * 减少重绘和回流
    * 减少 drawImage
    * 避免不必要的 DOM 操作
    * 避免使用 document.write
    * 尽量改变 class 而不是 Style
  * 动画优化
    * 尽量使用 CSS3 动画：5 个以内的元素时
    * 适当使用 Canvas 动画：5 个以上元素时
    * 合理使用 requestAnimationFrame 动画代替 setTimeout
  * GPU 加速
    * 注意过渡使用会引发手机过耗电增加
    * 触发 GPU 渲染：transitions、3D transforms、Opacity、Canvas、WebGL、Video
    

  <div align="center"> 
    ![移动端优化](/images/mobile/optimization.png) 
  </div>



# 五、常见应用

## 函数的节流和防抖
> 在网页实际运行的某些场景下，有些事件是会被不间断的被触发的，而不是我们认为的滚动一次触发一次。这种情况下，由于过于频繁地 DOM 操作和资源加载，严重影响了网页性能，甚至会造成浏览器崩溃。两者都是某个行为持续地触发，区别在于只需要判断是要优化到减少它的执行次数还是只执行一次。

## 实现方式

  * __节流__：一个水龙头在滴水，可能一次性会滴很多滴，但是我们只希望它每隔 500ms 滴一滴水并保持这个频率。即我们希望函数以一个可以接受的频率重复调用，通过节流函数减少回调函数的执行次数。
  * __防抖__：将一个弹簧按下，继续加压，继续按下，但只会在最后放手的一瞬反弹。即我们希望回调函数即使在设定时间内反复调用，也只会在间隔时间超过设定时间后调用一次，通过防抖函数让回调函数实现延时执行。


  ```js
  // 节流：首次不执行
  function throttle(callback, duration=200){
    let timer = null;
    return function(){
      if(timer) return;
      timer = setTimeout(()=>{
        callback.apply(this,arguments);
        timer = null;
      }, duration);
    }
  }
  let handleScroll = throttle(handleScroll)
  window.addEventListener("touchmove", handleScroll);

  // 防抖：首次不执行
  function debounce(callback, delay=200){
    let timer = null;
    return function(){
      if(timer) clearTimeout(timer);
      timer = setTimeout(()=>{
        callback.apply(this,arguments);
        timer = null;
      }, delay);
    }
  }
  let handleSeach = debounce(seachAjax, 500)
  input.addEventListener("keyup", e=>{ handleSeach(e.target.value)})
  ```


## 应用场景

  * 函数节流
    * 拖拽元素时 `drag` 事件
    * 监听滚动时 `scroll` 事件
    * 鼠标移动时 `mousemove` 事件
    * 手指滑动时 `touchmove` 事件
  * 函数防抖
    * 搜索框输入内容时 `keyup` 事件
    * 浏览器窗口调整大小时 `resize` 事件
    


 








