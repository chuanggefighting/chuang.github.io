---
title: 面试题之基础篇
tags:
  - 面试
categories: 面试
top: false
keywords:
  - 面试
date: 2020-03-22 17:31:06
description: HTML、CSS、JS、Vue、React、小程序、编程实现
---

# 一、HTML

## 语义化的理解
> 使用合理的标签来创建页面结构，让页面的内容结构化，页面结构更清晰。好处是便于浏览器和搜索引擎解析，提高代码的可读性和重用性。


## link、@import 导入区别
  * __从属关系__：@import 只能用于加载 CSS，link 是 XHTML 标签，它还可以定义 RSS、rel 连接属性、引入网站图标等。
  * __加载顺序__：加载页面时，link 引入的 CSS 被同时加载，@import 引入的 CSS 会等到页面被全部加载完成后再加载。
  * __兼容性__：link 无兼容性问题，@import 只有 IE5+ 才能被识别。


## 常见的浏览器内核
  * IE：__Trident__
  * Firefox：__Gecko__
  * Safari：__Webkit__
  * Chrome：__Blink__
  * Opera：__Blink__


## 简述浏览器的渲染原理
> 为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。

  1. 解析 HTML 标记并构建 __DOM 树__。
  2. 解析 CSS 标记并构建 __CSSOM 树__。
  3. 根据 DOM、CSSOM 构建__渲染树__，节点是包含颜色等属性的渲染对象。
  4. __布局__：根据渲染树进行布局，计算各个节点在页面的位置、大小等信息。
  5. __绘制__：调用渲染对象的 paint 方法，将它们的内容显示在屏幕并绘制基础组件。
    

## HTML5 form 的自动完成功能
  * __autocomplete__ 属性规定表单是否应该启用自动完成功能，它自动完成允许浏览器预测对输入字段。在用户在开始键入时，浏览器基于之前键入过的值显示出历史选项。
  * 关闭自动完成功能的方法：IE Internet 选项菜单的内容--自动完成里面设置、设置 `<form autocomplete="off"></form>` 来关闭整个表单的自动提示功能、设置 `<input autocomplete="off" />` 来关闭输入框的自动完成功能。


## 浏览器标签页之间的通信
> 实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者来让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

  1. __Websocket__：通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。
  2. __localStorage__：localStorage 在另一个浏览上下文里被添加、修改或删除时会触发 storage 事件，可以通过监听该事件来实现页面之间的通信。
  3. __SharedWorker__：服务器注册一个 onmessage 监听信息的事件，客户端(即使用 sharedWorker 的标签页)发送 message 时就会触发。


## 前端性能优化

  1. __页面内容方面__
    1. 通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
    2. 通过 DNS 缓存等机制来减少 DNS 的查询次数。
    3. 通过设置缓存策略，对常用不变的资源进行缓存。
    4. 通过延迟加载的方式，来减少页面首屏加载时需要请求的资源，延迟加载的资源当用户需要访问时，再去请求加载。
    5. 通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。
  2. __服务器方面__
    1. 使用 CDN 服务，来提高用户对于资源请求时的响应速度。
    2. 服务器端自用 Gzip、Deflate 等方式对传输资源进行压缩，减少传输文件的体积。
    3. 尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie。


## 移动端适配方案

  * __viewport 缩放__：针对不同屏幕分辨率的手机设置等比例缩放。简单方便，但是 PC 端可能会界面变形、像素失真。
  * __响应式布局__：通过媒体查询根据不同的屏幕分辨率来进行适配。缺点是无法覆盖全部分辨率、代码量大且维护性难、安卓机型问题较多，一般只适合简单的资讯类页面。
  * __弹性布局__：使容器子元素的宽高能够最合理的方式填充空间。主要有百分比布局、vw + vh 布局、rem 布局。
  * __vue 方案__：通过 vw 实现移动端适配，安装插件 postcss-px-to-viewport 并进行相关配置即可。


## 什么是 webp

  * __WebP__：谷歌开发的一种新图片格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。最大优点是在相同质量的文件下，它拥有更小的文件体积，这样可以减少请求时间而提升u用户体验，因此它非常适合于网络图片的传输。
  * __浏览器判断是否支持 webp 格式图片__：通过创建 Image 对象，将其 src 属性设置为 webp 格式的图片，然后在 onload 事件中获取图片的宽高。能够获取说明支持，不能获取或触发了 onerror 函数则说明不支持。


# 二、CSS

## BFC 及其应用
  * __简单介绍__：Block Format Context 块级格式化上下文，是页面盒模型的一种 CSS 渲染模式，相当于一个独立容器，里面的元素和外部的元素相互不影响。
  * __创建方式__：html 根元素、float、position: absolute/fixed、overflow: !visible、display: inline-block/table/flex。
  * __主要作用__：清除浮动、不同 BFC 时可以阻止 margin 重叠。


## CSS 盒模型

  * __组成__：margin、border、padding、content。
  * __标准盒模型__：box-sizing: content-box。
  * __IE 盒模型__：box-sizing: border-box。


## 重绘和回流，以及优化

  * __重绘重排__
    * 重绘：简单外观的改变而不会影响布局，比如 outline、visibility、color。
    * 回流：布局或几何属性改变而重新计算布局，大部分都会会导致页面的重新渲染。
    * 关系：重绘不一定会引发回流，回流必定会发生重绘，它们都会重新生成渲染树。
  * __优化方案__
    * __CSS__
      * CSS 硬件加速。
      * 避免使用 table 布局。
      * 使用 transform 代替 top。
      * 尽可能在 DOM 树的最末端改变 class。
      * 避免使用 CSS 表达式，可能会引发回流。
      * 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
      * 使用 visibility 替换 display: none，前者引起重绘，后者引发回流。
      * 将动画效果应用到 position: absolute/fixed 的元素，避免影响其他布局。
    * __Javascript__
      * 避免频繁操作样式，修改 class 最好。
      * 避免频繁操作 DOM，合并多次修改为一次。
      * 避免频繁读取会引发回流/重绘的属性，将结果缓存。
      * 对具有复杂动画的元素使用绝对定位，使它脱离文档流。


## opacity、visibility、display
  * __opacity: 0__：占据空间，可以点击，引起重绘，子元素不影响。
  * __display: none__：不占空间，不能点击，会引起回流，子元素不影响。
  * __visibility: hidden__：占据空间，不能点击，引起重绘，子元素可设置 visible 进行显示。


## Rem 及其原理
  * __Rem__：CSS3 新增的相对长度单位，指相对于根元素 html 的 font-size 大小，移动端新型浏览器支持较好。px 是相对固定单位，无法随着浏览器进行缩放。
  * __转换原理__：默认根元素的 font-size: 16px，如果想要设置为 12px 则就是 12px/16px = 0.75rem。通过 postcss-px-to-viewport 插件可以实现对 px 到 vw 的自动转换。


## 移动端视口配置
  * __initial-scale__: 初始的缩放比例。
  * __minimum-scale__: 允许用户缩放到的最小比例。
  * __maximum-scale__: 允许用户缩放到的最大比例。
  * __user-scalable__: 用户是否可以手动缩放。

## 伪类和伪元素
  * __伪类__：用于为处于某种状态的已有元素添加样式，该状态是随着用户行为变化的。比如说 :hover。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。
  * __伪元素__：用于创建一些原本不在文档树中的元素，并为其添加样式。比如 ::before，虽然用户可以看到这些内容，但是其实它不在文档树中。
  * __区别__：伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。css 规范规定使用双冒号 :: 表示伪元素，一个冒号 : 表示伪类。


## 可继承的 css 属性
  * __字体系列属性__：font-family、font-size、font-weight、font-style。
  * __文本系列属性__：text-indent、text-align、line-hight、word-spacing、letter-spacing、color。
  * __其他__：cursor、visibility。


## min/max-width、min/max-height 覆盖规则
  * max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。
  * min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突时。


# 三、JS

## 类型判断

  * __typeof__：判断所有的基本数据类型，返回一个字符串。
  * __instanceOf__：判断一个对象是否某构造函数的实例，返回值为 true/false。
  * __constructor__：返回一个对象具体的构造函数，比如 Array、Function、Map。
  * __Object.prototype.toString.call()__：对象的一个原型扩展函数，可以判断所有数据类型。


  ```js
  // 6 种原始数据类型
  console.log(typeof 'a');   // "string"
  console.log(typeof 1);     // "number"
  console.log(typeof true);  // "boolean"
  console.log(typeof Symbol());  // "symbol"
  console.log(typeof undefined); // "undefined"
  console.log(typeof null);  // "object"
  // 对象类型
  console.log(typeof {});    // "object"
  console.log(typeof []);    // "object"
  console.log(typeof new Map());  // "object"
  console.log(typeof new Set());  // "object"
  // function 类型
  console.log(typeof function () {}); // "function"


  let fun = new Function();
  function Apple() {}
  let apple = new Apple();

  console.log(fun instanceof Function);    // true
  console.log(apple instanceof Apple);     // true
  console.log(apple instanceof Function);  // false

  console.log([] instanceof Array);   // true
  console.log([] instanceof Object);  // true
  console.log({} instanceof Object);  // true

  console.log(new Map() instanceof Map);     // true
  console.log(new Map() instanceof Object);  // true

  console.log(fun.constructor === Function);    // true
  console.log(apple.constructor === Apple);     // true
  console.log(apple.constructor === Function);  // false

  console.log([].constructor === Array);   // true
  console.log([].constructor === Object);  // false

  console.log(new Map().constructor === Map);    // true
  console.log(new Map().constructor === Object); // false

  console.log({}.constructor === Object);  // true

  console.log(Object.prototype.toString.call(fun));        // "[object Function]"
  console.log(Object.prototype.toString.call(apple));      // "[object Object]"
  console.log(Object.prototype.toString.call([]));         // "[object Array]"
  console.log(Object.prototype.toString.call(new Map()));  // "[object Map]"
  console.log(Object.prototype.toString.call({}));         // "[object Object]"
  ```


## 隐式类型转换

  * __运算符转换__：-、*、/、% 会转换为数字后计算，+ 则进行数字相加或字符串拼接。
  * __双等号转换__：两边会转换为同一类型再进行比较，有一个 NaN 则返回 false。
  * __点号操作符__：数字、字符串等通过点调用方法时，隐式地将类型转换成对象。
  * __if() 语句__：括号里的表达式部分会被隐式转换为布尔类型进行判断。


## 小数精度丢失
> 有些小数在计算机使用二进制方式表示时无法准确表示，类似于十进制的 1/3 无理数、无限循环。但是计算机存储小数的类型不管是 float/double 都是有位数限制的，所以它们存储的只是一个近似值，这就导致了精度丢失。解决办法如下：

  * 整数的出现问题几率较低，毕竟很少有业务需要用到超大整数，只要运算结果不超过 __Math.pow(2, 53)__ 就不会丢失精度。
  * 小数的出现问题几率很大，尤其是一些电商网站的金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）。


  ```js
  // true, false
  var two   = 0.2
  var one   = 0.1
  var eight = 0.8
  var six   = 0.6
  console.log(two - one == one, eight - six == two)

  // floatObj：包含加减乘除四个方法，确保浮点数运算不丢失精度
  var floatObj = function() {

    // 判断obj是否为一个整数
    function isInteger(obj) {
        return Math.floor(obj) === obj
    }
    
    /*
      * 将一个浮点数转成整数，返回整数和倍数。如 3.14 >> 314，倍数是 100
      * @param floatNum {number} 小数
      * @return {object}
      *   {times:100, num: 314}
      */
    function toInteger(floatNum) {
        var ret = {times: 1, num: 0}
        var isNegative = floatNum < 0
        if (isInteger(floatNum)) {
            ret.num = floatNum
            return ret
        }
        var strfi  = floatNum + ''
        var dotPos = strfi.indexOf('.')
        var len    = strfi.substr(dotPos+1).length
        var times  = Math.pow(10, len)
        var intNum = parseInt(Math.abs(floatNum) * times + 0.5, 10)
        ret.times  = times
        if (isNegative) {
            intNum = -intNum
        }
        ret.num = intNum
        return ret
    }
    
    /*
      * 核心方法，实现加减乘除运算，确保不丢失精度
      * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）
      *
      * @param a {number} 运算数1
      * @param b {number} 运算数2
      * @param digits {number} 精度，保留的小数点数，比如 2, 即保留为两位小数
      * @param op {string} 运算类型，有加减乘除（add/subtract/multiply/divide）
      *
      */
    function operation(a, b, digits, op) {
      var o1 = toInteger(a)
      var o2 = toInteger(b)
      var n1 = o1.num
      var n2 = o2.num
      var t1 = o1.times
      var t2 = o2.times
      var max = t1 > t2 ? t1 : t2
      var result = null
      switch (op) {
          case 'add':
              if (t1 === t2) {  // 两个小数位数相同
                  result = n1 + n2
              } else if (t1 > t2) {  // o1 小数位 大于 o2
                  result = n1 + n2 * (t1 / t2)
              } else {          // o1 小数位 小于 o2
                  result = n1 * (t2 / t1) + n2
              }
              return result / max
          case 'subtract':
              if (t1 === t2) {
                  result = n1 - n2
              } else if (t1 > t2) {
                  result = n1 - n2 * (t1 / t2)
              } else {
                  result = n1 * (t2 / t1) - n2
              }
              return result / max
          case 'multiply':
              result = (n1 * n2) / (t1 * t2)
              return result
          case 'divide':
              result = (n1 / n2) * (t2 / t1)
              return result
      }
    }
    
    // 加减乘除的四个接口
    function add(a, b, digits) {
      return operation(a, b, digits, 'add')
    }
    function subtract(a, b, digits) {
      return operation(a, b, digits, 'subtract')
    }
    function multiply(a, b, digits) {
      return operation(a, b, digits, 'multiply')
    }
    function divide(a, b, digits) {
      return operation(a, b, digits, 'divide')
    }
    
    // exports
    return {
      add: add,
      subtract: subtract,
      multiply: multiply,
      divide: divide
    }
  }();
  ```


## 原型链
> 每个对象都会在其内部初始化一个属性 prototype (原型)，当我们访问一个对象的属性时，如果这个对象内部没有这个属性则去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype，直到 null 结束，如果没有则返回 undefined，这就是原型链的运行原理，即查找顺序：`实例对象 obj --> 原型对象 fn.prototype --> Object.prototype -->  null`。

  1. 相互关系：`obj.constructor.prototype = obj.__proto__`
  2. 函数对象：通过 new Function() 创建都是函数对象，其他的都是普通对象。每个对象都有 `__proto__` 属性指向原型对象，但只有函数对象才有 `prototype` 属性
  3. 原型对象：一个普通对象。所有的原型对象都会自动获得一个指向其构造函数的指针 `constructor`，构造函数通过 `prototype` 属性指向它的原型对象，可以说 原型对象 `Person.prototype` 就是构造函数 `Person` 的一个实例
  3. 原型链继承：利用原型让一个引用类型继承另一个引用类型的属性和方法，即让原型对象等于另一个类型的实例，这样就可以通过 `__proto__` 属性构成实例与原型的链条, 从而实现继承。


## 面向对象思想
> 将具体问题分解并抽象为一个个具体的对象，并且将对象及其公共的属性和方法封装成一个类，整个程序由对象之间的分工和合作完成。主要特点有封装 (只能通过对象来访问方法)、继承 (从已有对象上继承出新的对象)、多态 (多对象的不同形态)，极大提高了大型程序的重用性和可维护性。核心在于类的实现：js 基于 function 来模拟类，通过 prototype 属性来实现类方法的共享，ES6 class 是用来定义类的一个语法糖，通过 extends 来继承父类。


## this 指向
> this 代表当前方法执行时自动生成的一个上下文对象。

  * 元素绑定事件：指向当前操作的元素。
  * 普通函数：指向点前面的对象，没有点则指向 window (js 严格模式下是 undefined)。
  * 构造函数：指向生成的对象实例，而且 this 指向无法改变。new 的过程是在内部新建一个空对象，添加构造函数的属性和方法并返回该对象。
  * 箭头函数：指向定义时所在的对象，因为它没有自身的 this，使用的是外层 this。


  ```js
  // 普通函数
  let fn = function () {
    console.log(this);
  }
  let obj = {
    name: '哈哈哈',
    fn: fn
  }
  fn();       // window
  obj.fn();   // obj

  // 构造函数
  function Person(name, age){ 
    this.name = name;
    this.age = age;
    console.log(this)  // p：{name: "Tom", age: 20}
  }
  var p = new Person('Tony', 20);

  // 箭头函数
  const obj = {
    a: ()=>{
      console.log(this)  // Window
    },
    b: function(){
      console.log(this)  // obj
    }
  }
  obj.a()
  obj.b()
  ```


## apply、call、bind
> 相同点：用来改变 this 指向、第一个参数是 this 要指向的对象 (默认 window)。区别如下：

  * 参数：call 单个传递、apply 数组、bind 值或数组。
  * 功能：call、apply 函数直接执行，bind 函数会返回一个绑定了新 this 的函数但不会执行。


  ```js
  var a = { name: 'linxin' }
  function f(x, y){
    console.log(this)  // a
  }

  f.apply(a, [1, 2])
  f.call(a, 1, 2)
  f.bind(a, 1, 2)()
  ```


## 遍历方法

  * 数组：forEach、map、for 循环、for of。
  * 对象：for in、Object.keys()、Object.values()、Objcet.getOwnPropertyNames()、Reflect.ownKeys()。


## 防抖和节流
> 在网页实际运行的某些场景下，有些事件会被连续触发而频繁进行 DOM 操作和资源加载，严重影响了网页性能，甚至会造成浏览器崩溃。两者都是针对连续触发的某个行为，区别在于是要优化到减少它的执行次数还是只执行一次。

  * __防抖__
    * 基础理解：将一个弹簧连续按下，但只会在最后放手的一瞬反弹。即我们希望高频事件只执行一次，实现回调函数的延时执行。
    * 应用场景：搜索框输入内容时 `keyup` 事件、浏览器窗口调整时 `resize` 事件。
  * __节流__
    * 基础理解：一个水龙头在滴水时保持 一滴水/s 的频率。即我们希望高频事件以一定频率重复调用，减少函数的执行次数。
    * 应用场景：拖拽元素时 `drag` 事件、监听滚动时 `scroll` 事件、鼠标移动时 `mousemove` 事件、手指滑动时 `touchmove` 事件。


  ```js
  // 防抖：n 秒内高频事件再次被触发则重新执行。
  function debounce(callback, delay=200){
    let timer = null;
    return function(){
      if(timer) clearTimeout(timer);
      timer = setTimeout(()=>{
        callback.apply(this, arguments);
        timer = null;
      }, delay);
    }
  }
  let handleSeach = debounce(seachAjax, 500)
  input.addEventListener("keyup", e=>{ handleSeach(e.target.value)})

  // 节流：n 秒内只会执行一次。
  function throttle(callback, duration=200){
    let timer = null;
    return function(){
      if(timer) return;
      timer = setTimeout(()=>{
        callback.apply(this, arguments);
        timer = null;
      }, duration);
    }
  }
  let handleScroll = throttle(handleScroll)
  window.addEventListener("touchmove", handleScroll);
  ```

## 自执行函数
> 声明并立刻调用的匿名函数，用来创建一个独立的作用域，一般用于框架、插件等场景。好处在于

  * 防止变量扩散到全局，造成各种 js 库冲突。
  * 隔离作用域避免污染，避免闭包造成引用变量无法释放。
  * 利用立即执行特性，返回需要的业务函数或对象，避免每次都通过条件判断来处理。


## 尾调用优化
> 指函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以在一个函数里调用另一个函数时，会保留当前的执行上下文并新建另外一个加入栈中。使用尾调用时则不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。


## 闭包和内存泄露
> 指能够读取其他函数内部变量的函数，用来实现私有的方法和变量。

  * 闭包特性：函数嵌套函数、函数内部可以引用外部的参数和变量、参数和变量不会被 F 垃圾回收机制回收。
  * 优缺点：优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
  * 内存泄露
    * 动态存储和分配函数的内存空间，但是在使用完毕后未释放，导致该内存单元一直被占据到程序结束，即对象不再使用时仍然存在。
    * 出现场景：setTimeout 首个参数使用字符串而非函数、闭包、意外的全局变量、未被清空的定时器、未被销毁的事件监听、DOM 引用等。
    * 解决方案：不要动态绑定事件、不要给动态元素绑定事件而通过事件冒泡在父容器监听事件、动态时则必须提供 destroy 方法、尽量单例化，少创建 dom，少绑事件。


## 堆栈溢出

  * __递归__：指一个函数不断的调用自身。它将原来的问题转化为更小的同一问题来求解，只需要少量代码就可以完成多次重复计算，大大地减少了程序的代码量。
  * __堆栈溢出__：函数调用时会通过栈分配一定空间的数据块来保存参数、返回值等临时信息，等函数执行完成时才出栈。但是数据块写入数据过多时，会导致栈空间不足而产生数据覆盖问题，这就是递归中经常发生的栈溢出错误（stack overflow）。
  * __栈溢出的解决方案__：使用闭包 (每次调用时返回一个匿名函数，相关的参数和局部变量将会被释放而不会额外增加堆栈大小)、优化调用、尾递归 (添加一个参数，记录递归次数)。


  ```js
  // 递归示例
  function Fibonacci (n) {
    if ( n <= 2 ) {return 1};

    return Fibonacci(n - 1) + Fibonacci(n - 2);
  }

  // 栈溢出
  function factorial(n) {
    if (n === 1) return 1;
    return n * factorial(n - 1);
  }

  // 尾递归
  let count = 0;
  function factorial(n) {
      count ++;
      if (count > 1000) {
          console.error('超过了最大调用次数');
          return;
      }
      if (n === 1) return 1;
      return n * factorial(n - 1);
  }
  ```


## call、apply 对比

  * Function.prototype.apply/call 作用一样，区别在于传入参数的不同。第一个参数是 this 要指向的对象，null、undefined 时默认指向 window，后面的参数分别是参数数组、参数列表。
  * call 比 apply 的性能要好，call 传入参数的格式正式内部所需要的格式。


## ES5/ES6 继承的区别

  * class 声明内部会启用严格模式。
  * class 声明会提升，但不会初始化赋值。
  * class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
  * class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有 constructor，不能使用 new 调用。
  * 必须使用 new 来调用 class。
  * class 内部无法重写类名。


## ES6 代码转成 ES5 代码的实现思路
> Babel 的实现方式：

  1. 将代码字符串解析成抽象语法树，即所谓的 AST。
  2. 对 AST 进行处理，在这个阶段可以对 ES6 AST 进行相应转换，即转换成 ES5 AST。
  3. 根据处理后的 AST 再生成代码字符串。


## 箭头函数与普通函数的区别
> 箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数的差异如下：

  * 函数体内的 this 对象，是定义时所在的对象，而不是使用时所在的对象。
  * 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
  * 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
  * 不可以使用 new 命令，因为：
    * 没有自己的 this，无法调用 call、apply。
    * 没有 prototype 属性，而 new 命令在执行时需要将钩子函数的 prototype 赋值给新的对象的 `__proto__`。


## setTimeout、Promise、Async/Await 区别

  * __setTimeout__：回调函数放到宏任务队列里，等到执行栈清空以后执行。
  * __Promise__：本身是同步的立即执行函数，当在 executor 中执行 resolve/reject 时是异步操作，会先执行 then/catch 等，当主栈完成时，才会去调用 resolve/reject 中的方法。
  * __async__：函数返回一个 Promise 对象，当函数执行时一旦遇到 await 就会先返回，等到异步操作完成后再执行函数体内后面的语句。可理解为让出了线程而跳出了 async 函数体。


## Async/Await 同步方式实现异步
> 本质是一个自执行的 generate 函数，利用 generate 的特性把异步代码写成同步形式。

  ```js
  var fetch = require("node-fetch");

  function *gen() { // * 可以看作 async
    var url = "https://api.github.com/users/github";
    var result = yield fetch(url); // yield 可以看作 await
    console.log(result.bio);
  }

  var g = gen();
  var result = g.next();
  result.value.then(data => data.json()).then(data  => g.next(data));
  ```

## 简述 Generator 函数
> 异步编程(即多任务)的解决方案有一种叫做__协程__：多个线程互相协作来完成异步任务，即线程 A 执行到某处之后暂停并等到线程 B 执行完毕后继续执行。Generator 函数的最大特点就是可以交出函数的执行权（即暂停执行）。

  ```js
  function* gen(x) {
    var y = yield x + 2;
    return y;
  }
  // next(value)：向外输出数据，参数值将作为上一个 yield 语句的返回值。
  var g = gen(1);
  g.next()     // 返回 yield 表达式 x + 2 的值，{ value: 3, done: false }
  g.next(2)    // 参数值为异步任务结果并被 y 接收， { value: 2, done: false }
  ```


## JS 异步解决方案的发展历程和优缺点

  * __回调函数__
    * 优点：解决了同步的问题（整体任务执行时长）。
    * 缺点：回调地狱，不能用 try catch 捕获错误，不能 return。
  * __Promise__
    * 优点：解决了回调地狱的问题。
    * 缺点：无法取消 Promise，错误需要通过回调函数来捕获。
  * __Generator__
    * 特点：可以控制函数的执行。
  * __Async/Await__
    * 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题。
    * 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。


## 处理循环的异步操作
```js
// 法一
async function getMoney(){
    var money = [100, 200, 300]
    for( let i=0; i<money.length; i++){
        //compute.exec()：一个业务逻辑的异步方法
        await compute.exec().then(()=>{
            console.log(money[i])
        })
    }
}

// 法二：递归方式实现自我循环，开始调用 getMoney(0)
function getMoney(i) {
　　var money = [100, 200, 300]
　　compute.exec().then(() => {
　　　 if ( i < money.length ) { 　
          console.log(money[i]);
　　　 　　 i++;
          getMoney(i);
　　   }
  　})
}

```




##  MVC、MVP、MVVM 模式
> __View__ 视图模板、__Model__ 数据模型、__Controller/Presenter__ 处理业务逻辑的控件、__ViewModel__ 监听变化并处理业务逻辑的控件。

  * __MVC__
    * View、Model 直接绑定，因此很多 view 可以修改多个 model 而变得混乱，交互增加导致代码不好维护。
    * 具体流程：View 捕获用户操作 -> Controller 处理数据并调用对应的 Model 接口 -> Model 更新后通过观察者模式通知 View -> View 收到更新消息后向 Model 请求最新数据并更新界面。
  * __MVP__
    * View 绑定事件的事件驱动机制，并通过 Presenter 实现分离和通信。它定义了 View、Presenter 之间的接口，需要维护 Presenter 的内部实现。
    * 具体流程：View 用户操作 -> Presenter 调用 Model 接口  -> Model 更新后通知 Presenter -> Presenter 调用 View 提供的接口更新界面。
  * __MVVM__
    * View、Model 分别通过 ViewModel 的 DOM-Listeners、Data-Bindings 绑定事件和管理数据而实现了双向绑定。它实现了数据与视图的分离，通过数据来驱动视图，开发者只需要关心数据变化 (DOM 操作被封装了)。
    * 具体流程：View 用户操作 –> ViewModel 监听到变化通知 Model –> Model 更新 –> ViewModel 通知 View 更新。


## Set、Map、WeakSet、WeakMap 区别

  * __Set__
    * 成员不能重复。
    * 只有键值，没有键名，有点类似数组。
    * 可以遍历，方法有 add、delete、has。
  * __WeakSet__
    * 成员都是对象（引用）。
    * 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露。
    * 不能遍历，方法有 add、delete、has。
  * __Map__
    * 本质上是键值对的集合，类似集合。
    * 可以遍历，方法很多，可以跟各种数据格式转换。
  * __WeakMap__
    * 只接收对象为键名（null 除外），不接受其他类型的值作为键名。
    * 键名指向的对象，不计入垃圾回收机制。
    * 不能遍历，方法同 get、set、has、delete。


## 浏览器缓存机制
  * 浏览器缓存就是把一个已经请求过的资源拷贝一份存储起来，当下次需要该资源时，浏览器会根据缓存机制决定直接使用缓存资源还是再次向服务器发送请求。
  * from memory cache ; from disk cache
  * 作用: 减少网络传输的损耗以及降低服务器压力。
  * 优先级: 强制缓存 > 协商缓存; cache-control > Expires > Etag > Last-modified

## 简述浏览器缓存读取规则
> 浏览器缓存可以优化性能，比如直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，则使用缓存从而减少响应数据。

### 缓存位置
  * __Service Worker__：运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用时传输协议必须为 HTTPS。它的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由缓存哪些文件、如何匹配缓存、如何读取缓存，而缓存是可持续性的。Service Worker 也是 PWA 的核心技术。
  * __Memory Cache__：内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据很高效，但是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
  * __Disk Cache__：存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，它的覆盖面最大。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。
  * __Push Cache__：推送缓存，是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被时候用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂（大约 5 分钟）。

### 缓存过程分析
> 浏览器与服务器通信的方式为应答模式：浏览器发起 HTTP 请求、服务器响应该请求。浏览器第一次向服务器发起该请求并拿到请求结果后，将请求结果和缓存存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源返回的响应头来确定的。

  * 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。
  * 浏览器每次拿到返回的请求结果都会将该结果和缓存表示存入浏览器缓存中。


## JS 异步机制

## 异步任务
  * __浏览器__
    * __宏任务__：script 中的代码、setTimeout、setInterval、I/O、UI render。
    * __微任务__：promise（async/await）、Object.observe、MutationObserver。
  * __Node__
    * __宏任务__：setTimeout、setInterval、setImmediate、script（整体代码）、I/O 操作等。
    * __微任务__：process.nextTick（与普通微任务有区别，在微任务队列执行之前执行）、new Promise().then(回调) 等。
  * __区别__
    * node 环境下的 setTimeout 定时器会依次一起执行，浏览器是一个一个分开的。
    * 浏览器环境下微任务的执行是每个宏任务执行之后，而 node 中微任务会在各个阶段执行，一个阶段结束立刻执行 microTask。


  ```js
  // 浏览器环境
  while(true){
      宏任务队列.shift()
      微任务队列全部任务()
  }

  // Node 环境
  while(true){
      loop.forEach((阶段)=>{
          阶段全部任务()
          nextTick 全部任务()
          microTask 全部任务()
      })
  }
  ```


### 执行机制
> 先主线程后异步任务队列、先微任务再宏任务。

  1. JS 引擎将所有操作分为 同步任务、异步任务。
  2. 同步任务进入主线程，然后直接按顺序执行。
  3. 异步任务进入工作线程，当满足触发条件后推入任务队列。
  4. 事件循环机制：主线程执行完所有同步任务之后空闲时，重复去任务队列中查看是否有可执行的异步任务，有则推入主进程的执行栈。
    1. 执行一个宏任务（栈中没有就从事件队列中获取）。
    2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中。
    3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）。
    4. 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染。
    5. 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从任务队列中获取）。


## header 中的 token 为何不会被劫持 
  1. token 不是防止 XSS 的，而是为了防止 CSRF。
  2. CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token。


## CSRF 攻击、CSP 内容安全策略

### CSRF 攻击
  * __实现__：跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态（cookie），绕过后台的用户验证，冒充用户向服务器执行一些操作。
  * __本质__：利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。
  * __防护方法__：同源检测和服务器检测请求来源、使用 token 进行验证、设置 cookie 时设置 Samesite 而限制 cookie 不能作为被第三方使用。

### CSP 内容安全策略
  * __实现__：本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。它也是解决 XSS 攻击的一个强力手段。
  * __开启__：一种是设置 `HTTP 头部 Content-Security-Policy`，一种是设置 `meta 标签 <meta http-equiv="Content-Security-Policy">`。


## 简述 PWA
> 指渐进式网页应用，目的是对 Web App 提升性能和改善用户体验。主要特点如下：

  * 可安装：可以像原生 APP 在主屏幕上留有图标。
  * 离线应用：可以离线使用，基于技术 Service Worker。
  * Service Worker 实际上是一段在后台运行的脚本。作为一个独立的线程，运行环境和普通脚本不同，所以不能直接参与 Web 交互行为，属于一种客户端代理。
  * Service Worker 可以创建有效的离线体验，拦截网络请求，并根据网络是否可用判断是否使用或更新缓存数据。
  * 消息推送。


## 发送数据埋点请求时使用 1x1 px 的透明 gif 图片
  * 跨域友好。
  * 执行过程无阻塞。
  * 能够完成整个 HTTP 请求和响应（尽管不需要响应内容）。
  * 触发 GET 请求后不需要获取和处理数据，服务器也不需要发送数据。
  * 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好。
  * GIF 的最低合法体积最小（合法的 GIF 只需要 43 个字节）。


## webpack loader、plugin 的区别

  * __loader__：一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程。
  * __plugin__：一个扩展器，它丰富了 webpack 本身，针对的是 loader 结束后 webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。



# 四、Vue

## 单向数据流
> 数据流指组件之间的数据流动，vue、react 遵循数据只能由外层组件向内层组件传递的单向数据流。特点是子组件不能直接修改从父组件传递过来的数据，否则一个子组件修改数据就会导致所有子组件变化。优点是所有状态的改变可记录、可跟踪，组件数据只有唯一的入口和出口，有利于代码维护。缺点是写起来不太方便，变更时需要创建各种 action 来维护对应的 state。


## 双向绑定数据
> 单双向绑定指 view、model 之间的映射关系，和数据流无关。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点是无法追踪局部状态的变化，增加了 debug 难度。react 采取单向绑定，vue 支持单向绑定(`插值，v-bind`) 和双向绑定(`v-model`)。

  * __实现原理__：vue2.0 采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter、getter 操作，在数据变动时发布消息给订阅者，触发相应监听回调。
  * __实现流程__ 
    * __1、模板解析为 render 函数__：函数包含所有的模板信息并返回一个虚拟 DOM，模板的 data 和指令变成了 JS 变量和 JS 逻辑。
    * __2、响应式监听__：通过 Object.defineProperty 设置对象的 get/set 实现监听 data 的属性变化，然后将 data 属性代理到实例对象 vm。
    * __3、页面渲染__：通过 updateComponent() 将模板渲染为 html。首次渲染时直接渲染虚拟 DOM，data 属性变化触发重新渲染时对比新旧节点后局部渲染。
  * __实现方式__
    * __发布者-订阅者模式__：一般通过 sub、pub 的方式实现数据和视图的绑定监听，更新数据 `vm.set('property', value)`。
    * __脏值检查__：angular 在指定事件触发时进入脏值检测，通过对比新旧数据来决定是否更新视图，它只对改变的数据进行更新元素。
    * __数据劫持__：vue2.0 通过 `Object.defineProperty()` 来监听对象各个属性的 getter、setter，属性改变时触发回调。
    * __ES6 Proxy__：vue3.0 用来替代 Object.defineProperty，因为它可以劫持整个对象而不需要遍历对象的所有属性。


  ```js
  for (var key in data) {
      (function (key) {
          Object.defineProperty(obj, key, {
              get: function() {
                  console.log('get', key);
                  return data[key];
              },
              set: function(newVal) {
                  console.log('set', newVal);
                  data[key] = newVal;
              }
          })
      })(key)
  }
  let data = new Proxy({
      get: function (obj, key) {
          return obj[key];
      },
      set: function (obj, key, val) {
          obj[key] = val;
          scan();
          return obj[key];
      }
  })
  ```

## 双向绑定和 vuex 是否冲突
> 严格模式下使用时，Vuex state 上使用 v-model 会导致出错。解决方案如下：

  * 使用带有 setter 的双向绑定计算属性。
  * `<Input>` 绑定 value，然后监听 input/change 事件并在事件回调中调用方法。


## Vue3.0 Proxy 替代 Object.defineProperty 的原因

  * __Object.defineProperty__：无法低耗费的监听到数组下标的变化，导致通过数组下标添加元素时不能实时响应。只能劫持对象的属性，从而需要对每个对象、每个属性进行遍历，如果属性值是对象则还需要深度遍历。
  * __Proxy__：可以劫持整个对象并返回一个新对象。可以代理对象、数组、动态增加的属性。



## 如何监控到属性修改并触发警告

  * 因为 Vue 是单向数据流，易于检测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。
  * 通过 setter 属性进行检测，修改值将会触发 setter，从而触发警告。


## v-for 时给每项元素绑定事件时需要用事件代理吗
> v-for 中使用事件代理可以使监听器数量和内存占用率都减少，vue 内部并不会自动做事件代理，所以在 v-for 上使用事件代理在性能上会更优。


## 父子组件生命周期钩子的执行顺序
> vue 生命周期：beforeCreate、created、beforeMount、Mounted、beforeUpdate、updated、beforedestroy、destroyed。

  * __加载渲染过程__：父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted。
  * __子组件更新过程__：父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated。
  * __父组件更新过程__：父 beforeUpdate -> 父 updated。
  * __销毁过程__：父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed。


## NextTick
> 在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。


## 组件 key

  * Key 是用于追踪哪些列表中的元素被修改、被添加或被移除的辅助标识，开发时需要保证元素的 key 在其同级元素中具有唯一性。
  * vue、react 都是通过 diff 算法来对比新旧虚拟节点，从而实现更新。Key 值则用来判断该元素是新创建的还是被移动而来的元素，从而减少不必要的重复渲染。


## 组件 data 必须是函数
> 因为 JS 本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有 Vue 实例的数据。如果将 data 作为一个返回一个对象的函数，那么每一个实例的 data 属性都是独立的，不会相互影响了。


## vuex 全局挂载

  * __window 挂载__：相当于增加全局属性，容易造成变量污染。数据是静态的而只能通过手动更新，数据更新后相关组件也不会重新渲染，必须手动渲染。
  * __vue 实例挂载__：store 数据更新后就会立即渲染所有使用 store 数据的组件。Vuex 使用单向数据流，store 数据的更新需要经过 action 层、mutation 层，层次划分明确，便于管理。


## Vuex mutation、Redux reducer 不能做异步操作？
> 纯函数，给定同样的输入返回同样的输出，可预测性。


## performance 性能模式
> 通过 Performance API 可以获取到当前页面中与性能相关的信息，Performance.timing 对象包含了各种与浏览器处理相关的时间数据 (接口耗时、资源加载时间等)。

  ```js
  // main.js：适用于开发模式和支持 performance.mark 的浏览器，开发工具的性能/时间线面板展示。
  const isDev = process.env.NODE_ENV !== "production";
  Vue.config.performance = isDev;
  ```

# 五、React

## 对比 Vue
### 相同点
  * 数据驱动视图
  * 都支持服务器端渲染
  * 都有支持 native 的方案：React 的 React native、Vue 的 weex。
  * 都有 Virtual DOM、webComponent 规范(组件化)，通过 props 实现父子通信。

### 不同点
  * __数据绑定__：vue 实现了数据的双向绑定，react 则不支持。
  * __框架模式__：Vue 是 `MVVM` 模式，React 则只针对 `MVC view 层`。
  * __state 对象__：vue 不是必须的，react 状态不可变并且只能通过 setState 更新。
  * __virtual DOM__：vue 会跟踪每个组件的依赖关系而`不需要重新渲染整个组件树`，React 则是每当应用状态被改变时`重新渲染全部组件`，需要 shouldComponentUpdate 控制。
  * __组件写法__：Vue 推荐使用 `webpack + vue-loader` 的单文件组件，即把 html、css、js 写在同一文件。React 则推荐 `JSX + inline style`，即把 html、css 全部写进 Js。
  * __复杂交互__：Vue 在工程上解决，通过记录 Model、双向绑定，Model 变更时更新 view 对应部分。React 则在算法上解决，实现 view 高效更新算法，Model 变更时更新整个 view。


## redux reducer 为何设计成纯函数
> redux 的设计思想是不产生副作用、数据更改的状态可回溯。

## react-router 里的标签和普通标签的区别
  * 有 onClick 则执行 OnClick。
  * 阻止 a 标签默认事件（跳转页面）。
  * 使用 history/hash 跳转，只是链接发现改变而并没有刷新页面。


## 组件的生命周期

  ```js
  // 1、组件挂载
  constructor   // 实例化：初始化 state，本地化 props，给事件处理函数绑定 this
  static getDerivedStateFromProps  // 实例化时或 props 变化时调用，返回 新state/null
  render        // 渲染函数：不能省略并且必须有返回值 (返回 null/false 表示不渲染)
  componentDidMount  // 挂载完成函数：axios 请求、事件绑定、setState 数据、操作 dom

  // 2、组件更新
  static getDeriverdStateFromProps  // 从 props 中获取 state
  shouldComponentUpdate    // 返回 true/false 表示是否更新组件，常用于组件性能优化
  render                   // 渲染
  getSnapshotBeforeUpdate  // 获取快照：最新渲染输出（提交到 DOM 节点）前被调用
  componentDidUpdate       // 更新完成函数

  // 3、组件卸载
  componentWillUnmount     // 预销毁函数：移除定时器、事件绑定等

  // 4、错误处理
  static getDerivedStateFromError // 从错误中获取 state
  componentDidCatch        // 捕获错误并进行处理
  ```


## Mixin、HOC、Render Prop、React Hooks

### Mixin
> 缺陷如下：

  * 命名冲突：多个 Mixin 可能定义了相同的 state 字段而导致数据覆盖问题。
  * 相关依赖：组件与 Mixin、多个 Mixin 之间都可能存在依赖关系，维护成本较高。
  * 增加复杂性：一个组件引入过多 mixin 时，代码逻辑将会非常复杂，过多的状态也降低了应用的可预测性。

### HOC
  * 优势
    * HOC 不会影响组件内部的状态，不存在冲突和互相干扰，这就降低了耦合度。
    * 不同于 Mixin 的打平+合并，HOC 具有层级结构（组件树结构），降低了复杂度。
  * 缺陷
    * 嵌套地狱：每一次 HOC 调用都会产生一个组件实例，过多的嵌套会导致难以溯源，而且可能会存在 props 属性覆盖问题。
    * 静态构建：HOC 只是声明了新组件但不会马上渲染，只有在组件被渲染时才执行。

### Render Prop
  * 优势
    * 动态构建，组件会重新渲染。
    * 不用担心 props 的命名冲突。
    * 可以溯源，子组件的 props 一定是来自于直接父组件。
  * 缺陷
    * 嵌套地狱：虽然摆脱了组件多层嵌套的问题，但是转化为了函数回调的嵌套。
    * 使用繁琐：HOC 可以通过装饰器语法的一行代码实现复用，Render Props 则不行。
    * 没有组件的上下文：没有 this.props 属性，不能像 HOC 那样可以直接获取到子组件实例对象 this.props.children。

### React Hooks
  * 优势
    * 解决了以上的嵌套问题，而且实现了视图和状态的分离，Hooks 还可以相互组合。
    * Hooks 为函数组件而生，从而解决了类组件的几大问题：this 指向容易错误、声明周期中的逻辑代码难以理解和维护、代码复用成本高等。
  * 缺陷
    * 存在不能出现在条件、循环中等写法限制，内部实现也不直观，增加了学习成本。
    * 在闭包场景可能会引用到旧的 state、props 值，React.memo 也不能完全替代 shouldComponentUpdate（因为拿不到 state change，只针对 props change）。

## Flux 思想
> 主要特点就是数据单向流动，具体流程如下：

  1. 用户访问 View。
  2. View 发出用户的 Action。
  3. Dispatcher 收到 Action，要求 Store 进行对应的更新。
  4. Store 更新后，发出一个 change 事件。
  5. View 收到 change 后，更新页面。


## 合成事件
> 如果 DOM 上绑定了过多的事件处理函数，整个页面的响应和内存占用可能都会受到影响。React 为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层 SyntheticEvent。

  * 当用户在为 onClick 添加函数时，React 并没有将 Click 时间绑定到 DOM，而是在 document 处监听所有支持的事件。
  * 当事件发生并冒泡至 document 时，React 才会让中间层 SyntheticEvent 将所有事件合成。所以原生事件会先执行，然后执行 React 合成事件，最后执行真正在 document 上挂载的事件。
  * React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，就会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document上，导致所有的 React事件都将无法被触发。


## setState 是异步还是同步

  * setState 只在合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步的。
  * setState 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中无法马上获取更新后的值，形成了所谓的“异步”。但可以通过第二个参数 callback 获取最新数据。
  setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。

## redux、dva、vuex

  * redux：通过 store 存储，通过 dispatch(action) 唯一更改，reducer 描述如何更改。
  * dva：基于 redux，结合 redux-saga 等中间件进行封装。
  * vuex：类似dva，集成化。action 异步，mutation 同步。

## redux 中间件
> 中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer。这种机制可以让我们改变数据流，实现异步 action、action 过滤、日志输出、异常报告等功能。常见的中间件如下：

  * __redux-thunk__：处理异步操作。
  * __redux-logger__：提供日志输出。
  * __redux-promise__：处理异步操作，actionCreator 的返回值是 promise。

## redux 缺点

  * 组件所需要的数据必须由父组件传过来，而不能像 flux 中直接从 store 获取。
  * 组件相关数据更新时，父组件即使用不到该组件也会重新 render，这样可能会影响效率，或者需要写复杂的 shouldComponentUpdate 进行判断。

## 性能优化方案
  * 使用 production 版本的 react.js。
  * 重写 shouldComponentUpdate 来避免不必要的 dom 操作。
  * 使用 key 来帮助 React 识别列表中所有子组件的最小变化。

## setState 执行

  * 前两次都是在 react 自身声明周期内，触发时 `isBatchingUpdates: true`，所以并不会直接执行更新，而是加入了 dirtyComponents，所以获取的都是更新前的状态 0。
  * 两次 setState 相同，react 内部会合并而只执行一次，完成后 state.val 值为 1。
  * setTimeout 中的代码触发时 `isBatchingUpdate: false`，直接更新而输出 2、3。


  ```js
  // 0、0、2、3
  class Example extends React.Component {
    constructor() {
      super();
      this.state = {
        val: 0
      }
    }
    
    componentDidMount() {
      this.setState({val: this.state.val + 1});
      console.log(this.state.val);

      this.setState({val: this.state.val + 1});
      console.log(this.state.val);

      setTimeout(() => {
        this.setState({val: this.state.val + 1});
        console.log(this.state.val);

        this.setState({val: this.state.val + 1});
        console.log(this.state.val);
      }, 0);
    }

    render() {
      return null;
    }
  }
  ```


# 六、小程序

## 架构原理

  * 数据驱动的架构模式，UI 和数据是分离的，所有的页面更新都通过对更新数据来实现。
  * 小程序本质是一个单页面应用，所有的页面渲染和事件处理都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口。
  * 它从技术讲和现有的前端开发差不多，采用 JS、WXML、WXSS 三种技术进行开发。功能可分为 webview、appService 两个部分。webview 用来展现 UI，appService 用来处理业务逻辑、数据及接口调用。两个部分在两个进程中运行，通过系统层 JSBridge 实现通信、UI 渲染、事件处理等。


## 生命周期

  * __onLoad()__：页面加载时触发，只会调用一次，可获取当前页面路径中的参数。
  * __onShow()__：页面显示/切入前台时触发，一般用来发送数据请求。
  * __onReady()__：页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。
  * __onHide()__：页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。
  * __onUnload()__：页面卸载时触发，比如 redirectTo、navigateBack 到其他页面时。


## 双向绑定对比 vue
> 大体相同，但小程序直接 this.data 的属性不可以同步到视图，必须调用 this.setData() 方法。

## wxml 与标准 html
> wxml 基于 xml 设计，标签只能在微信小程序中使用，不能使用 html 标签。


## 页面间传递数据
  * 使用全局变量实现数据传递。
  * 页面跳转或重定向时，使用 url 带参数传递数据。
  * 使用组件模板 template 传递参数。
  * 使用缓存传递参数。
  * 使用数据库传递数据。


## 提高应用速度
  * 提高页面加载速度
  * 用户行为预测
  * 减少默认 data 的大小
  * 组件化方案


# 七、编程相关

## 执行结果

  ```js
  // 结果：[1, NaN, NaN]
  // 原因：map 回调传入 item、index，执行 parseInt(1, 0)、parseInt(2, 1)、parseInt(3, 2)。
  ['1', '2', '3'].map(parseInt)


  // 什么情况下会打印 1
  var a = ?;
  if(a == 1 && a == 2 && a == 3){
    console.log(1);
  }
  var a = {
    value: 0,
    valueOf() {
      return ++this.value;
    }
  }


  // 实现 (5).add(3).minus(2)
  Number.prototype.add = function(n) {
    return this + n;
  }
  Number.prototype.minus = function(n) {
    return this - n;
  }


  // 某公司 1-12 月的销售额为：{1:22, 2:12, 5: 88}，请处理为：
  // [22, 12, null, null, 88, null, null, null, null, null, null, null]
  function convert(obj) {
    return Array.from({ length: 12 }).map((item, i) => obj[i] || null).slice(1);
  }
  ```


## 综合考察

  ```js
  function Foo() {
    getName = function () { console.log(1); };
    return this;
  }
  Foo.getName = function () { console.log(2);};
  Foo.prototype.getName = function () { console.log(3);};
  var getName = function () { console.log(4);};
  function getName() { console.log(5);}

  Foo.getName();        // 2
  getName();            // 4
  Foo().getName();      // 1
  getName();            // 1
  new Foo.getName();    // 2
  new Foo().getName();  // 3
  new new Foo().getName();    // 3
  ```



## 变量
  ```js
  /**
  * @desp 变量提升：JS 解析器都会将函数体内声明的变量移到函数体的顶部。
  * @result ：Goodbye Jack、World
  *
  **/
  var name = 'World';
  (function () {
    // var name; 
    if (typeof name === 'undefined') {
        var name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
  })();
  (function () {
      // 查找变量时，当前函数体内没找到则到一直向上到全局对象中寻找。
      console.log(name)
  })();

  // 赋值表达式：undefined、{ n: 2 }
  var a = {n: 1};
  var b = a;
  a.x = a = {n: 2};
  console.log(a.x, b.x)
  ```

## 作用域
  ```js
  var b = 10;
  (function b(){
      // 内部作用域会先去查找已有变量的声明，有则赋值，但 IIFE 函数无法赋值。
      b = 20;
      console.log(b);         // [Function b]
      console.log(window.b);  // 10

      // window.b = 20 打印：[Function b]、20
      // var b = 20 打印：20、10
  })();

  var a = 10;
  (function () {
      console.log(a)   // undefined
      a = 5
      console.log(window.a)   // 10
      var a = 20;
      console.log(a)   // 20
  })();
  ```


## this 指针
  ```js
  // 4 2 1
  function Foo() {
    Foo.a = function() {
      console.log(1)
    }
    this.a = function() {
      console.log(2)
    }
  }
  Foo.prototype.a = function() {
    console.log(3)
  }
  Foo.a = function() {
    console.log(4)
  }
  Foo.a();
  let obj = new Foo(); 
  obj.a();
  Foo.a();
  ```

## 对象应用
  ```js
  // http://www.baidu.com
  function changeObjProperty(o) {
    o.siteUrl = "http://www.baidu.com"
    o = new Object()
    o.siteUrl = "http://www.google.com"
  } 
  let webSite = new Object();
  changeObjProperty(webSite);
  console.log(webSite.siteUrl); 
  
  // [ , , 1, 2]
  var obj = {
      '2': 3,
      '3': 4,
      'length': 2,
      'splice': Array.prototype.splice,
      'push': Array.prototype.push
  }
  obj.push(1)
  obj.push(2)
  console.log(obj)
  ```


## 事件循环/异步
  ```js
  // script start、async1 start、async2、promise1、
  // script end、async1 end、promise2、setTimeout
  async function async1() {
      console.log('async1 start');
      await async2();
      console.log('async1 end');
  }
  async function async2() {
      console.log('async2');
  }
  console.log('script start');
  setTimeout(function() {
      console.log('setTimeout');
  }, 0)
  async1();
  new Promise(function(resolve) {
      console.log('promise1');
      resolve();
  }).then(function() {
      console.log('promise2');
  });
  console.log('script end');
  ```


## jsonp 封装
  ```js
  function jsonp ({url, param, callback}) {
    return new Promise((resolve, reject) => {
      var script = document.createElement('script')
      window.callback = function (data) {
        resolve(data)
        document.body.removeChild('script')
      }
      var param = {...param, callback}
      var arr = []
      for (let key in param) {
        arr.push(`${key}=${param[key]}`)
      }
      script.src = `${url}?${arr.join('&')}`
      document.body.appendChild(script)
    })
  }
  ```


## 实现一个 sleep 函数

  ```js
  // Promise
  function sleep1(time) {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, time);
    })
  }
  sleep1(1000).then(() => console.log("sleep1"));

  // Generator
  function* sleep2(time) {
    return yield sleep1(time);
  }
  const s = sleep2(1500);
  s.next().value.then(() => console.log("sleep2"));


  // Async/Await
  async function sleep3(time) {
    await sleep1(time);
  }
  (async () => {
    await sleep3(2000);
    console.log("sleep3")
  })()
  ```


## 消息队列的类实现

  ```js
  // 设计一个 LazyMan 类，实现以下功能
  LazyMan('Tony');
  // Hi I am Tony
  LazyMan('Tony').sleep(10).eat('lunch');
  // Hi I am Tony
  // 等待了10秒...
  // I am eating lunch
  LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
  // Hi I am Tony
  // I am eating lunch
  // 等待了10秒...
  // I am eating diner
  LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
  // Hi I am Tony
  // 等待了5秒...
  // I am eating lunch
  // I am eating dinner
  // 等待了10秒...
  // I am eating junk food

  class LazyManClass {
    constructor(name) {
      this.name = name;
      this.fns = [];
      console.log(`Hi I am ${this.name}`);
      setTimeout(() => {
        this.next();
      });
      return this
    }

    sleep(time) {
      const fn = () => {
        setTimeout(() => {
          console.log(`等待了${time}秒...`)
          this.next();
        }, time * 1000)
      }
      this.fns.push(fn);
      return this;
    }

    sleepFirst(time) {
      const fn = () => {
        setTimeout(() => {
          console.log(`等待了${time}秒...`)
          this.next();
        }, time * 1000)
      }
      this.fns.unshift(fn);
      return this;
    }

    eat(food) {
      const fn = () => {
        console.log(`I am eating ${food}`);
        this.next();
      }
      this.fns.push(fn);
      return this;
    }

    next() {
      const fn = this.fns.shift();
      fn && fn();
    }
  }

  const LazyMan = (name) => {
    return new LazyManClass(name);
  }
  ```




