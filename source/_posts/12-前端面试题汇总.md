---
title: 前端面试题汇总
tags:
  - 面试
categories: 面试
top: false
keywords:
  - 面试
date: 2020-03-22 17:31:06
description: 高级前端面试必备
---

# 一、HTML

## link、@import 导入区别
  * __从属关系__：@import 只能用于加载 CSS，link 是 XHTML 标签，它还可以定义 RSS、rel 连接属性、引入网站图标等。
  * __加载顺序__：加载页面时，link 引入的 CSS 被同时加载，@import 引入的 CSS 会等到页面被全部加载完成后再加载。
  * __兼容性__：link 无兼容性问题，@import 只有 IE5+ 才能被识别。


## 常见的浏览器内核
  * IE：__Trident__
  * Firefox：__Gecko__
  * Safari：__Webkit__
  * Chrome：__Blink__
  * Opera：__Blink__


## 简述浏览器的渲染原理
> 为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。

  1. 解析 HTML 标记并构建 __DOM 树__。
  2. 解析 CSS 标记并构建 __CSSOM 树__。
  3. 根据 DOM、CSSOM 构建__渲染树__，节点是包含颜色等属性的渲染对象。
  4. __布局__：根据渲染树进行布局，计算各个节点在页面的位置、大小等信息。
  5. __绘制__：调用渲染对象的 paint 方法，将它们的内容显示在屏幕并绘制基础组件。
    

## HTML5 form 的自动完成功能
  * __autocomplete__ 属性规定表单是否应该启用自动完成功能，它自动完成允许浏览器预测对输入字段。在用户在开始键入时，浏览器基于之前键入过的值显示出历史选项。
  * 关闭自动完成功能的方法：IE Internet 选项菜单的内容--自动完成里面设置、设置 `<form autocomplete="off"></form>` 来关闭整个表单的自动提示功能、设置 `<input autocomplete="off" />` 来关闭输入框的自动完成功能。


## 浏览器标签页之间的通信
> 实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者来让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

  1. __Websocket__：通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。
  2. __localStorage__：localStorage 在另一个浏览上下文里被添加、修改或删除时会触发 storage 事件，可以通过监听该事件来实现页面之间的通信。
  3. __SharedWorker__：服务器注册一个 onmessage 监听信息的事件，客户端(即使用 sharedWorker 的标签页)发送 message 时就会触发。


## 简述前端性能优化

  1. __页面内容方面__
    1. 通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
    2. 通过 DNS 缓存等机制来减少 DNS 的查询次数。
    3. 通过设置缓存策略，对常用不变的资源进行缓存。
    4. 通过延迟加载的方式，来减少页面首屏加载时需要请求的资源，延迟加载的资源当用户需要访问时，再去请求加载。
    5. 通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。
  2. __服务器方面__
    1. 使用 CDN 服务，来提高用户对于资源请求时的响应速度。
    2. 服务器端自用 Gzip、Deflate 等方式对于传输的资源进行压缩，减少传输文件的体积。
    3. 尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie。


## 什么是 webp

  * __WebP__：谷歌开发的一种新图片格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。最大优点是在相同质量的文件下，它拥有更小的文件体积，这样可以减少请求时间而提升u用户体验，因此它非常适合于网络图片的传输。
  * __浏览器判断是否支持 webp 格式图片__：通过创建 Image 对象，将其 src 属性设置为 webp 格式的图片，然后在 onload 事件中获取图片的宽高。能够获取说明支持，不能获取或触发了 onerror 函数则说明不支持。


# 二、CSS

## BFC 及其应用
  * __简单介绍__：Block Format Context 块级格式化上下文，是页面盒模型中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。
  * __创建方式__：html 根元素、float、绝对定位、overflow 不为 visible、display: table/flex。
  * __主要作用__：清除浮动、防止同一 BFC 容器中的相邻元素间的外边距重叠问题。


## CSS 盒模型

  * __组成__：margin、border、padding、content。
  * __标准盒模型__：box-sizing: content-box。
  * __IE 盒模型__：box-sizing: border-box。


## 重绘和回流，以及优化

  * __重绘重排__
    * 重绘：简单外观的改变而不会影响布局，比如 outline、visibility、color。
    * 回流：布局或几何属性改变而重新计算布局，大部分都会会导致页面的重新渲染。
    * 关系：重绘不一定会引发回流，回流必定会发生重绘，它们都会重新生成渲染树。
  * __优化方案__
    * __CSS__
      * CSS 硬件加速。
      * 避免使用 table 布局。
      * 使用 transform 代替 top。
      * 尽可能在 DOM 树的最末端改变 class。
      * 避免使用 CSS 表达式，可能会引发回流。
      * 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
      * 使用 visibility 替换 display: none，前者引起重绘，后者引发回流。
      * 将动画效果应用到 position: absolute/fixed 的元素，避免影响其他布局。
    * __Javascript__
      * 避免频繁操作样式，修改 class 最好。
      * 避免频繁操作 DOM，合并多次修改为一次。
      * 避免频繁读取会引发回流/重绘的属性，将结果缓存。
      * 对具有复杂动画的元素使用绝对定位，使它脱离文档流。


## opacity、visibility、display
  * __opacity: 0__：占据空间，可以点击，引起重绘，子元素不影响。
  * __display: none__：不占空间，不能点击，会引起回流，子元素不影响。
  * __visibility: hidden__：占据空间，不能点击，引起重绘，子元素可设置 visible 进行显示。


## Rem 及其原理
  * __Rem__：CSS3 新增的相对长度单位，指相对于根元素 html 的 font-size 大小，移动端新型浏览器支持较好。px 是相对固定单位，无法随着浏览器进行缩放。
  * __转换原理__：默认根元素的 font-size: 16px，如果想要设置为 12px 则就是 12px/16px = 0.75rem。通过 postcss-px-to-viewport 插件可以实现对 px 到 vw 的自动转换。


## 移动端视口配置
  * __initial-scale__: 初始的缩放比例。
  * __minimum-scale__: 允许用户缩放到的最小比例。
  * __maximum-scale__: 允许用户缩放到的最大比例。
  * __user-scalable__: 用户是否可以手动缩放。

## 伪类和伪元素
  * __伪类__：用于为处于某种状态的已有元素添加样式，该状态是随着用户行为变化的。比如说 :hover。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。
  * __伪元素__：用于创建一些原本不在文档树中的元素，并为其添加样式。比如 ::before，虽然用户可以看到这些内容，但是其实它不在文档树中。
  * __区别__：伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。css 规范规定使用双冒号 :: 表示伪元素，一个冒号 : 表示伪类。


## 可继承的 css 属性
  * __字体系列属性__：font-family、font-size、font-weight、font-style。
  * __文本系列属性__：text-indent、text-align、line-hight、word-spacing、letter-spacing、color。
  * __其他__：cursor、visibility。


## min/max-width、min/max-height 覆盖规则
  * max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。
  * min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突时。



# 三、Javascript

## 防抖和节流
> 在网页实际运行的某些场景下，有些事件会被连续触发而频繁进行 DOM 操作和资源加载，严重影响了网页性能，甚至会造成浏览器崩溃。两者都是针对连续触发的某个行为，区别在于是要优化到减少它的执行次数还是只执行一次。

  * __防抖__
    * 基础理解：将一个弹簧连续按下，但只会在最后放手的一瞬反弹。即我们希望高频事件只执行一次，实现回调函数的延时执行。
    * 应用场景：搜索框输入内容时 `keyup` 事件、浏览器窗口调整时 `resize` 事件。
  * __节流__
    * 基础理解：一个水龙头在滴水时保持 一滴水/s 的频率。即我们希望高频事件以一定频率重复调用，减少函数的执行次数。
    * 应用场景：拖拽元素时 `drag` 事件、监听滚动时 `scroll` 事件、鼠标移动时 `mousemove` 事件、手指滑动时 `touchmove` 事件。


  ```js
  // 防抖：n 秒内高频事件再次被触发则重新执行。
  function debounce(callback, delay=200){
    let timer = null;
    return function(){
      if(timer) clearTimeout(timer);
      timer = setTimeout(()=>{
        callback.apply(this, arguments);
        timer = null;
      }, delay);
    }
  }
  let handleSeach = debounce(seachAjax, 500)
  input.addEventListener("keyup", e=>{ handleSeach(e.target.value)})

  // 节流：n 秒内只会执行一次。
  function throttle(callback, duration=200){
    let timer = null;
    return function(){
      if(timer) return;
      timer = setTimeout(()=>{
        callback.apply(this, arguments);
        timer = null;
      }, duration);
    }
  }
  let handleScroll = throttle(handleScroll)
  window.addEventListener("touchmove", handleScroll);
  ```


## ES5/ES6 继承的区别

  * class 声明内部会启用严格模式。
  * class 声明会提升，但不会初始化赋值。
  * class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
  * class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有 constructor，不能使用 new 调用。
  * 必须使用 new 来调用 class。
  * class 内部无法重写类名。


## ES6 代码转成 ES5 代码的实现思路
> Babel 的实现方式：

  1. 将代码字符串解析成抽象语法树，即所谓的 AST。
  2. 对 AST 进行处理，在这个阶段可以对 ES6 AST 进行相应转换，即转换成 ES5 AST。
  3. 根据处理后的 AST 再生成代码字符串。


## 箭头函数与普通函数的区别
> 箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数的差异如下：

  * 函数体内的 this 对象，是定义时所在的对象，而不是使用时所在的对象。
  * 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
  * 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
  * 不可以使用 new 命令，因为：
    * 没有自己的 this，无法调用 call、apply。
    * 没有 prototype 属性，而 new 命令在执行时需要将钩子函数的 prototype 赋值给新的对象的 `__proto__`。


## setTimeout、Promise、Async/Await 区别

  * __setTimeout__：回调函数放到宏任务队列里，等到执行栈清空以后执行。
  * __Promise__：本身是同步的立即执行函数，当在 executor 中执行 resolve/reject 时是异步操作，会先执行 then/catch 等，当主栈完成时，才会去调用 resolve/reject 中的方法。
  * __async__：函数返回一个 Promise 对象，当函数执行时一旦遇到 await 就会先返回，等到异步操作完成后再执行函数体内后面的语句。可理解为让出了线程而跳出了 async 函数体。


## Async/Await 同步方式实现异步
> 本质是一个自执行的 generate 函数，利用 generate 的特性把异步代码写成同步形式。

  ```js
  var fetch = require("node-fetch");

  function *gen() { // * 可以看作 async
    var url = "https://api.github.com/users/github";
    var result = yield fetch(url); // yield 可以看作 await
    console.log(result.bio);
  }

  var g = gen();
  var result = g.next();
  result.value.then(data => data.json()).then(data  => g.next(data));
  ```

## 简述 Generator 函数
> 异步编程(即多任务)的解决方案有一种叫做__协程__：多个线程互相协作来完成异步任务，即线程 A 执行到某处之后暂停并等到线程 B 执行完毕后继续执行。Generator 函数的最大特点就是可以交出函数的执行权（即暂停执行）。

  ```js
  function* gen(x) {
    var y = yield x + 2;
    return y;
  }
  // next(value)：向外输出数据，参数值将作为上一个 yield 语句的返回值。
  var g = gen(1);
  g.next()     // 返回 yield 表达式 x + 2 的值，{ value: 3, done: false }
  g.next(2)    // 参数值为异步任务结果并被 y 接收， { value: 2, done: false }
  ```


## JS 异步解决方案的发展历程和优缺点

  * __回调函数__
    * 优点：解决了同步的问题（整体任务执行时长）。
    * 缺点：回调地狱，不能用 try catch 捕获错误，不能 return。
  * __Promise__
    * 优点：解决了回调地狱的问题。
    * 缺点：无法取消 Promise，错误需要通过回调函数来捕获。
  * __Generator__
    * 特点：可以控制函数的执行。
  * __Async/Await__
    * 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题。
    * 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。


##  MVC、MVP、MVVM 模式
> __View__ 视图模板、__Model__ 数据模型、__Controller/Presenter__ 处理业务逻辑的控件、__ViewModel__ 监听变化并处理业务逻辑的控件。

  * __MVC__
    * View、Model 直接绑定，因此很多 view 可以修改多个 model 而变得混乱，交互增加导致代码不好维护。
    * 具体流程：View 捕获用户操作 -> Controller 处理数据并调用对应的 Model 接口 -> Model 更新后通过观察者模式通知 View -> View 收到更新消息后向 Model 请求最新数据并更新界面。
  * __MVP__
    * View 绑定事件的事件驱动机制，并通过 Presenter 实现分离和通信。它定义了 View、Presenter 之间的接口，需要维护 Presenter 的内部实现。
    * 具体流程：View 用户操作 -> Presenter 调用 Model 接口  -> Model 更新后通知 Presenter -> Presenter 调用 View 提供的接口更新界面。
  * __MVVM__
    * View、Model 分别通过 ViewModel 的 DOM-Listeners、Data-Bindings 绑定事件和管理数据而实现了双向绑定。它实现了数据与视图的分离，通过数据来驱动视图，开发者只需要关心数据变化 (DOM 操作被封装了)。
    * 具体流程：View 用户操作 –> ViewModel 监听到变化通知 Model –> Model 更新 –> ViewModel 通知 View 更新。


## Set、Map、WeakSet、WeakMap 区别

  * __Set__
    * 成员不能重复。
    * 只有键值，没有键名，有点类似数组。
    * 可以遍历，方法有 add、delete、has。
  * __WeakSet__
    * 成员都是对象（引用）。
    * 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露。
    * 不能遍历，方法有 add、delete、has。
  * __Map__
    * 本质上是键值对的集合，类似集合。
    * 可以遍历，方法很多，可以跟各种数据格式转换。
  * __WeakMap__
    * 只接收对象为键名（null 除外），不接受其他类型的值作为键名。
    * 键名指向的对象，不计入垃圾回收机制。
    * 不能遍历，方法同 get、set、has、delete。


## 简述浏览器缓存读取规则
> 浏览器缓存可以优化性能，比如直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，则使用缓存从而减少响应数据。

### 缓存位置
  * __Service Worker__：运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用时传输协议必须为 HTTPS。它的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由缓存哪些文件、如何匹配缓存、如何读取缓存，而缓存是可持续性的。Service Worker 也是 PWA 的核心技术。
  * __Memory Cache__：内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据很高效，但是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
  * __Disk Cache__：存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，它的覆盖面最大。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。
  * __Push Cache__：推送缓存，是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被时候用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂（大约 5 分钟）。

### 缓存过程分析
> 浏览器与服务器通信的方式为应答模式：浏览器发起 HTTP 请求、服务器响应该请求。浏览器第一次向服务器发起该请求并拿到请求结果后，将请求结果和缓存存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源返回的响应头来确定的。

  * 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。
  * 浏览器每次拿到返回的请求结果都会将该结果和缓存表示存入浏览器缓存中。


## call、apply 对比

  * Function.prototype.apply/call 作用一样，区别在于传入参数的不同。第一个参数是 this 要指向的对象，null、undefined 时默认指向 window，后面的参数分别是参数数组、参数列表。
  * call 比 apply 的性能要好，call 传入参数的格式正式内部所需要的格式。


## 发送数据埋点请求时使用 1x1 px 的透明 gif 图片
  * 跨域友好。
  * 执行过程无阻塞。
  * 能够完成整个 HTTP 请求和响应（尽管不需要响应内容）。
  * 触发 GET 请求后不需要获取和处理数据，服务器也不需要发送数据。
  * 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好。
  * GIF 的最低合法体积最小（合法的 GIF 只需要 43 个字节）。


## ['1', '2', '3'].map(parseInt)

  * __结果__：[1, NaN, NaN]。
  * __原因__：map 回调传入 item、index，具体执行的是 parseInt(1, 0)、parseInt(2, 1)、parseInt(3, 2)。


## 实现一个 sleep 函数

  ```js
  // Promise
  function sleep1(time) {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, time);
    })
  }
  sleep1(1000).then(() => console.log("sleep1"));

  // Generator
  function* sleep2(time) {
    return yield sleep1(time);
  }
  const s = sleep2(1500);
  s.next().value.then(() => console.log("sleep2"));


  // Async/Await
  async function sleep3(time) {
    await sleep1(time);
  }
  (async () => {
    await sleep3(2000);
    console.log("sleep3")
  })()
  ```


## 考察消息队列的类实现

  ```js
  // 设计一个 LazyMan 类，实现以下功能
  LazyMan('Tony');
  // Hi I am Tony
  LazyMan('Tony').sleep(10).eat('lunch');
  // Hi I am Tony
  // 等待了10秒...
  // I am eating lunch
  LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
  // Hi I am Tony
  // I am eating lunch
  // 等待了10秒...
  // I am eating diner
  LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
  // Hi I am Tony
  // 等待了5秒...
  // I am eating lunch
  // I am eating dinner
  // 等待了10秒...
  // I am eating junk food

  class LazyManClass {
    constructor(name) {
      this.name = name;
      this.fns = [];
      console.log(`Hi I am ${this.name}`);
      setTimeout(() => {
        this.next();
      });
      return this
    }

    sleep(time) {
      const fn = () => {
        setTimeout(() => {
          console.log(`等待了${time}秒...`)
          this.next();
        }, time * 1000)
      }
      this.fns.push(fn);
      return this;
    }

    sleepFirst(time) {
      const fn = () => {
        setTimeout(() => {
          console.log(`等待了${time}秒...`)
          this.next();
        }, time * 1000)
      }
      this.fns.unshift(fn);
      return this;
    }

    eat(food) {
      const fn = () => {
        console.log(`I am eating ${food}`);
        this.next();
      }
      this.fns.push(fn);
      return this;
    }

    next() {
      const fn = this.fns.shift();
      fn && fn();
    }
  }

  const LazyMan = (name) => {
    return new LazyManClass(name);
  }
  ```


## 代码实现

  ```js
  // 什么情况下会打印 1
  var a = ?;
  if(a == 1 && a == 2 && a == 3){
    console.log(1);
  }
  var a = {
    value: 0,
    valueOf() {
      return ++this.value;
    }
  }

  // 实现 (5).add(3).minus(2) 功能
  Number.prototype.add = function(n) {
    return this + n;
  }
  Number.prototype.minus = function(n) {
    return this - n;
  }

  // 某公司 1-12 月的销售额为：{1:22, 2:12, 5: 88}，请处理为：
  // [22, 12, null, null, 88, null, null, null, null, null, null, null]
  function convert(obj) {
    return Array.from({ length: 12 }).map((item, i) => obj[i] || null).slice(1);
  }
  ```


# 四、Vue

## 单向数据流
> 数据流指组件之间的数据流动，vue、react 遵循数据只能由外层组件向内层组件传递的单向数据流。特点是子组件不能直接修改从父组件传递过来的数据，否则一个子组件修改数据就会导致所有子组件变化。优点是所有状态的改变可记录、可跟踪，组件数据只有唯一的入口和出口，有利于代码维护。


## 双向绑定数据
> 单双向绑定指 view、model 之间的映射关系，它和数据流没有关系。react 采取单向绑定，vue 支持单向绑定(`插值，v-bind`) 和双向绑定(`v-model`)。

  * __实现原理__：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应监听回调。
  * __实现流程__
    * __1、模板解析为 render 函数__：函数包含所有的模板信息并返回一个虚拟 DOM，模板的 data 和指令变成了 JS 变量和 JS 逻辑。
    * __2、响应式监听__：通过 Object.defineProperty 设置对象的 get/set 实现监听 data 的属性变化，然后将 data 属性代理到实例对象 vm。
    * __3、页面渲染__：通过 updateComponent() 将模板渲染成 html，首次渲染时直接将虚拟节点 vnode 渲染为 DOM，data 属性变化触发重新渲染时对比新旧节点进行局部渲染。
  * __实现方式__
    * __发布者-订阅者模式__：一般通过 sub、pub 的方式实现数据和视图的绑定监听，更新数据 `vm.set('property', value)`。
    * __脏值检查__：angular 在指定事件触发时进入脏值检测，通过对比新旧数据来决定是否更新视图，它只对改变的数据进行更新元素。
    * __数据劫持__：vue2.0 采用 数据劫持 + 发布者-订阅者模式 的方式。通过 `Object.defineProperty()` 来监听所有属性的 get、set。在数据变动时发布消息给订阅者，触发相应的监听回调。
    * __ES6 Proxy__：vue3.0 用来替代 Object.defineProperty，因为它可以劫持整个对象而不需要遍历对象的所有属性。


  ```js
  for (var key in data) {
      (function (key) {
          Object.defineProperty(obj, key, {
              get: function() {
                  console.log('get', key);
                  return data[key];
              },
              set: function(newVal) {
                  console.log('set', newVal);
                  data[key] = newVal;
              }
          })
      })(key)
  }
  let data = new Proxy({
      get: function (obj, key) {
          return obj[key];
      },
      set: function (obj, key, val) {
          obj[key] = val;
          scan();
          return obj[key];
      }
  })
  ```

## 双向绑定和 vuex 是否冲突
> 严格模式下使用时，Vuex state 上使用 v-model 会导致出错。解决方案如下：

  * 使用带有 setter 的双向绑定计算属性。
  * `<Input>` 绑定 value，然后监听 input/change 事件并在事件回调中调用方法。


## Vue3.0 Proxy 替代 Object.defineProperty 的原因

  * __Object.defineProperty__：无法低耗费的监听到数组下标的变化，导致通过数组下标添加元素时不能实时响应。只能劫持对象的属性，从而需要对每个对象、每个属性进行遍历，如果属性值是对象则还需要深度遍历。
  * __Proxy__：可以劫持整个对象并返回一个新对象。可以代理对象、数组、动态增加的属性。


## 如何监控到属性修改并触发警告

  * 因为 Vue 是单向数据流，易于检测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。
  * 通过 setter 属性进行检测，修改值将会触发 setter，从而触发警告。


## v-for 时给每项元素绑定事件时需要用事件代理吗
> v-for 中使用事件代理可以使监听器数量和内存占用率都减少，vue 内部并不会自动做事件代理，所以在 v-for 上使用事件代理在性能上会更优。


## 父子组件生命周期钩子的执行顺序
> vue 生命周期：beforeCreate、created、beforeMount、Mounted、beforeUpdate、updated、beforedestroy、destroyed。

  * __加载渲染过程__：父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted。
  * __子组件更新过程__：父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated。
  * __父组件更新过程__：父 beforeUpdate -> 父 updated。
  * __销毁过程__：父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed。


##  React/Vue 组件的 key
> vue、react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。当对比没有结果时会通过 key 查找相应旧节点，没有找到则认为是一个新增节点，如果没有 key 则只能采用遍历查找、map 映射的方式。


## Vuex mutation、Redux reducer 不能做异步操作？
> 纯函数，给定同样的输入返回同样的输出，可预测性。



# 五、React

## redux reducer 为何设计成纯函数
> redux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处都是纯函数。

## react-router 里的标签和普通标签的区别
  * 有 onClick 则执行 OnClick。
  * 阻止 a 标签默认事件（跳转页面）。
  * 使用 history/hash 跳转，只是链接发现改变而并没有刷新页面。






