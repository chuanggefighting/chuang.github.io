---
title: 移动端开发
tags:
  - 移动端
categories: 移动端
top: false
keywords:
  - 移动端
date: 2019-06-24 02:03:23
description: 开发模式、适配方案、flex 布局、事件类型
---

# 一、开发模式
> 移动端开发模式分三种，前端只能开发 Web App。

  <div align="center">
    ![Mobile Mode](/images/mobile/mode.png)
  </div> 

## Native App
> 移动端的原生应用。

  * 实现：基于手机操作系统 API 并使用原生语言编写。
  * 优点：支持离线运行、能够访问智能设备提供的所有功能、更好的性能和用户体验、更丰富的图形动画和更好的渲染效果。
  * 缺点：开发成本较高，同一个项目至少需要 Android、iOS、Web 三个开发团队。维护、更新成本高：需要所有用户重新下载安装。


## Web App
> 移动端的 Web 浏览器，注意 PC Web 运行在 Windows、Linux。

  * 实现：基于 Html5 实现并运行在 iOS、Android。
  * 优点：开发成本较低、适用范围广并跨平台、可以方便快速地部署、用户不需要重新下载即可直接访问最新版本而维护成本低。
  * 缺点：图形和动画渲染效果差、用户体验差：加载慢、费流量、不能调用相机和 GPS 等系统相关功能。


## Hybrid App
> 混合 App，兼具 Native 原生体验、H5 跨平台开发和快速迭代的优势。

  * 实现：使用原生语言编写功能性的应用外壳，然后在其中内嵌展示性的 H5 页面。
  * 优点：部分支持离线功能、维护和更新较为方便、可调用智能设备相关功能。
  * 缺点：用户体验较差、图形和动画渲染效果较差。



# 二、适配方案
> 让页面能在不同尺寸、不同分辨率的移动设备上，尽可能的实现合理展示。

  <div style="text-indent: 2em">设计图都是 2 倍的，是因为页面中除了字体是矢量图而大部分都是位图。如果 1px 宽高的盒子里放入 1px 宽高的图片则图片会失真，因为在移动端渲染时是用 4px 渲染，但是如果我们给 1px 宽高的盒子放入 2px 宽高的图片则不失真。</div>


## 设备判断

  ```js
  // 环境判断：微信、支付宝、移动端、Ios、Android
  export default {
    isWechat: navigator.userAgent.toLowerCase().indexOf("micromessenger") > -1,
    isAlipay: navigator.userAgent.toLowerCase().indexOf("alipay") > -1,  
    isMobile = /Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent),
    isIOS: /iPhone|iPad|iPod/i.test(navigator.userAgent),
    isAndroid: /Android/i.test(navigator.userAgent),
  }
  ```


## 两种像素
> 使用 css 像素单位时，同样样式的代码在不同屏幕分辨率的移动设备中显示的情况基本一致，是因为移动设备通过像素比转换了 css 像素实际大小

  1. 设备像素
    * 概念：物理像素，通常指设备的分辨率。单位 dp，是设备能控制显示的最小单位。
    * 特点：同一个设备的 1dp 代表的物理长度是固定不变的、像素比例取决于 屏幕特性（是否高清屏）和用户缩放比例。
  2. CSS 像素
    * 概念：逻辑像素，主要用于精确度量浏览器的 Web 页面。单位 px，是独立于设备而用于 web 开发的抽象单位。
    * 特点：改变大小的场景有缩放屏幕、更换设备。页面放大时，1px 等于更多的物理像素，页面能看到的内容减少。


## Viewport
> 浏览器上用来显示网页的部分区域，是手机浏览器的实际宽度。

  <div style="text-indent: 2em">PC 端网站都是以浏览器窗口(设备屏幕) 作为视口进行布局。但是在移动端，手机浏览器的实际宽度默认比手机屏幕宽很多，无论手机宽度是 320px、640px，在手机浏览器内部的宽度始终会是浏览器本身的 viewport （主流为 980px）。手机浏览器为了浏览桌面端网页时显示正常，设计页面时一般基于 960px，然而这样会使手机浏览器出现横向滚动条。为了避免这种情况，移动设备的浏览器会自动将视口缩放到移动端窗口的大小，网页内容看起来被压扁而不容易观看。可简单理解为：`当浏览器宽度小于 980 时，Viewport 宽度就是980，当浏览器尺寸宽度大于 980 时 Viewport 宽度和浏览器宽度一致`。</div>


### 分类
> 移动设备默认的是 布局视口，但是移动端开发时需要的是 理想视口。

  * `布局视口`：手机浏览器的实际区域，用于计算 CSS 页面布局。
  * `视觉视口`：用户当前看到的区域，放大页面时内容减少但并不会受影响。
  * `理想视口`：移动设备的屏幕区域，它以 CSS 像素单位计算并与设备的物理宽高无关。


### 设置
> 视口控制通过 meta 实现：`设备宽度 = 页面宽度 = 浏览器视口宽度`，但只对移动端有效。

  ```js
  // 启用360浏览器的极速模式 (webkit)  
  <meta name="renderer" content="webkit" />

  // 优先使用 IE 最新版本和 Chrome  
  <meta http-equiv="X-UA-Compatible" content="IE=EDGE, chrome=1" />

  // 页面窗口自动调整到设备宽度，并禁止用户缩放页面 (scale) 
  <meta name="viewport" content="width=device-width, height=device-height, 
  initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  // 使用全屏模式运行，仅针对 ios safari  
  <meta name="apple-mobile-web-app-capable" content="yes" />
  
  // 设置顶端状态栏背景为灰色半透明，仅针对 ios safari  
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  // windows phone 点击无高光 
  <meta name="msapplication-tap-highlight" content="no" />

  // 关闭电话号码和邮箱的自动识别  
  <meta name="format-detection" content="telephone=no, email=no" />
  ```


## 实现方式

### viewport 缩放
> 针对不同屏幕分辨率的手机设置等比例缩放。简单方便，但是 PC 端可能会界面变形、像素失真。

  ```js
  <meta name="viewport" content="width=device-width, height=device-height, 
    initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  ```


### 响应式布局
  <div style="text-indent: 2em">设计理念通过媒体查询根据不同的屏幕分辨率来进行适配，从而在不同设备不同分辨率下都有良好的用户体验，一般通过媒体查询设置移动端宽度。缺点是 无法覆盖全部分辨率、代码量大且维护性难、安卓机型问题较多，一般只适合简单的资讯类页面。</div>

  ```css
  /* 法一 */ 
  link media="(max-width:480px)" href="mobile.css"
	
  /* 法二 */ 
  @media all and (orientation :landscape) {  /* 横屏 */  } 
  @media all and (orientation :portrait) {  /* 竖屏 */  }
  @media screen and (max-width: 500px) {  
     body { background: black }
  }
  ```


### 弹性布局
> 使容器子元素的宽高能够最合理的方式填充空间。

1. __百分比布局__
    * 优点：宽度自适应，在不同的分辨率下都能达到适配。
    * 缺点：需要确定父级元素的大小、一般需要固定高度但不好设置。
    * 特点：width、height 等大部分相对于直接父元素。border-radius、translate、background-size 等相对于自身。
  2.  __vw、vh 布局__：
    * 优点：指定相对视口的宽高实现宽高自适应，单位转换方便。
    * 缺点：单位换算时可能出现小数、IE11 和一些低版本手机不支持。
  3. __rem 布局__：
    * 优点：通过字体自适应解决移动端适配屏幕尺寸问题的布局方式，只适用于固定尺寸。
    * 缺点：不能兼容所有终端，而且使字号在不同屏幕上的绝对尺寸不一致，不符合用户习惯
    * 实现原理：直接通过媒体查询设置根元素的 font-size、通过 js 读取屏幕宽度计算出对应尺寸并设置根元素的 font-size。


  ```css
  /* 通过媒体查询实现移动端字体的自适应 */
  @media screen and (min-width: 375px){
    html { font-size: 14.0625px; }
  }
  @media screen and (min-width: 360px){
    html { font-size: 13.5px;  }
  }
  @media screen and (min-width: 320px){
    html { font-size: 12px; }
  }
  html {
    font-size: 16px;
  }
  ```

  ```js
  //  Js 动态设置 rem：以设计图 640 分辨率为标准封装 rem.js，网上有优化版 flexible.js 等
  (function (doc, win) {
      var docEl = doc.documentElement,
          resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
          recalc = function () {
              // 获取屏幕宽度
              var clientWidth = docEl.clientWidth;
              if (!clientWidth) return;
              if (clientWidth >= 640) {
                  docEl.style.fontSize = '100px';
              } else {
                  // 设置 html 的字体大小：clientWidth/(640/100)
                  docEl.style.fontSize = 100 * (clientWidth / 640) + 'px';
              }
          };
      if (!doc.addEventListener) return;
      win.addEventListener(resizeEvt, recalc, false);
      doc.addEventListener('DOMContentLoaded', recalc, false);
  })(document, window);
  ```
  

### vue 方案
> vue-cli3 项目通过 vw 实现移动端适配，需要安装插件 `npm i postcss-px-to-viewport -D`。

  ```js
  // postcss.config.js
  module.exports = {
    plugins: {
      'autoprefixer': {},
      'postcss-px-to-viewport': { 
        viewportWidth: 750,    // 视窗宽度，对应设计稿的宽度，一般是 750 
        viewportHeight: 1334,  // 视窗高度，根据 750 设备的宽度来指定，一般指定 1334
        unitPrecision: 3,      // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） 
        viewportUnit: 'vw',    // 指定需要转换成的视窗单位，建议使用 vw 
        selectorBlackList: ['.ignore', '.hairlines'], // 指定不转换为视窗单位的类
        minPixelValue: 1,      // 小于或等于`1px`不转换为视窗单位
        mediaQuery: false      // 允许在媒体查询中转换`px` 
      }
    }
  }
  ```


# 三、Flex 布局
> 如果想让一个盒子变成弹性盒子可以用 `display: flex`，弹性盒子中有主轴(横轴row) 和副轴(纵轴column)，可以根据需要设置盒子的容器(父元素)和项目(子元素)。

## 基础属性
  ```scss
  // 容器属性
  .parent{
    display: flex;

    // 元素排列方向(左右和上下)，切换主副轴
    flex-direction: row | row-reverse | column | column-reverse;

    // 是否换行：reverse 往上一行换行
    flex-wrap: nowrap | wrap | wrap-reverse;

    // 复合属性，无顺序关系
    flex-flow: flex-direction flex-wrap; 

    // 副轴上(即子项垂直) 的对齐方式
    align-items: stretch | flex-start | flex-end | center | baseline;

    // 主轴上(即子项水平) 的对齐方式
    justify-content: flex-start | flex-end | center | space-between | space-around;

    // 多行垂直(副轴) 对齐方式, 默认 stretch
    align-content: flex-start | flex-end | center | space-between | space-around;
  }

  // 项目属性
  .child{
    // 定义排列顺序, 数字越大越靠后(可为负值)
    order: number;

    // 定义放大比例 (单行有多余空间时)
    flex-grow: number;

    // 定义缩小比例 (单行空间不足时)    
    flex-shrink: number;

    // 设置主轴上项目宽度(建议代替宽度)   
    flex-basis: %/px/rem;

    // 前三者复合属性，默认0 1 auto; 
    flex: grow [shrink] [basis];

    // 定义项目自己的对齐方式，可覆盖 align-items
    align-self: stretch | flex-start | flex-end | center | baseline;
  }
  ```


## 布局实例

  ```scss
  // div.box、span.item
  .box-1 {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .box-2 {
    display: flex;
    justify-content: space-between;
  }

  .box-3 {
    display: flex;
    .item:nth-child(2) {
      align-self: center;
    }
    .item:nth-child(3) {
      align-self: flex-end;
    }
  }

  .box-4 {
    display: flex;
    flex-flow: row-reverse wrap;
    justify-content: space-between;
    align-content: space-between;
  }

  // div.box、div.column 分别两个 span.item
  .box-5{
    display: flex;
    flex-wrap: wrap;
    align-content: space-between;

    .column{
      flex-basis: 100%;
      display: flex;
      justify-content: space-between;
    }
  }

  .box-6 {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-content: space-between;
  }
  .box-7 {
    display: flex;
    flex-flow: column wrap;
    justify-content: space-between;
    align-content: space-between;
  }

  // div.column 分别包含 2、1、3 个子元素
  .box-8{
    display: flex;
    flex-wrap: wrap;
    align-content: space-between;

    .column{
      flex-basis: 100%;
      display: flex;
      justify-content: space-between;
    }
    .column:nth-child(2){
      justify-content: center;
    }
  }
  ```

  <div align="center"> 
    ![flex 布局](/images/mobile/flex.png)
  </div>


## 网格布局
> 平均分布，即在容器里面平均分配空间

  ```scss
  // 几个子元素就平分几份
  .box{
    display: flex;
    .item{
      flex: 1;
    }
  }

  // 某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间
  .box{
    display: flex;
    .item{
      // flex: 1 1 0%;
      flex: 1;

      &.fixed{
        flex: 0 0 20%;
      }
    }
  }
  ```


## 圣杯布局

  ```scss
  body{
    display: flex;
    min-height: 100vh;
    flex-direction: column;

    header, footer {
      flex: 1;
    }

    .content{
      flex: 1;
      display: flex;
      
      .main{
        flex: 1;
      }
      .left, .right{
        // 两个边栏的宽度设为 12em
        flex: 0 0 12em;
      }
      .left{
        order: -1;
      }
    }
  }

  // 小屏幕时内容区三栏自动变为垂直叠加
  @media (max-width: 768px) {
    .content {
      flex-direction: column;
      flex: 1;

      .left, .main, .right {
        flex: auto;
      }
    }
  }
  ```

  <div align="center"> 
    ![圣杯布局](/images/mobile/grail.png)
  </div>



## 流式布局
> 每行的项目数固定，会自动分行

  ```scss
  .parent {
    width: 200px;
    height: 150px;
    background-color: black;
    display: flex;
    flex-flow: row wrap;
    align-content: flex-start;
  }

  .child {
    box-sizing: border-box;
    background-color: white;
    flex: 0 0 25%;
    height: 50px;
    border: 1px solid red;
  }
  ```


## 固定底栏
> 页面内容太少时底栏会抬高到页面的中间，移动端 fixed 定位会导致输入内容的虚拟键盘会导致定位元素错位等问题

  ```scss
  body{
    display: flex;
    height: 100vh;
    flex-direction: column;

    // header、footer、div.content
    .content{
      flex: 1;
      width: 100%;
      height: auto;
      overflow-y: scroll;
      -webkit-overflow-scrolling: touch;
    }
  }

  // 隐藏滚动条
  ::-webkit-scrollbar{  
      width: 0px; 
      height: 0px;
      background-color: #fff;  
  }

  // absolute 方式
  .box{
    position: relative;
    height: 100%;

    .content{
      position: absolute;
      left: 0;
      right: 0;
      top: 100px;
      bottom: 100px;
      height: auto;
      overflow-y: scroll;
      -webkit-overflow-scrolling: touch;
    }
    footer{
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
    }
  }
  ```


## 样式布局

  ```scss
  // 输入框的前方添加提示，后方添加按钮
  .input-item{
    display: flex;
    input{
      flex: 1;
    }
  }

  // 主栏的左侧或右侧添加一个图片栏 (类似头像)
  .item{
    display: flex;
    align-items: flex-start;
    img{
      margin-right: 1em;
    }
    p{
      flex: 1;
    }
  }

  // 两端对齐，列不满时左对齐
  // 法一：如果每行有 n 项，则在最后添加 n-2 个空项
  ul {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    li {
      width: 30%;
      height: 50px;
      background-color: #f1f8ff;
      margin-bottom: 10px;
    }
    li.empty {
      width: 30%;
      height: 0px;
    }
  }
  // 法二；利用 after/before，适用于每行 3/4 项
  ul:after {
    display:block;
    content:"";
    width: 30%;
    height:0px;
  }
  ```


# 四、事件类型

## 分类

* __click__：单击事件。移动端中连续 click 的触发有 200~300ms 的延迟，延迟来自判断双击和长按，因为只有默认等待时间结束以确定没有后续动作发生时才会触发 click 事件。所以触摸事件反应更快，体验更好，也可以通过 fastclick 库解决延迟问题。
* __touch__：触摸类事件，分为四种触发方式：touchstart (触屏开始)、touchmove (拖拽)、touchend (触屏完成)、touchcancel (触屏取消)。触屏时如果有更高级别的事件发生，比如电话接入或弹出信息等，则触发 ontouchcancel 事件。
* __gesture__：手势类事件，可分为三种：gesturestart (两/多根手指按下时)、gesturechange (两/多根手指按下且移动时)、gestureend (倒数第二根手指移开时)。手势的专有属性有：rotation (手指变化引起的旋转角度)、scale (手指之间的距离)。
* __tap__：触碰类事件，一般用于代替 click 事件，分为四种：tap (手指触碰屏幕)、longTap (手指长按屏幕)、singleTap (手指单击屏幕)、doubleTap(手指双击屏幕)。
* __swipe__：滑动事件，分为五种：swipe (滑动手指)、swipeLeft (左滑)、swipeRight (右滑)、swipeUp (上滑)、swipeDown (下滑)。


## 触发

### 触发顺序
  ```js
  // 查看顺序：ontouchstart、ontouchmove、ontouchend、onclick
  addEvent(dom, 'tap click touchstart touchmove', false)

  function addEvent(dom, type, showAll) {
    type = type.split(' ')

    type.forEach(function(item) {
      dom.addEventListener(item, function(v) {
        console.log(showAll ? v : v.type)
      })
    })
  }
  ```


### 事件对象

  * 获取：box.addEventListener("touchstart", function(event){ },true)。
  * 属性
    * touches：当前跟踪的触摸操作的 touch 对象的数组。
    * targetTouches：特定于事件目标的 touch 对象数组 (事件冒泡指出目标对象)。
    * changedTouches：表示自上次触摸以来发生了什么改变的 touch 对象的数组。
  * 特点
    * touchend 事件时 touches、targetTouches 信息会被删除，changedTouches 保存最后一次的信息，最好用于计算手指信息。
    * 通过 jquery 不能获取以上三个属性，而通过 zepto.js (精简版的 jquery，现在用的不多) 可以正常获取。


## 问题方案

### click 延迟
> 原因：移动端浏览器会优先判断用户是否要触发双击缩放、双击滚动等默认行为，用户碰触页面后需要等待 300ms 左右来判断是不是双击动作而不是立即响应。

  * 设置 device-width：`meta name="viewport" content="width=device-width"`。
  * 禁用缩放：`meta name="viewport" content="width=device-width, user-scalable=no"`。
  * FastClick：`import fastclick from 'fastclick'、fastclick.attach(document.body)`。
  * CSS touch-action：`touch-action: none`，表示在该元素上的操作不会触发用户代理的任何默认行为。


### 点击穿透
> 原生 touch 事件、框架的自定义 tap 事件都存在该问题，因为 touch 系列事件发生大约 300ms 后才会触发 click 事件。

  * 出现问题
    * 点击蒙层上的关闭按钮，蒙层消失后发现触发了按钮下面元素的 click 事件，如果有 a 标签则会触发页面跳转。
    * 直接点击页面内按钮跳转至新页面，然后发现新页面中对应位置元素的 click 事件被触发。
  * 解决方案
    * 不要混用 touch、click：只用一种事件就不会存在点击穿透问题。
    * fastclick：引入库之后把页面内所有 touch 事件都换为 click。
    * 阻止默认：`<div class="mask" @touchmove.prevent></div>、<div ontouchend = "e.preventDefault()"></div>`。


### touch、mouse
  <div style="text-indent: 2em">移动端中只有触屏事件完成后再次触发时，才会触发上一个事件的 mouseout 事件。即系统会在手指提起的瞬间判断接收到事件的元素是否被改变，若没有改变则会按照 mousedown、mouseup、click 的顺序依次触发，反之不会触发。</div>
 

### 点击状态处理

  * hover 样式：移动端不可用。
  * touch 事件：动态增删 class 或绑定动画。
  * 激活状态：常用于 a、button 等元素的伪类 :active
    * js：`document.body.addEventListener('touchstart', fn)`
    * html：`body ontouchstart`
  * 点击高亮：`a { tap-highlight-color: transparent; }`


### touch、gesture
  * 当一个手指放在屏幕上时会触发 touchstart 事件，如果另一个手指又放到了屏幕上则会触发 gesturestart 事件，然后触发基于该手指的 touchstart 事件。
  * 如果两个手指在屏幕上滑动将会触发 gesturechange 事件，但只要有一个手指移开则会触发 gestureend 事件，然后又触发 touchend 事件。






