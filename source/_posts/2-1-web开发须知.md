---
title: web 开发须知
tags:
  - 项目开发
categories: 项目开发
top: false
keywords:
  - 前端开发
date: 2019-02-17 15:41:48
description: 前端技术栈、程序员网站、服务器、页面渲染、框架模式、<br/>浏览器渲染机制、JS 运行机制、项目开发规范、H5 性能优化
---

# 一、技术栈
> web 开发就是呈现用户可理解的界面并响应用户操作。

## 基础技能
  <div align="center">
  ![前端技能图](/images/web/technology.png)
  </div>


## 拓展技能
## wget 扒取网站源码
>  wget 是一个 Linux 用户用在命令行下下载文件的工具。

  * 下载命令：`wget -c -r -np -nc -L -k -p http://xxx.com`
    * -c：断点续传
    * -r：--recursive，指定递归下载
    * -np：--no-parent 不遍历父目录
    * -nc：--no-clobber  不重复下载
    * -L：递归时不进入其它主机
    * -k：--convert-links，将下载的 HTML 页面链接转换为本地链接
    * -p：--page-requisites，下载所有的图片等页面显示所需的内容
  * 下载 wget
    * mac：`brew install wget`
    * window：`https://eternallybored.org/misc/wget/`


# 二、学习网站       

## 基础
  * [印记中文](https://www.docschina.org/)：教程中文版
  * [站长工具](http://tool.chinaz.com/tools/openweb.aspx/)：代码整理和测试
  * [在线工具](http://tool.lu/)：代码处理工具合集
  * [码云](https://gitee.com/)：代码托管中文网站
  * [Github](https://github.com/)：代码托管全球网站
  * [Stack Overflow](https://stackoverflow.com/)：技术问答社区
  * [Learn Anything](https://stackoverflow.com/)：思维导图形式学习技术

## 提升
  * [百度脑图](http://naotu.baidu.com/)：思维导图          
  * [ProcessOn](https://slides.com/)：脑图工具         
  * [Slides](https://www.processon.com/)：WebPPT 编辑器        
  * [CanIuse](https://caniuse.com/)：浏览器兼容         
  * [Overapi](http://overapi.com/)：API速查手册  
  * [RunJS](https://runjs.cn/)：JS在线编辑和分享         
  * [Standardjs](https://standardjs.com/)：JS编码规范   
  * [Faviconer](https://www.favicon-generator.org/)：图标生成器                    

## 拓展
  * [零花钱](https://github.com/easychen/howto-make-more-money)：接单网站 
  * [Electron](https://electronjs.org/)：跨平台程序  
  * [.gitignore](https://github.com/github/gitignore)：不同语言项目 
  * [墨刀](https://modao.cc/)：在线制作移动应用原型 



# 三、服务器

## 分类
> 从硬件上来看，服务器是一台配置比较高的PC机器。但是从软件角度根据用途可分为 web 服务器、数据库服务器等，用来处理客户端请求的服务器有以下两种：
          
  * __web 服务器__：又称 HTTP 服务器，包括 Apache、Nginx 等。专注于处理 HTTP 协议、传递本地磁盘上的静态资源给客户端，常用于提供代理服务。
  * __应用服务器__：提供可以处理业务逻辑的方法，包括 WebLogic、Tomcat 等。常用来加载动态内容和处理响应数据并返回给客户端，但则只能访问其安装目录中的文件。


## 代理
  * __代理服务器__：一种具有转发功能的应用程序，扮演了服务器和客户端的中间人角色。接收客户端发送的请求并转发给服务器，同时接收服务器返回的响应并转发给客户端。
  * __正向代理__：隐藏了真实的客户端，客户端请求都被代理服务器代替去请求。比如翻墙的原理就是在国外搭建一台代理服务器，代理去访问国外网址并返回结果给国内客户端。
  * __反向代理__：隐藏了真实的服务端，反向代理服务器会帮客户端把请求转发到真实服务器。常用来做负载均衡，比如访问百度时会有很多服务器接收服务。
  * __应用__：web 项目开发时联合使用 apache + tomcat + nginx。访问静态、动态资源时使用 apache/tomcat 解析。nginx 作为反向代理服务器，同时支持高并发。

    
## 运行机制
  <div style="text-indent: 2em; margin-top: 15px;">Apache 等传统 Web 服务器采用了多线程模型，它会为每个客户端请求分配一个线程来同步执行 I/O 操作，系统通过线程池进行线程切换来减少时间开销。这种方式容易造成阻塞，而且浪费 CPU 和内存，当连接达到一定数量时可能会导致服务器耗光内存而崩溃，只适用于 异步操作较少但业务逻辑较复杂的应用。这就是 `线程驱动`。</div>
  

# 四、页面渲染
> 客户端是上网时使用的手机、电脑等机器，而服务器是性能较强大的机器，可保持长时间运行并保证可随时访问服务器上文件。

## 客户端渲染
  * __实现原理__：浏览器异步请求服务器获取数据，然后浏览器拼接 数据和模板文件 得到最终的 HTML字符串，最后直接解析并渲染到页面。
  * __优势__
    * 前后端分离设计，服务器只需要提供接口。
    * 一定程度上减少了服务器的压力，浏览器负责页面逻辑和渲染。
    * 页面切换速度快：传统网站中的不同页面切换是通过服务器加载一个新的页面、SPA 模型中是通过动态地重写部分页面实现局部刷新和懒加载。
  * __问题__
    * SEO：传统的搜索引擎只会从 HTML 中抓取数据，导致前端渲染的页面无法被抓取。
    * 首屏性能：用户首次加载页面时，需要先下载框架和应用程序的代码，然后再渲染页面。比如常用的 SPA 会把所有 JS 整体打包导致文件太大，页面加载时间较长而可能导致白屏问题，用户体验比较差。

## 预渲染
> 用来改善少数营销页面的 SEO 而无需使用 web 服务器实时动态编译 HTML。

  * __实现原理__：即在构建阶段简单地生成匹配特定路由的静态 html 文件，可以通过 webpack 的 prerender-spa-plugin 轻松添加。
  * __优缺点__：设置简单，并且可以将前端页面作为一个完全静态的站点。但是搜索引擎不能抓取到 网页内容和结构，而且不能插入动态数据。


## 服务端渲染
> 指传统的 ASP、Java 或 PHP 的渲染机制，是预渲染的升级机制。

  * __实现原理__：浏览器发起请求后，服务端将 数据和模板拼接生成的 html 字符串返回给浏览器，浏览器只是进行解析和渲染。
  * __优点__：更好的 SEO 而使搜索引擎爬虫可以抓取渲染好的页面、更少的客户端电量消耗、更快的内容到达时间 (服务端返回渲染好的 HTML)。
  * __缺点__：不利于前后端分离而开发效率低、更多的服务器端负载（CPU 和内存资源）、更复杂的开发和部署（兼容 Node 执行环境）。


## 同构渲染
> 在服务器和客户端都可以运行的代码程序叫 同构，注意需要兼容 Node.js 的执行环境。

  * __实现原理__：浏览器发起请求后，服务器返回数据和模板拼接生成的 html 字符串，浏览器将其插入到指定节点后渲染页面。
  * __优点__：提高首屏渲染性能而避免白屏问题、对搜索引擎友好而有助于 SEO、前后端共用一套 Node.js 代码而节省开发时间。
  * __缺点__：内存溢出、异步操作、大量计算和个性化缓存等性能、服务器端和浏览器的环境差异、复杂类型无法转义为字符串形式发送给前端


## 架构选择
  * 同构前一定要考虑到浏览器和服务器的环境差异，站在更高层面考虑
  * 对于需要做 SEO 的项目，如果是一个后台应用，则只要首页做一些静态内容宣导即可。如果是内容型网站，那么可以考虑专门做一些页面给搜索引擎。
  * 对于前端渲染首屏问题，我们可以采用分拆打包（路由库）、交互优化（加载动画）、部分同构（使用同构把菜单和页面骨架渲染出来） 等一些方式合理利用同构。



# 五、框架模式

  * __框架和库__
    * 类库：一个有组织的功能集合，用于提供特定功能的接口并被调用。
    * 框架：构建应用程序的整体架构，使开发者可以专注于逻辑处理而提高开发效率。
    * 联系：框架一般会集成大量库并在合适地方调用，有时称为库，区别在于思考角度。
  * __框架分类__
    * 可视化组件：Echarts。
    * UI 框架：Bootstrap、EasyUI、ElementUI。
    * JS 框架：jQuery、NodeJs、requirejs、VueJs、angularJS、reactJS。


## MVP
  * __实现思路__：切断 View 和 Model 的联系，让 View 只和 Presenter（原Controller）交互，减少在需求变化中需要维护的对象的数量，相比 MVC 成本更低而且更容易理解。
  * __缺陷__：最接近用户的界面是需要根据需求变化而频繁更改的。

  <div align="center">
    ![MVP](/images/web/mvp.png) 
  </div> 


## MTV
  * __实现思路__：Model 负责业务对象和数据库的关系映射(ORM)，Template 负责如何把页面展示给用户(html)，View 负责业务逻辑并在适当时候调用 Model和Template。此外，通过一个URL分发器将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template。

  <div align="center">
    ![MTV](/images/web/mtv.png)
  </div> 


## MVC
  * __实现思路__：所有的终端用户请求被发送到 Controller，Controller 依赖请求去选择加载哪个模型并附加到对应 View，最终 View 作为响应发送给终端用户。
  * __缺陷__：处理多数据和复杂业务时可能会变得非常混乱，因为很多 view 都具备修改多个 model 的能力。可以通过将多个 model 抽象为一个解决问题，但会造成代码冗余和多余的性能损耗。

  <div align="center"> 
    ![MVC](/images/web/mvc.png) 
  </div> 


## MVVM
> Vue 的官方架构模式，核心思想是双向绑定。

  * __实现思路__：View 接收用户交互请求并发给ViewModel --> ViewModel 操作 Model 数据更新 --> Model 更新后通知 ViewModel 数据化 --> ViewModel 更新 View 数据。这样开发者只需关注业务逻辑，不需要手动操作DOM和关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理，完美解决了复杂交互导致代码难以维护的问题。
  * __优点__：独立开发（可专注于业务逻辑和数据）、低耦合性（View 和 Model 相互独立）、可重用性（可让多个 View 重用一段视图逻辑）、方便测试（可测试 ViewModel，而 Controller 不可）。
  * __缺点__：调用复杂度增加、viewModel 会越来越庞大（逻辑多）、类会增多（每个VC都附带一个 viewModel）。

  <div align="center">
    ![MVVM](/images/web/mvvm.png)
  </div> 


## Flux
> React 官方提出的类似 MVC、MVVM 的一种架构模式而非具体架构，它根据__单向数据流__的核心思想提出了一些基本概念，所有框架都可以具体实现。

  * __Store__ 用来存放数据和处理 Action 来更新数据的具体方法，可以有多个。
  * __Action__ 本质是一个纯声明式的数据结构，只提供对事件的描述而没有处理逻辑。
  * __Dispatcher__ 用于接收所有 Action，然后分发 (dispatch) 事件改变 Store。

  <div align="center"> 
    ![Flux 模式](/images/react/flux.png)
  </div>


# 六、浏览器渲染机制
> 浏览器是 Html 解析和展示页面的工具，主要功能是将用户选择的 web 资源呈现出来。它需要从服务器请求资源并将其显示在浏览器窗口中，资源格式一般有 HTML、PDF、image 等。渲染引擎是用户直接相关并呈现用户所需页面的组成部分。

## 分层结构
> 浏览器的抽象分层结构图如下：

  * __用户界面__：用于和用户进行交互的功能组件，如地址栏、返回、前进按钮等。
  * __浏览器引擎__：用于查询和操作渲染引擎的界面。
  * __渲染引擎__：负责显示请求的内容，如果请求 HTML 则它解析 HTML、CSS 并显示。
  * __网络__：负责处理网络相关的事务，如 HTTP 请求等。
  * __UI 后端__：负责绘制提示框等浏览器组件，底层使用操作系统的用户接口。
  * __Js 解释器__：负责解析和执行 JavaScript 代码。
  * __数据存储__：负责持久存储 cookie 和缓存等应用数据。

  <div align="center"> 
    ![浏览器结构](/images/web/browserCom.png)
  </div>


## 多进程机制
> 浏览器是多进程的，每打开一个 Tab 页就相当于创建了一个独立的进程。浏览器由于系统给它的进程分配了内存等资源而可以运行。

### 进程和线程
> 进程里并发运行的线程会共享该进程下有限的内存地址空间，模式选择时注意运行模式必须确保同一进程里的线程不会相互影响。

  * 区分
    * __CPU__：工厂，是执行计算任务的计算机核心。
    * __进程__：工厂车间，是资源分配和独立运行的 CPU 最小单位，用来完成一个任务。
    * __线程__：车间工人，是可以独立运行的 CPU 最小单位，协同其它线程完成一个任务。
  * 模式
    * __单线程__：所有任务在主线程中排队执行。
    * __多线程__：任务在各个线程中独立执行而互不影响，同一进程下的所有线程共享变量。
    * __多进程__：多任务可以同时执行，各进程的变量互不影响，但消耗更多的内存等资源。
    * __协调机制__：防止进程之间、线程之间产生冲突，允许进程之间、线程之间共享资源。


### 多进程的优势
> 如果浏览器是单进程，则某个 Tab 页或插件崩溃了就会影响整个浏览器，用户体验不好。

  * 多进程充分利用多核优势。
  * 避免单个 page crash 影响整个浏览器。
  * 避免第三方插件 crash 影响整个浏览器。
  * 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性。


### 内部进程
  * __Browser 进程__：浏览器的主进程 (负责协调和主控)，只有一个。
    * 将渲染进程得到的内存中的 Bitmap，绘制到用户界面上。
    * 负责浏览器界面显示，与用户交互。如前进，后退等。
    * 负责各个页面的管理，创建和销毁其他进程。
    * 负责网络资源的管理、下载等。
  * __第三方插件进程__：每种类型的插件对应一个进程。
  * __GPU 进程__：用于 3D 绘制等，最多一个。
  * __Render 进程__：浏览器内核，内部是多线程的。
    * 功能：负责页面渲染、脚本执行、事件处理等。
    * 特点：默认每个 Tab 页面对应一个进程并互不影响。


### 浏览器内核的多线程

<div style="text-indent: 2em">由于 JavaScript 可以操作 DOM，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，`浏览器设置 GUI 渲染线程与 JS 引擎线程为互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。所以 JS 如果执行时间过长就会导致页面渲染加载阻塞。`</div>

  * __GUI 渲染线程__
    * 负责渲染浏览器界面，解析 HTML、CSS，构建 DOM、RenderObject 树等。
    * 当界面需要重绘 Repaint 或由于某种操作引发回流 reflow 时，该线程就会执行。
  * __JS 引擎线程__
    * 即 JS 内核，负责处理 Js 脚本程序。
    * 负责解析执行 Javascript 脚本代码。
    * 一直通过事件循环机制，查看并执行任务队列中的任务。
  * __事件触发线程__
    * 归属于浏览器而不是 JS 引擎，用来控制事件循环。
    * 某事件符合条件被触发时，该线程把事件添加到任务队列的队尾等待处理。
    * JS 引擎执行 setTimeOut、Ajax 等代码块时，会将对应任务添加到事件线程中。
    * 注意：由于 JS 的单线程，队列中的事件都需要排队等待 JS 引擎空闲时才去执行。
  * __定时触发器线程__
    * 计时完毕后，添加到事件队列中，等待 JS 引擎空闲时执行。
    * setInterval、setTimeout 所在线程，用来计时并触发定时。
    * 注意：W3C 规定 setTimeout 中低于 4ms 的时间间隔算为 4ms。
  * __异步 http 请求线程__
    * XMLHttpRequest 连接后是通过浏览器新开一个线程请求。
    * 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数再放入事件队列中等待 Js 引擎执行。


### 浏览器内核和 Browser 进程的通信
  1. Browser 进程收到用户请求，通过网络下载或本地加载获取页面内容。
  2. Renderer 进程的接口收到 Browser 进程传递的请求，然后交给渲染线程执行。
    1. 渲染线程收到请求后，加载网页并渲染网页。
    2. 渲染过程中可能需要 Browser 进程获取资源和需要 GPU 进程帮助渲染。
    3. 可能会有 JS 线程操作 DOM，这样可能会造成回流并重绘。
    4. Render 进程将渲染结果传递给 Browser 进程。
  3. Browser 进程接收到结果并将结果绘制出来。



## 渲染机制
> 即渲染引擎工作流，为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。相关事件：DOM 树构建完成时触发 DOMContentLoaded 事件，页面加载完成时触发 load 事件。

  1. __浏览器解析 url__
    1. 用户输入 URL，浏览器解析后获取主机名和端口号。
    2. 通过 DNS 查询将主机名转换成服务器 ip 的地址。
    3. 浏览器建立一条与目标服务器的 TCP 连接（三次握手）。
    4. 浏览器向服务器发送一条 HTTP 请求报文并获取服务器响应。
    5. 浏览器关闭连接并重复请求至资源全部加载后，解析文档内容并渲染到页面。
  2. __浏览器渲染__
    1. 解析 HTML 标记并构建 DOM 树。
    2. 解析 CSS 标记并构建 CSSOM 树。
    3. 根据 DOM、CSSOM 构建渲染树，节点是包含颜色等属性的渲染对象。
    4. 布局：根据渲染树进行布局，计算各个节点在页面的位置、大小等信息。
    5. 绘制：调用渲染对象的 paint 方法，将它们的内容显示在屏幕并绘制基础组件。
  3. __资源下载问题__
    * 图片下载不会产生阻塞。
    * css 下载时会阻塞渲染，但带有 media 属性除外：css 由单独的下载线程异步下载，加载时不会阻塞 DOM 树解析但会阻塞 render 树渲染。
    * 遇到 script 标签时，DOM 构建停止直到 js 脚本下载并执行完毕，此时浏览器一般会下载其他资源但不会解析。如果 js 中有对 CSSOM 的操作，还会先确保 CSSOM 已经被下载并构建。
  4. __重绘重排__
    * 重绘：简单外观的改变而不会影响布局，比如 outline、visibility、color。
    * 回流：布局或几何属性改变而重新计算布局，大部分都会会导致页面的重新渲染。
    * 关系：重绘不一定会引发回流，回流必定会发生重绘，它们都会重新生成渲染树。


## 优化方案

  * __CSS__
    * CSS 硬件加速。
    * 避免使用 table 布局。
    * 使用 transform 代替 top。
    * 尽可能在 DOM 树的最末端改变 class。
    * 避免使用 CSS 表达式，可能会引发回流。
    * 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
    * 使用 visibility 替换 display: none，前者引起重绘，后者引发回流。
    * 将动画效果应用到 position: absolute/fixed 的元素，避免影响其他布局。
  * __Javascript__
    * 避免频繁操作样式，修改 class 最好。
    * 避免频繁操作 DOM，合并多次修改为一次。
    * 避免频繁读取会引发回流/重绘的属性，将结果缓存。
    * 对具有复杂动画的元素使用绝对定位，使它脱离文档流。


# 七、JS 运行机制

## JS 解析引擎
  * __js 引擎__：能够读懂 JavaScript 代码并能准确运行出结果的一段程序。
  * __V8 引擎__：为了提高 JS 的运行性能，在运行之前会将JS编译为本地的机器码，然后再去执行机器码。底层采用 C/C++ 编写。
  * 对于 Java、C++、C 等静态语言处理上述事情的叫 __编译器__，而对于 JavaScript 这样的动态语言则叫做 __解释器__。区别：编译器是将源代码编译为另外一种代码（比如机器码或者字节码），而解释器是直接解析并将代码运行结果输出。


## JS 的单线程
> 单线程即 JS 引擎线程称为 __主线程__，处理耗时异步任务的其它线程称为 __工作线程__。

<div style="text-indent: 2em">`单线程是指浏览器中负责解释和执行 Js 代码的 JS 引擎线程只能有一个`，称为 `主线程`，所以同一时间只能执行一个任务，其他任务需要排队等待执行。之所以是单线程，是因为 JS 的主要用途是与用户互动和操作 DOM，多线程同时操作会带来复杂的同步问题。为了利用多核 CPU 的计算功能，HTML5 提出了 web worker 标准，允许 JS 脚本创建多个线程来处理耗时操作，但是 Worker 是 JS 引擎向浏览器申请开的子线程，它完全受主线程控制并且不能操作 DOM，所以这个新标准并没有改变JS单线程的本质。</div>
 
  * __WebWorker__
    * 特点：只属于某个页面，不会和其他页面的 Render 进程共享。
    * 创建：Chrome 会在 Render 进程中新建一个 Worker 线程来运行 js 程序。
  * __SharedWorker__
    * 特点：浏览器的所有页面共享。
    * 创建：Chrome 会创建一个新进程来运行 Js 程序，但是相同 Js 只存在一个 SharedWorker 进程而不管它被创建多少次。


## JS 任务
> 所有任务都是在主线程上执行，形成一个执行栈。产生场景有执行 js 代码、对用户操作作出反应、处理异步的网络请求。

  * __同步任务__：主线程的执行栈中排队执行的任务。
  * __异步任务__：添加到任务列队中延迟执行的任务。
    * __宏任务__：由事件触发线程维护宏任务队列。一次事件循环中只执行第一个，然后重新渲染页面。比如 script 代码块、setTimeout、setInterval、I/O、UI render。
    * __微任务__：JS 引擎线程负责维护微任务队列。一次事件循环中全部执行，在页面渲染之前完成。比如 Promise（async/await）、Object.observe、MutationObserver。
  * __常见异步任务__
    * __onclick 等事件的销毁函数__：当事件触发时，回调函数会被立即添加到任务队列中。由浏览器内核的 DOM Binding 模块处理。
    * __setInterval 等计时器__：当定时器时间到，就把该事件放到 任务队列中 等待处理。由浏览器内核的 timer 模块进行延时处理。
    * __Ajax 请求__：在网络请求完成返回之后，将回调函数添加到任务队列中。由浏览器内核的 network 模块处理。


  ```js
  var test = function(){

    // 同步任务
    console.log("start"); 

    // 异步宏任务
    setTimeout(function(){
        console.log("异步宏任务");
    }, 300);

    // 异步微任务
    Promise.resolve(42).then(value =>{
        console.log(value);
    })

    // 同步任务
    console.log("end");
  }
  test();
  ```


## JS 异步机制
> 处理耗时异步任务的线程运行机制。

### 同步和异步
<div style="text-indent: 2em;">公路上的多辆汽车按顺序运行，这时有车坏掉了。同步模式就是让故障车停在原地修理，后面的车就会被堵住无法行驶。异步模式则是把故障车辆推到应急车道修理，正常的车流不受影响，车修好之后从应急车道回到正常车道即可，唯一的影响就是过多的应急车道会打乱车流顺序。简单来说，`同步可以保证顺序一致但容易导致阻塞，异步可以解决阻塞问题但会改变顺序性。具体使用时，浏览器端的 Ajax 等耗时长的操作、服务器端的所有操作 都应该异步执行`，否则容易导致浏览器或服务器失去响应，因为执行环境是单线程的。</div> 

 * __同步模式__：所有任务在主线程的执行栈中排队等待。类似银行排队办业务，当前执行的耗时任务会阻塞后续代码的执行。
 * __异步模式__：本质是事件驱动模式，返回结果后通知调用。主线程执行同步任务，工作线程执行耗时异步任务。类似餐厅点餐，当前执行的任务不会阻塞后续代码的执行。


## 任务队列
> 一个 消息(事件) 的队列，具有先进先出的特点。

  * 解析异步操作后，相关的异步任务（ 事件、回调函数），就会被放到任务队列中，等待被处理。
  * 只有主线程中的任务全部执行完，任务队列中的异步任务才会被放到主线程的执行栈中开始执行。


## 事件循环 
> Event Loop，指主线程重复从任务队列中读取事件并执行的过程。

  * JS 会创建一个 类似 while(true) 的循环，每执行一次循环体的过程叫 tick。
  * 核心是循环查看任务队列中是都有待处理的事件，如果有：则取出，放到 js 主线程中执行。
  * JS 是运行在单线程上的，所以浏览器都会单独开启一个线程来处理事件消息的轮询，避免阻塞 js 的执行。


## 异步过程 
> 回调函数是被主线程延迟执行的代码，主线程执行的异步任务就是对应的回调函数。

  1. 主线程执行 __异步发起函数__，将异步任务转交给相应的工作线程。
  2. 主线程继续执行后面的其它代码，同时工作线程执行异步任务。
  3. 工作线程完成异步任务后，将调用 __回调函数__ 的事件添加到任务队列等待处理。
  4. 主线程空闲时，通过 __事件循环机制__ 从任务队列中读取事件，放入执行栈并依次执行。

  <div align="center"> 
    ![Ajax实现过程](/images/web/ajax-process.png) 
  </div>

  <div style="text-indent: 2em;">从生产者与消费者的角度看，异步过程是这样的：工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中。主线程不断地从消息队列中取消息并执行，当消息队列为空时主线程阻塞，直到消息队列再次非空。</div> 


## 异步执行机制
> 先主线程后异步任务队列、先微任务再宏任务。

  1. JS 引擎将所有操作分为 同步任务、异步任务。
  2. 同步任务进入主线程，然后直接按顺序执行。
  3. 异步任务进入工作线程，当满足触发条件后推入任务队列。
  4. 事件循环机制：主线程执行完所有同步任务之后空闲时，重复去任务队列中查看是否有可执行的异步任务，有则推入主进程的执行栈。
    1. 执行一个宏任务（栈中没有就从事件队列中获取）。
    2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中。
    3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）。
    4. 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染。
    5. 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从任务队列中获取）。

  
  <div align="center">
    ![js 执行机制](/images/web/js-run.png) 
  </div>


  ```js
  // 输出结果：1、7、6、8、2、4、3、5、9、11、10、12

  console.log('1');

  setTimeout(function() {
      console.log('2');
      process.nextTick(function() {
          console.log('3');
      })
      new Promise(function(resolve) {
          console.log('4');
          resolve();
      }).then(function() {
          console.log('5')
      })
  })
  process.nextTick(function() {
      console.log('6');
  })
  new Promise(function(resolve) {
      console.log('7');
      resolve();
  }).then(function() {
      console.log('8')
  })

  setTimeout(function() {
      console.log('9');
      process.nextTick(function() {
          console.log('10');
      })
      new Promise(function(resolve) {
          console.log('11');
          resolve();
      }).then(function() {
          console.log('12')
      })
  })
  ```

  1. __第一轮事件循环__
    * 整体 script 作为第一个宏任务进入主线程，执行 console.log 输出 1
    * setTimeout，其回调函数被分发到宏任务队列，记为 setTimeout1
    * process.nextTick()，其回调函数被分发到微任务队列，记为 process1
    * Promise、new Promise 直接执行输出 7。then 被分发到微任务队列，记为 then1
    * 第二个 setTimeout，其回调函数被分发到宏任务队列，记为 setTimeout2
    * 执行两个微任务 process1、then1 输出 6、8
    * 输出结果：1、7、6、8
  2. __第二轮事件循环__
    * 从宏任务 setTimeout1 开始，输出 2
    * process.nextTick()，同样将其分发到微任务队列，记为 process2
    * new Promise 立即执行输出 4，then 也分发到微任务队列，记为 then2
    * 执行两个微任务 process2、then2 输出 3、5
    * 输出结果：2、4、3、5
  3. __第三轮事件循环__
    * 此时只剩下 setTimeout2，执行输出 9
    * process.nextTick() 分发到微任务队列，记为 process3
    * new Promise 直接执行输出 11，then 分发到微任务队列，记为 then3
    * 执行两个微任务 process3、then3 输出 10、12
    * 输出结果：9、11、10、12



# 八、项目开发规范

## 代码规范工具
> EditorConfig 统一编辑器风格 (写代码前起作用)、Prettier 统一项目风格 (保存代码后起作用)，ESlint 实时检查代码。具体使用时可以体验区别：editorConfig、prettiter 空格分别设置为 4、2，则代码编辑时回车为 4 格，保存后变成 2 格。

  * __EditorConfig__：用于实现跨编辑器开发项目时保持一致的代码风格。需要编辑器插件 `EditorConfig for VS Code`、项目根目录配置文件 `.editorconfig`。
  * __Prettier__：用于格式化当前文件。需要编辑器插件 `Prettier-Code formatter`、项目根目录配置文件 `.prettierrc`。此外可以配置文件实现允许命令批量格式化多个文件、配置编辑器实现所有文件保存时自动格式化。
  * __ESlint__：代码静态分析工具，用于实时自动检查编写的代码是否符合规范。可以通过编辑器插件安装 `ESlint`、项目根目录配置文件 `.eslintrc`。
  ```
  # .editorconfig
  root = true

  [*]
  charset = utf-8
  indent_style = space
  indent_size = 2
  end_of_line = lf                    # 换行符格式
  insert_final_newline = true         # 是否在文件最后插入一个空行
  trim_trailing_whitespace = true     # 是否删除行尾的空格

  [*.md]
  max_line_length = 0                 # 强制在指定字符数之后换行
  trim_trailing_whitespace = false    # md 会用尾空格表示换行，不自动移除
  ```


## BEM 命名规范
> __块 block、元素 element、修饰符 modifier__，是由俄罗斯搜索引擎团队 Yandex 提出的一种 css 命名方案。主要用于团队开发的大型项目统一类名规范，它的主要特点有：`减少了命名冲突的可能性、增强了语义化` (包含模块路径和状态等信息)、`提高了可复用性` (scss 等编写代码方便)、`提升了 css 性能` (一类元素对应一个类名，减少了后代选择器的使用)。

  ```scss
  // BEM 命名约定
  .block { }              // 模块类名
  .block__element { }     // 模块中的元素类名
  .block--modifier { }    // 不同状态、版本的模块类名

  .c-row-age { }          // components/RowAge/index.js
  .cc-addable-block { }   // components/common/AddableBlock/index.js
  .cc-addable-block--disabled { }


  // Element UI 命名
  .el-input,
  .el-input__inner {  
      cursor: pointer;
  }
  .el-input.is-focus .el-input__inner {  
      border-color: $--input-focus-border;
  }
  .el-input__icon {
      transition: none;
  }
  .el-pagination--small {  
      .btn-prev,  
      .btn-next,  
      .el-pager li {    
          margin: 0 3px;   
          min-width: 22px;  
      }
  }
  ```


## Restful 风格接口
> Restful 是一种架构风格的规范和约束而并非标准，基于它设计的软件可以更简洁、更有层次、更容易实现缓存等机制，常用于客户端和服务器交互类的软件。常用架构以下：

  * __RESTful 架构__：面向资源的架构，即针对资源设计接口。客户端操作通过资源对应的 URL 进行操作，从而访问服务器端资源。
  * __SOA 架构__：面向服务的体系结构。SOA 将不同的功能组件视为一种服务并分别封装，降低了组件之间的耦合程度，增加了代码的复用程度。


### 特点
  * __资源__；作为资源的标识，比如 html / jpg / json。
  * __URI__：统一资源定位符，即每个 URI 对应一个特定资源。
  * __无状态__：所有资源都可以通过 URI 去定位，而不与其他资源产生耦合。
  * __统一接口__：数据元操作 CURD 分别对应 http 的 get、post、put、delete。


### URI 
  1. __区别 URL__
    * 联系：URL 是属于 URI 的一部分。
    * URI：统一资源定位符，对应具体的资源。
    * URL：统一资源标识符，对应具体的资源地址。
  2. __规范__
    * 不用大写
    * 用中杠 - 不用下杠 _ 
    * 参数列表要 encode
    * 名词表示资源集合，资源集合时使用复数形式如 zoos/1/animals。
    * 每个网址代表一种资源，所以网址中一般只能有名词并对应数据库的表格名。
  3. __版本__
    * API 的版本号应该放入到 URI，比如 /api.example.com/v1/zoos。
  4. __通信__
    * 前后端统一使用 json 数据。
    * 客户端通过 url 中的 `？& ,` 实现过滤、搜索等复杂操作。
    * 客户端通过 http 方法（`GET获取、POST新建、PUT更新、DELETE删除`）对应服务器端数据元操作 (`SELECT、CREATE、UPDATE、DELETE`)。



# 九、H5 性能优化

## 性能指标

### Http 相关

  * __Http 请求数量__：可通过雪碧图、js CSS 合并等方式控制数量。
  * __组件是否压缩__
    * 组件压缩是一种一种增加CPU压缩解压缩时间来减少网络传输消耗的办法。
    * 通过去掉 Js，CSS 的空格和回车进行压缩，然后经过 GZIP 压缩，效果较好。
    * 不要对图片音乐等资源设置压缩，因为它们已经被压缩，再次压缩徒增 CPU 负担。
  * __图片格式和大小__
    * 常见格式有 webp、jpg、png，一般 webp 的图片最小但存在兼容问题。
    * 获取图片尺寸时应考虑应用场景，比如移动设备使用多个尺寸而非通过代码缩放。
    * 图片已经被压缩，但可以通过 TinyPNG、Smush.it 等工具进一步压缩并且质量不变。
  * __CSS 放在顶部__
    * 如果网页是动态生成的，则 head 代码完成后就可以输出页面，这样浏览器就会更快地解析出来 head 中的内容并开始下载 CSS 文件资源。
    * css 放在底部会引起重新绘制，用户侧感受到闪屏的不好体验。
  * __JS 放在底部__
    * JS 下载时会引起两个问题：阻止网页内容的展示并阻止其他资源下载。
    * 各种资源的下载是并行的，根据不同域名不同浏览器内核并行数量不同，所以下载 js 时并行下载机制失效。
    * js 操作可能改变页面布局的操作，所以渲染引擎会等待 js 下载完成再开始渲染，用户侧页面加载时间会因为等待而变得更长。
  * __是否设置缓存__：Cache-Control
    * no-cache：请求或响应消息不能缓存。
    * no-store：防止重要的信息被无意的发布。
  * 避免非 200 返回值：返回状态码非 200 的请求没有意义。
  * __使用 CDN__
    * 解决因分布、带宽、服务器能力带来的访问延迟高问题，提供一系列加速解决方案。
    * CDN 内容分发网络将源站内容发布到最接近用户的边缘节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。


### 时间相关
  * __白屏时间__：用户首次看到网页有内容的时间，即第一次渲染流程完成时间。
  * __首屏时间__：用户看到第一屏，即整个网页顶部大小为当前窗口的区域，显示完整的时间。
  * __首资源下载时间__：从开始下载到第一个资源均下载完成的时间，不包括页面绘制时间。
  * __总资源下载时间__：从开始下载到所有资源均下载完成的时间，不包括页面绘制时间。
  * __用户可操作时间__：从页面开始加载到用户操作可响应的时间。


### WebView 相关
> android、IOS 上测试 H5 性能，测试员还应该关注因加载 H5 而引起的 app 常规性能指标。

  * __内存__：加载页面前后内存变化，可间接反映H5中资源数量和大小，如dom数量，图片大小。
  * __FPS__：帧率尤其在有视频和动画效果的H5中，测试员应该重点关注，防止严重的卡顿流出。
  * __CPU__：当页面中资源样式复杂，强调视觉效果时，测试员可观察CPU占用率来反映H5绘制质量。如果CPU长期处于高占用率，可考虑降低高计算量的视觉效果等手段。


## 测试工具

  * __抓包工具__：Fiddler、Charles。
  * __平台型工具__：Page Speed、PCAP Web Performance Analyzer、WebPagetest。

  <div align="center">
    ![前端性能测试工具](/images/web/performance.png) 
  </div> 


## 优化方案

### PC 端优化
  * css 尽量层次简单并放到 head。
  * 简化 DOM 结构，最好不深于六层。
  * 尽量缓存 DOM 查找，查找器尽量简洁。
  * 涉及多域名的网站，可以开启域名预解析。
  * 动画尽量使用在 绝对/固定 定位 的元素上。
  * 隐藏在屏幕外 或 页面滚动时，尽量停止动画。
  * DOM 操作尽量通过缓存减少次数，避免过度触发回流。
  * js 脚本放在页面 body 底部，减少对其他过程的阻塞。
  * Js 修改元素样式操作尽量减少，使用类名修改或动画操作样式。
  * 减少首次下载的文件数量大小，使用图片懒加载、js 按需加载等方式。


### 移动端优化
  * 不滥用 Float：渲染页面时计算量比较大。
  * 不滥用 Web 字体：需要下载、解析、重绘当前页面。
  * 不声明过多的 Font-size：会影响 CSS 树的效率。
  * 减少重绘和回流
    * 减少 drawImage。
    * 避免不必要的 DOM 操作。
    * 避免使用 document.write。
    * 尽量改变 class 而不是 Style。
  * 动画优化
    * 尽量使用 CSS3 动画：5 个以内的元素时。
    * 适当使用 Canvas 动画：5 个以上元素时。
    * 合理使用 requestAnimationFrame 动画代替 setTimeout。
  * GPU 加速
    * 注意过渡使用会引发手机过耗电增加。
    * 触发 GPU 渲染：transitions、3D transforms、Opacity、Canvas、WebGL、Video。
    

  <div align="center"> 
    ![移动端优化](/images/mobile/optimization.png) 
  </div>


