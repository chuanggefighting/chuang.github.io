---
title: Javascript 常用方法封装
tags:
  - Javascript
categories: Javascript
top: false
keywords:
  - js 方法
date: 2019-04-08 20:20:09
description: JS 算法类、页面功能类、数据处理类
---


# 一、JS 算法类
  * 排序算法
    * __冒泡排序__：比较任何两个相邻元素，如果第一个比第二个大则交换位置。元素向上移动到正确顺序，类似气泡上升至表面而得名。
    * __选择排序__：每次从元素中选出最小或最大值，存放在序列的起始位置，以此循环至排序完毕。
    * __插入排序__：将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，适用于少量数据的排序。
    * __归并排序__：将原始序列切分成较小的序列直到无法再切分，然后将小序列排序后归并成大序列，直到最后只有一个排序完毕的大序列。
    * __快速排序__：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行上述递归排序，以此达到整个数据变成有序序列。
  * 搜索算法
    * __顺序搜索__：让目标元素与列表中的每一个元素逐个比较，直到找出与给定元素相同的元素为止，缺点是效率低下。
    * __二分搜索__：在一个有序列表，以中间值为基准拆分为两个子列表，拿目标元素与中间值作比较从而再在目标的子列表中递归此方法，直至找到目标元素。
  * 其他
    * __贪心算法__：在对问题求解时，不考虑全局，总是做出局部最优解的方法。
    * __动态规划__：在对问题求解时，由以求出的局部最优解来推导全局最优解。
    * __复杂度__：一个方法在执行的整个生命周期所需要占用的时间、空间等资源。



## 冒泡排序
  ```js
  Array.prototype.bubbleSort = function() {
      for (let i = 0; i < this.length; i++) {
          for (let j = 0; j < this.length - 1 - i; j++) {
              if (this[j] > this[j + 1]) {
                  let temp = this[j]
                  this[j] = this[j + 1]
                  this[j + 1] = temp
              }
          }
      }
  }
  ```


## 选择排序
  ```js
  Array.prototype.selectionSort = function() {
      let indexMin
      for (let i = 0; i < this.length - 1; i++){
          indexMin = i
          for (var j = i; j < this.length; j++){ 
              if(this[indexMin] > this[j]) {
                  indexMin = j
              }
          } 
          if (i !== indexMin){
              let aux = this[i]
              this[i] = this[indexMin]
              this[indexMin] = aux
          }
      }
      return this
  }
  ```


## 插入排序
  ```js
  Array.prototype.insertionSort = function() {
      let j
      let temp
      for (let i = 1; i < this.length; i++) {
          j = i
          temp = this[i]
          while (j > 0 && this[j - 1] > temp) {
              this[j] = this[j - 1]
              j--
          } 
          this[j] = temp
          console.log(this.join(', '))
      }
      return this
  }
  ```


## 归并排序
  ```js
  Array.prototype.mergeSort = function() {
      const merge = (left, right) => {
          const result = []
          let il = 0
          let ir = 0
          while(il < left.length && ir < right.length) {
              if(left[il] < right[ir]) {
                  result.push(left[il++])
              } else {
                  result.push(right[ir++])
              }
          }
          while (il < left.length) {
              result.push(left[il++])
          }
          while (ir < right.length) {
              result.push(right[ir++])
          }
          return result
      }
      const mergeSortRec = array => {
          if (array.length === 1) {
              return array
          }
          const mid = Math.floor(array.length / 2)
          const left = array.slice(0, mid)
          const right = array.slice(mid, array.length)
          return merge(mergeSortRec(left), mergeSortRec(right))
      }
      return mergeSortRec(this)
  }
  ```


## 快速排序
  ```js
  Array.prototype.quickSort = function() {
      const partition = (array, left, right) => {
          var pivot = array[Math.floor((right + left) / 2)]
          let i = left
          let j = right
          while (i <= j) {
              while (array[i] < pivot) {
                  i++
              }
              while (array[j] > pivot) {
                  j--
              }
              if (i <= j) {
                  let aux = array[i]
                  array[i] = array[j]
                  array[j] = aux
                  i++
                  j--
              }
          }
          return i
      }
      const quick = (array, left, right) => {
          let index
          if (array.length > 1) {
              index = partition(array, left, right)
              if (left < index - 1) {
                  quick(array, left, index - 1)
              }
              if (index < right) {
                  quick(array, index, right)
              }
          }
      }
      quick(this, 0, this.length - 1)
      return this
  }
  ```


## 顺序搜索
  ```js
  Array.prototype.sequentialSearch = function(item) {
      for (let i = 0; i < this.length; i++) {
          if (item === this[i]) return i
      }
      return -1
  }
  ```


## 二分搜索
  ```js
  Array.prototype.binarySearch = function(item) {
      this.quickSort()
      let low = 0
      let mid = null
      let element = null
      let high = this.length - 1
      while (low <= high){
          mid = Math.floor((low + high) / 2)
          element = this[mid]
          if (element < item) {
              low = mid + 1
          } else if (element > item) {
              high = mid - 1
          } else {
              return mid
          }
      }
      return -1
  }
  ```


## 动态规划
> 美国硬币：d1=1, d2=5, d3=10, d4=25，如果要找36美分的零钱，我们可以用 1个25美分、1个10美分和1个便士（ 1美分)
最少硬币找零的解决方案是找到 n 所需的最小硬币数

  ```js
  class MinCoinChange {

    constructor(coins) {
      this.coins = coins
      this.cache = {}
    }

    makeChange(amount) {
      if (!amount) return []
      if (this.cache[amount]) return this.cache[amount]
      let min = [], newMin, newAmount
      this.coins.forEach(coin => {
          newAmount = amount - coin
          if (newAmount >= 0) {
              newMin = this.makeChange(newAmount)
          }
          if (newAmount >= 0 && 
                (newMin.length < min.length - 1 || !min.length) && 
                (newMin.length || !newAmount)) {
              min = [coin].concat(newMin)
          }
      })
      return (this.cache[amount] = min)
    }
  }
  const rninCoinChange = new MinCoinChange([1, 5, 10, 25])
  console.log(minCoinChange.makeChange(36)) // [1, 10, 25]

  const minCoinChange2 = new MinCoinChange([1, 3, 4])
  console.log(minCoinChange2.makeChange(6))  // [3, 3]
  ```


## 贪心算法
> 通过贪心算法得出上述解决方案

  ```js
  class MinCoinChange {

    constructor(coins) {
      this.coins = coins
    }

    makeChange(amount) {
      const change = []
      let total = 0
      this.coins.sort((a, b) => a < b).forEach(coin => {
          while ((total + coin) <= amount) {
            change.push(coin)
            total += coin
          }
      })
      return change
    }
  }
  const rninCoinChange = new MinCoinChange ( [ 1, 5, 10, 2 5])
  console. log (rninCoinChange. rnakeChange (36))
  ```



# 二、页面功能类


## 页面滚动
  ```js
  // 垂直滚动到页面指定位置
  export const  scrollAnimation = (currentY, targetY, dom) => {

    // 计算需要移动的距离
    let needScroll = targetY - currentY
    let _currentY = currentY

    // 注意 window 滚动
    dom = dom ? dom : 'window'
    
    setTimeout(() => {
        const dist = Math.ceil(needScroll / 10)
        _currentY += dist
        dom.scrollTo(_currentY, currentY)
        // 如果移动幅度小于十个像素，直接移动，否则递归调用，实现动画效果
        if (needScroll < 10 || needScroll > -10) {
            scrollAnimation(_currentY, targetY, dom)
        } else {
            dom.scrollTo(currentY, targetY)
        }
    }, 10)
  }
  ```


# 三、数据处理类

## URL 参数
  ```js
  export function getUrlKey(name) {
    return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.href) || [, ""])[1].replace(/\+/g, '%20')) || null
  }
  ```


## 计算日期
  ```js
  // 日期格式转换
  export function DateFormat (date, fmt = 'yyyy-MM-dd') {
    var o = {
      'M+': date.getMonth() + 1,   // 月份
      'd+': date.getDate(),        // 日
      'h+': date.getHours(),       // 小时
      'm+': date.getMinutes(),     // 分
      's+': date.getSeconds(),     // 秒
      'q+': Math.floor((date.getMonth() + 3) / 3), // 季度
      'S': date.getMilliseconds()  // 毫秒
    }
    if (/(y+)/.test(fmt)) {
      fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length))
    }
    for (var k in o) {
      if (new RegExp('(' + k + ')').test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length)))
      }
    }
    return fmt
  }

  // 获取几 天/年 后的日期
  export function getDateLater(type, num){
    let d = new Date();
    switch(type){
      case "day":
        d.setDate(d.getDate() + num)
        break
      case "year":
        d.setDate(d.getDate())
        d.setFullYear(d.getFullYear() + num)
        break
      default:
        break
    }
    return DateFormat(d)
  }
  ```


## 身份证信息
  ```js
  // 根据身份证号获取信息：性别、出生日期、年龄
  export function getIdentity(id){
      var result = {};
      var _birthDate;
      switch(id.length){
          case 18:
              _birthDate = {
                  year : id.substr(6, 4), 
                  month : id.substr(10, 2), 
                  date : id.substr(12, 2)
              };
              //第 17 位
              result['sex'] = parseInt(id.substr(16, 1))%2==0 ? "106001":"106002"; 
              break;
          case 15:
              _birthDate = {
                  year : "19" + id.substr(6, 2), 
                  month : id.substr(8, 2), 
                  date : id.substr(10, 2)
              };
              // 第 15 位
              result['sex'] = parseInt(id.substr(14, 1))%2==0 ? "106001":"106002";
              break;
          default:
              break;
      }
      var birthDate = new Date(Number(_birthDate.year),Number(_birthDate.month) - 1,Number(_birthDate.date));
      result['birthDay'] = DateFormat(birthDate)
          
      var _currDate = new Date();
      if(Number(_birthDate.month) - 1 < _currDate.getMonth()){
        result['age'] = _currDate.getFullYear() - birthDate.getFullYear();
      }else if(Number(_birthDate.month) - 1 == _currDate.getMonth()){
        if(Number(_birthDate.date) <= _currDate.getDate()){
          result['age'] = _currDate.getFullYear() - birthDate.getFullYear();
        }else{
          result['age'] = _currDate.getFullYear() - birthDate.getFullYear() - 1;
        }
      }else{
        result['age'] = _currDate.getFullYear() - birthDate.getFullYear() - 1;
      }
      return result;
  }
  ```


