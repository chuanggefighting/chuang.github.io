---
title: TypeScript 进阶语法
tags:
  - TypeScript
categories: TypeScript
top: false
keywords:
  - typescript
date: 2019-04-11 20:06:28
description: 类型方法、高级类型
---


# 一、类型方法

## 类型断言
  * 用来指定一个值的类型，注意指定的必须是其子类型，比如不能指定数字为 string。
  * 类似类型转换但并不进行数据检查和解构，它只在编译阶段起作用而运行时没影响。

  ```ts
  // 两种实现方式如下，注意使用 JSX 时只允许 as 语法
  let val: any = "hello";
  let len_1: number = (<string>val).length;
  let len_2: number = (val as string).length;

  // 实例：将一个联合类型的变量指定为一个更加具体的类型
  function getLength(something: string | number): number {
    // 类型断言不是类型转换，不能断言成一个联合类型中不存在的类型
    if ((<string>something).length) {
        return (<string>something).length;
    } else {
        return something.toString().length;
    }
  }
  ```


## 类型判断
  * typeof：判断变量类型。
  * instanceof：判断方法或接口类型。

  ```ts
  var s: string = 'great';
  console.log(typeof s === 'string');
  var a: A = new A();
  console.log(a instanceof A);
  ```


## 类型推论
> TS 会在没有明确的指定类型时推测出一个类型。

  ```ts
  // 报错：变量类型推断为 string
  let x = 3;
  x = '3';

  // 正确：变量类型推断为 any
  let y;
  y = 'seven';
  y = 7;

  // 最佳通用类型：根据赋值推论 (number | null)[]
  const x = [0, 1, null];

  // 上下文类型：根据变量所在位置的上下文进行推论
  window.onmousedown = function(mouseEvent: any) {
    // 编译通过，如果不指定 mouseEvent 类型则会报错
    console.log(mouseEvent.button);
  }
  ```


## 类型兼容性
> 基于结构子类型，而结构类型是一种只使用其成员来描述类型的方式，它与名义类型形成对比。在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明或类型名称来决定的，而结构性类型系统是基于类型的组成结构，它并不要求明确地声明。


### 基本规则
> 具有相同的属性：如果 x 要兼容 y，那么 y 至少具有与 x 相同的属性。

  ```ts
  // 基于结构类型系统的 TS 会检查成功，Java 则会报错
  interface Named {
    name: string;
  }
  class Person {
    name: string;
    age: number;
  }
  let p: Named;
  p = new Person();  // 正确
  ```


### 兼容性

  * 函数
    ```ts
    // 形参需要包含关系，参数名可以不相同
    let x = (a: number) => 0;
    let y = (b: number, s: string) => 0;
    y = x;    // 正确
    x = y;    // 报错

    // 返回类型需要被包含关系
    let x = ()=>({name: 'Alice'});
    let y = ()=>({name: 'Alice', age:20});
    y = x;    // 报错
    x = y     // 正确

    // 可选参数与必须参数可互换，剩余参数可看作无限个可选参数。

    // 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。
    ```
  * 枚举：枚举类型与数字类型兼容，不同枚举类型之间不兼容。
    ```ts
    enum Status { Ready, Waiting };
    enum Color { Red, Blue, Green };

    let status = Status.Ready;   // 0
    status = Color.Green;        // 报错
    ```
  * 类
    * 比较两个类类型的对象时，只会比较实例的成员而不比较静态成员和构造函数。
    * 类的私有成员和受保护成员会影响兼容性。当检查类实例的兼容时，如果目标类型包含一个私有成员或受保护成员，那么源类型必须包含来自同一个类的这个成员。这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。
    ```ts
    class Animal {
      feet: number;
      constructor(name: string, numFeet: number) { }
    }
    class Size {
      feet: number;
      constructor(numFeet: number) { }
    }
    let a: Animal;
    let s: Size;
    a = s;         // 正确
    s = a;         // 正确
    ```
  * 泛型：类型参数只影响使用其做为类型一部分的结果类型。
    ```ts
    interface NotEmpty<T> { 
      data: T;   // 注释掉则正确
    }
    let x: Empty<number>;
    let y: Empty<string>;

    x = y;       // 报错
    ```


### 子类型与赋值
> TS 有两种类型的兼容性：子类型与赋值。它们的区别在于，赋值扩展了子类型兼容，允许和 any 来回赋值，以及 enum 和对应数字值之间的来回赋值。实际上，类型兼容性是由赋值兼容性来控制的，包括 implements、extends 语句。


# 二、高级类型

## 交叉类型
> 通过 `&` 获取多个类型的并集，与继承的区别是继承可以有自己的属性而交叉没有。

  ```ts
  function extend<T, U>(first: T, second: U): T & U {
    const result = <T & U>{};
    for (let id in first) {
        (<T>result)[id] = first[id];
    }
    for (let id in second) {
      if (!result.hasOwnProperty(id)) {
          (<U>result)[id] = second[id];
      }
    }
    return result;
  }

  const x = extend({ a: 'hello' }, { b: 42 });

  // 现在 x 拥有了 a、b 属性
  const a = x.a;
  const b = x.b;
  ```


## 联合类型
> 通过 `|` 获取多个类型中的一个，具体类型需要等到赋值时根据类型推论的规则推断出。

  ```ts
  // 类型限定
  let a: number | string = "a";
  // 取值限定
  let b: "a" | "b" | "c";
  function fn(name: string, age: string | number){ }

  a = 'hello';
  a = 20        // 报错：已经推断出 string
  ```


## 索引类型
> 使用不存在的索引时会返回 undefined 而且没有约束，因此我们需要有对索引的约束。

  ```ts
  let obj = { a: 1, b: 2, c: 3 };

  // 不使用索引类型：
  function getValue(obj: any,keys: string[]){
    return keys.map(key => obj[key]);
  }
  console.log(getValue(obj,["c","f"]))  // 返回 undefined，没有约束

  // 使用索引类型：T[k][] 表示返回值必须是 obj 中的值组成的列表
  function getValue<T,K extends keyof T>(obj: T, keys: K[]): T[K][] { 
    return keys.map(key => obj[key]); // keys 中的元素只能是 obj 中的键
  }
  console.log(getValue(obj,["a","b"]));
  console.log(getValue(obj,["c","f"]));  // 报错
  ```

## 映射类型
> 从旧类型中创建新类型的一种方式，比如将接口中的所有成员变成只读、可选。

  ```ts
  interface Obj{
    a: string;
    b: number;
    c: boolean;
  }

  // 将所有属性变为只读，生成一个新接口
  type ReadonlyObj = Readonly<Obj>;
  type Readonly<T> = {
    readonly [P in keyof T]: T[P];
  }

  // 将所有属性变为可选
  type PartialObj = Partial<Obj>;
  type Partial<T> = {
    [P in keyof T]?: T[P];
  }

  // 获取原类型的子集：两个等同
  type PickObj = Pick<Obj,'a'|'b'>;
  interface PickObj {
    a: string,
    b: number
  }
  ```

## 条件类型
> 指由表达式所决定的类型，它使类型具有了不唯一性并增加了语言的灵活性。

  * 实例
    ```ts
    // 如果类型 T 可以被赋值给类型 U，name 结果就赋予 X 类型，否则赋予 Y 类型
    T extends U ? X : Y;

    type TypeName<T> =
      T extends string ? string :
      T extends number ? number :
      T extends boolean ? boolean :
      T extends undefined ? undefined :
      T extends Function ? Function :
      object;
    type T1 = TypeName<string>;   // 字符串类型
    type T2 = TypeName<string[]>; // object 类型
    type T3 = TypeName<Function>; // function 类型
    type T4 = TypeName<string | string[]>; // string、obj 的联合类型
    ```
  * 应用：类型的过滤
    ```ts
    type Diff<T, U> = T extends U ? never : T;

    // 作用是过滤掉第一个参数中的'a'。T5 为联合类型 'b' | 'c' 
    type T5 = Diff< 'a'|'b'|'c', 'a'|'e' >;

    // 解析过程
    Diff<'a', 'a'|'e'> | Diff<'b', 'a'|'e'> | Diff<'c', 'a'|'e'>
    never | 'b' | 'c'
    'b' | 'c'
    ```
  * TS 内置
    * `Exclude<T, U>`：从 T 中剔除可以赋值给 U 的类型。
    * `Extract<T, U>`：提取 T 中可以赋值给 U 的类型。
    * `NonNullable<T>`：从 T 中剔除 null、undefined。
    * `ReturnType<T>`：获取函数返回值类型。
    * `InstanceType<T>`：获取构造函数类型的实例类型。
    ```ts
    // "b" | "d"
    type T0 = Exclude<"a" | "b" | "c" | "d", "a" | "c" | "f">;

    // "a" | "c"
    type T1 = Extract<"a" | "b" | "c" | "d", "a" | "c" | "f">;

    // string | number
    type T3 = NonNullable<string | number | undefined>;
    ```


## 类型保护
> 为了确定联合类型中变量的类型，ts 对每个分支(共有成员)都进行判断并不断使用类型断言的方法是不可取的，通过类型保护机制可以实现：一次判断针对整个作用域/所有分支都有效。类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。

### typeof
> 用来判断变量是哪种原始类型：`typeof v === "typename"、typeof v !== "typename"`。

  ```ts
  function padLeft(val: string, padding: string | number) {
    if (typeof padding === 'number') {
        return Array(padding + 1).join(" ") + val;
    }
    if (typeof padding === 'string') {
        return padding + val;
    }
    throw  new Error(`Expected string or number, got '${padding}'`)
  }
  ```


### instanceof
> 通过构造函数来细化类型，它的右侧要求是一个构造函数，TS 将细化为：`类型不为 any 则返回构造函数的 prototype 类型、构造签名所返回的类型的联合`。

  ```ts
  interface Padder {
    getPaddingString(): string
  }

  class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
      return Array(this.numSpaces + 1).join(" ");
    }
  }

  class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
      return this.value;
    }
  }

  function getRandomPadder() {
    return Math.random() < 0.5 ?
      new SpaceRepeatingPadder(4) :
      new StringPadder("  ");
  }

  // 类型为 SpaceRepeatingPadder | StringPadder
  let padder: Padder = getRandomPadder();

  if (padder instanceof SpaceRepeatingPadder) {
      padder;   // 类型细化为 SpaceRepeatingPadder
  }
  if (padder instanceof StringPadder) {
      padder;   // 类型细化为 StringPadder
  }
  ```


### 自定义
> 定义一个类型保护只需要定义一个返回值是一个 类型谓词的函数。使用变量来调用自定义类型保护时，TS 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。

  ```ts
  // 不使用类型保护：不断使用类型断言
  let pet = getSmallPet();
  if ((<Fish>pet).swim) {
      (<Fish>pet).swim();
  }
  else {
      (<Bird>pet).fly();
  }

  // 类型保护：类型谓词为 pet is Fish (name is Type)
  function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
  }
  // 变量调用 isFish 时，TS 将变量缩减为那个具体的类型
  if (isFish(pet)) {  // if 分支：pet 是 Fish 类型
      pet.swim();
  }
  else {             // else 分支：pet 是 Bird 类型
      pet.fly();
  }
  ```


## 可以为 null 的类型
> TS 有两种特殊的类型 `null、undefined`，类型检查器默认它们可以赋值给任意类型。`--strictNullChecks` 标记可以解决此错误：当声明一个变量时，它不会自动包含 null、undefined，但是可以使用联合类型明确的包含它们：

  ```ts
  let s = 'foo';
  s = null;        // 报错

  let sn: string | null = 'bar';
  sn = null;       // 正确
  sn = undefined;  // 报错
  ```

### 可选参数/属性
> 使用 strictNullChecks 标记之后默认添加 `| undefined`。

  ```ts
  function f(x:number, y?: number) {
    return x + (y || 0);
  }
  f(1);
  f(1, undefined);
  f(1, null)  // 报错

  class C {
    a: number;
    b?: number;
  }
  let c = new C();
  c.a = undefined;   // 报错
  c.b = undefined;   // 正确
  ```

### 类型保护和断言
> 由于可以为 null 的类型是通过联合类型实现，那么需要使用类型保护来去除 null。如果编译器不能够去除 null/undefined，可以使用类型断言手动去除，语法 `identifier!` 表示从 identifier 的类型里去除了 null、undefined。

  ```ts
  // 使用类型保护来去除 null
  function f(sn: string | null): string {
    if (sn == null) {
        return "default";
    }
    else {
        return sn;
    }
  }
  // 简洁方式
  function f(sn: string | null): string {
    return sn || "default";
  }

  // 使用类型断言手动去除 null/undefined
  function fixed(name: string | null): string {
    function postfix(epithet: string) {
      // 去掉 ! 就会报错
      return name!.charAt(0) + '.  the ' + epithet;
    }
    name = name || "Bob";
    return postfix("great");
  }
  ```


## 类型别名
> 通过 type 创建来给一个类型起个新名字，常用于联合类型。它和接口的区别如下：

  * 类型别名不能使用 extends、implement。
  * 接口创建了一个新名字，可以在其他任何地方使用。类型别名并不创建新名字。
  * 如果无法通过接口描述一个类型而需要使用联合/元组类型，则一般可以选择类型别名。

  ```ts
  type Name = string;
  type NameResolver = () => string;
  type NameOrResolver = Name | NameResolver;
  function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    }
    else {
        return n();
    }
  }

  // 泛型
  type Container <T> =  {value: T};

  // 属性中引用
  type Tree <T> = {
    value: T;
    left: Tree <T>;   
    right: Tree <T>;
  }

  // 配合交叉类型使用
  type LinkedList <T> = T & { next: LinkedList <T> };
  interface Person {
    name: string
  }
  var people: LinkedList<Person>;
  var s = people.name;
  var s = people.next.name;

  // 报错：类型别名不能出现在声明右侧的任何地方
  type Yikes = Array<Yikes>;
  ```


## 字面量类型

  * 字符串字面量类型：可以指定字符串必须的固定值，还可以用于区分函数重载。
    ```ts
    // 实现类似枚举类型的字符串
    type Easing = "ease-in" | "ease-out" | "ease-in-out";
    class UIElement {
      animate(dx: number, dy: number, easing: Easing) {
        if (easing === "ease-in") {}
        else if (easing === "ease-out") { }
        else if (easing === "ease-in-out") { }
        else {
            // 抛出错误
        }
      }
    }
    let button = new UIElement();
    button.animate(0, 0, "ease-in");
    button.animate(0, 0, "uneasy");    // 报错

    // 区分函数重载
    function createElement(tagName: "img"): HTMLImageElement;
    function createElement(tagName: "input"): HTMLInputElement;
    function createElement(tagName: string): Element { }
    ```
  * 数字字面量类型
    ```ts
    // 直接使用
    function getNum(): 1 | 2 | 3 | 4 { }

    // 缩小调试 bug 的范围
    function foo(x: number) {
      if (x !== 1 || x !== 2) {
          // 报错：x 与 2 进行比较时值必须为 1，检查非法
      }
    }
    ```


## 可辨识联合
> 合并单例类型、联合类型、类型保护和类型别名来创建一个叫做 可辨识联合 的高级模式，它也称为 标签联合、代数数据类型。它在函数式编程很有用处。一些语言会自动地为你辨识联合，TS 则基于已有的 JS 模式。

  * 实现要素
    * 具有普通的单例类型属性：可辨识的特征。
    * 一个类型别名包含了那些类型的联合：联合。
    * 此属性上的类型保护。
    ```ts
    // 将要联合的接口：都有 kind 属性但有不同的字符串字面量类型
    interface Square {
      kind: "square";
      size: number;
    }
    interface Rectangle {
      kind: "rectangle";
      width: number;
      height: number;
    }
    interface Circle {
      kind: "circle";
      radius: number;
    }

    // 使用可辨识联合
    type Shape = Rectangle | Circle | triangle;
    function area(s: Shape) {
      switch (s.kind) {
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
      }
      // 报错：switch 没有包涵所有情况，没有处理 case triangle
    }
    ```
  * 完整性检查：没有涵盖所有可辨识联合的变化时让编译器通知
    * 法一：启用 `--strictNullChecks` 并指定一个返回值类型。
    * 法二：使用 never 类型，用来除去所有可能情况后剩下的类型。
    ```ts
    // 报错：TS 认为函数返回值为 number | undefined
    type Shape = Rectangle | Circle | triangle;
    function area(s: Shape): number {
      switch (s.kind) {
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
      }
    }

    // 报错
    function assertNever(x: never): never {
      throw new Error("Unexpected object: " + x);
    }
    function area(s: Shape) {
      switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
        default: return assertNever(s);
      }
    }
    ```



## 多态的 this 类型
> 表示某个包含类或接口的子类型，称为 `F-bounded 多态性`。它能很容易的表现连贯接口间的继承。

  ```ts
  class BasicCalculator {
    public constructor(protected value: number = 0) { }
    public currentValue(): number {
      return this.value;
    }
    public add(operand: number): this {
      this.value += operand;
      return this;
    }
    public multiply(operand: number): this {
      this.value *= operand;
      return this;
    }
    // other operations go here
  }

  let v = new BasicCalculator(2)
              .multiply(5)
              .add(1)
              .currentValue();
  ```












