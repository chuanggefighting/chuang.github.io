---
title: 面试题之提升篇
tags:
  - 面试
categories: 面试
top: false
keywords:
  - 面试
date: 2020-04-05 23:06:25
description: 源码实现、网络相关、设计模式、算法相关、Nodejs
---

# 一、源码实现

## 函数柯里化
> 指将多个参数的函数拆解为单一参数的多个函数的依次调用，即使用闭包返回一个延迟执行函数。优点是可以实现延迟计算和参数复用。

  ```js
  // 普通函数
  function add(a, b){
    return a+b
  }
  add(1, 2);
  // 柯里化实现
  const currying = x => {
    return y => { return x+y }
  }
  currying(1)(2)

  // 封装实现
  function curringAdd() {
    let args = [].slice.call(arguments, 0);
    
    function add() {
      args = [...args, [].slice.call(arguments, 0)];
      return add
    }
    
    add.toString = function() {
      return args.reduce((t, a) => t + +a, 0);
    }

    return add;
  }
  console.log(curringAdd(1)) // 1
  console.log(curringAdd(1)(2)(3))  // 6
  console.log(curringAdd(2, 6)(1))  // 9
  ```


## bind、call、apply

  ```js
  Function.prototype.MyCall = function (context) {
    const args = [...arguments].slice(1);

    context.fn = this;

    const result = context.fn(...args);
    delete context.fn;

    return result;
  }

  Function.prototype.MyApply = function (context) {
    const args = arguments[1] || [];

    context.fn = this;
    const result = context.fn(...args);
    delete context.fn;

    return result;
  }

  Function.prototype.MyBind = function (context) {
    const args = [...arguments].slice(1);

    return function () {
      context.MyApply(context, args);
    }
  }
  ```


## 模拟 new

  ```js
  function myNew(fn) {
    const newObj = Object.create(fn.prototype);
    result = fn.apply(newObj, [...arguments].slice(1));
    return typeof result === "object" ? result : newObj;
  }
  ```


## Proxy + Fetch 实现 axios

  ```js
  const fetch = require("node-fetch");

  const axiosOriginal = {
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
  };
  const axios = new Proxy(axiosOriginal, {
    set() {
      throw new Error("Can't set any property");
    },

    get(target, name) {
      const method = name.toLocaleUpperCase();
      if (target.methods.indexOf(method) === -1) throw new Error(`Can't support method ${method}`);
      return (url, options) => {
        return fetch(url, {
          method,
          ...options
        }).then(res => res.text())
      }
    }
  });

  axios.get("http://www.baidu.com").then(res => console.log(res));
  axios.post("http://www.baidu.com").then(res => console.log(res));
  ```


## Promise

  ```js
  const PENDING = "pending";
  const RESOLVED = "resolved";
  const REJECTED = "rejected";

  class MyPromise {
    constructor(fn) {
      this.state = PENDING;
      this.resolvedHandlers = [];
      this.rejectedHandlers = [];
      fn(this.resolve.bind(this), this.reject.bind(this));
      return this;
    }

    resolve(props) {
      setTimeout(() => {
        this.state = RESOLVED;
        const resolveHandler = this.resolvedHandlers.shift();
        if (!resolveHandler) return;

        const result = resolveHandler(props);
        if (result && result instanceof MyPromise) {
          result.then(...this.resolvedHandlers);
        }
      });
    }

    reject(error) {
      setTimeout(() => {
        this.state = REJECTED;
        const rejectHandler = this.rejectedHandlers.shift();
        if (!rejectHandler) return;

        const result = rejectHandler(error);
        if (result && result instanceof MyPromise) {
          result.catch(...this.rejectedHandlers);
        }
      });
    }

    then(...handlers) {
      this.resolvedHandlers = [...this.resolvedHandlers, ...handlers];
      return this;
    }

    catch(...handlers) {
      this.rejectedHandlers = [...this.rejectedHandlers, ...handlers];
      return this;
    }
  }

  MyPromise.all = function (promises) {
    return new MyPromise((resolve, reject) => {
      const results = [];
      for (let i = 0; i < promises.length; i++) {
        const promise = promises[i];
        promise.then(res => {
          results.push(res);
          if (results.length === promises.length) resolve(results);
        }).catch(reject);
      }
    });
  }

  MyPromise.race = function (promises) {
    return new MyPromise((resolve, reject) => {
      for (let i = 0; i < promises.length; i++) {
        const promise = promises[i];
        promise.then(resolve).catch(reject);
      }
    });
  }

  // promise.finally 实现
  Promise.prototype.finally = function (callback) {
    let P = this.constructor;
    return this.then(
      value  => P.resolve(callback()).then(() => value),
      reason => P.resolve(callback()).then(() => { throw reason })
    );
  };
  ```


## React

  1. React 实现主要分为 Component、Element。
  2. Component 属于 React 实例，创建实例的过程中会在实例中注册 state、props 属性，还会依次调用内置的生命周期函数。Component render 函数会返回一个 ElementObj / null。
  3. Element 对象分为原生 Element 对象和组件式对象，它们会被一起解析成虚拟 DOM 树，内部使用的 state、props 也会以 AST 的形式注入进去。
  3. 虚拟 DOM 树渲染前后会触发 componentWillMount、componentDidMount 等生命周期函数，解析完成后将被渲染成真实 DOM 树。
  4. 调用 setState 时会更新 Component state，并会触发内部的一个 updater。调用 render 会生成新的虚拟 DOM 树，利用 diff 算法对比后的醋最优方案去更新 DOM。


## Redux

  * __实现原理__：创建一个状态中心，通过纯函数来对其数据进行修改，然后将修改结果以发布订阅的方式通知到所有订阅者，从而达到一个共享状态的效果。
  * __核心__：函数式编程，使用无副作用的同步函数 action 来触发 reducer 对数据进行修改。
  * __创建函数__：createStore，这个函数的作用是创建一个 store 对象，关键步骤如下：
    * 1、将 reducer 利用闭包存储在函数内。
    * 2、导出 subscribe 函数，内部将订阅者添加到一个订阅者列表中并等待通知。
    * 3、导出 dispatch 函数，内部执行 reducer 函数并将 action 作为参数传入到 reducer。
    * 4、将 reducer 函数的返回结果存到 currentState，并通知所有订阅者 state 已更新。
    * 5、订阅者可以通过 getState 得到最新的 state。
  * __中间件原理__：Decorator 装饰器模式，将中间件通过装饰后返回一个增强型的 dispatch。
  * __redux-thunk 实现异步__：内部判断 action 的类型，是函数则将 dispatch 作为参数执行，action 函数决定何时（可能是异步操作后）执行 dispatch。


## new Vue 执行后

  1. new Vue 会调用 Vue 原型链上的 _init 方法对 Vue 实例进行初始化。
  2. 首先是 initLifecycle 初始化生命周期，对 Vue 实例内部的一些属性（如 children、parent、isMounted）进行初始化。
  3. initEvents，初始化当前实例上的一些自定义事件（Vue.$on）。
  4. initRender，解析 slots 绑定在 Vue 实例上，绑定 createElement 方法在实例上。
  5. 完成对生命周期、自定义事件等属性的初始化后，触发生命周期钩子 beforeCreate。
  6. initInjections，在初始化 data、props 之前完成依赖注入（类似于 React.Context）。
  7. initState，初始化 data、props，并对内部属性完成数据劫持，更新时触发回调。
  8. initProvide，对依赖注入进行解析。
  9. 完成对数据（state 状态）的初始化后，触发生命周期钩子 created。
  10. 进入挂载阶段，将 vue 模板语法通过 vue-loader 解析成虚拟 DOM 树，虚拟 DOM 树与数据完成双向绑定，触发生命周期钩子 beforeMount。
  11. 将解析好的虚拟 DOM 树通过 vue 渲染成真实 DOM，触发生命周期钩子 mounted。


## webpack 热更新原理

  1. 修改一个或多个文件时，文件系统会接收更改并通知 webpack。
  2. webpack 重新编译构建一个或多个模块，并通知 HMR（Hot Module Replacement） 服务器进行更新。
  3. HMR Server 使用 Websocket 通知 HMR runtime 需要更新，HMR runtime 通过 HTTP 请求更新 jsonp。
  4. HMR runtime 替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。


# 二、网络相关

## HTTP 状态码及其功能

  * 100~199：信息提示
  * 200~299：成功
  * 300~399：重定向
  * 400~499：客户端错误
  * 500~599：服务端错误
  * 200 成功
  * 204 无内容
  * 301 永久移动（回应 GET 响应时会自动将请求者转到新位置）
  * 304 未修改（协商缓存）
  * 400 Bad Request
  * 401 未授权
  * 403 服务器拒绝请求
  * 404 未找到
  * 409 请求发生冲突
  * 500 服务器内部错误
  * 502 错误网关
  * 503 服务不可用


## HTTPS 原理 (握手过程)
  1. 客户端使用 https 的 url 访问 web 服务器，要求与服务器建立 ssl 连接。
  2. web 服务器收到客户端请求后，会将网站的证书（包含公钥）传送一份给客户端。
  3. 客户端收到网站证书后会检查颁发机构和过期时间，没问题则随机生成一个秘钥。
  4. 客户端利用公钥将会话秘钥加密，并传送给服务端，服务端利用自己的私钥解密。
  5. 之后服务器与客户端使用秘钥加密传输。


## HTTPS 握手过程中，客户端验证证书的合法性
  1. 首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内。
  2. 浏览器开始查找操作系统中已内置的受新人的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发。
  3. 如果找不到，浏览器就会报错，说明浏览器发来的证书是不可信任的。
  4. 如果找到，浏览器就会从操作系统中取出颁发者 CA 的公钥（浏览器开发商一般会实现在内部植入常用认证机关的公开密钥），然后对服务器发来的证书里面的签名进行解密。
  5. 浏览器使用相同 hash 算法计算出服务器发送证书的 hash 值，然后与证书中签名做对比。
  6. 对比结果一致，则证明服务器发来的证书合法，没有被冒充。


## http2 多路复用

  * HTTP/1 每次请求都会建立一次 HTTP 连接，即 3 次握手和 4 次挥手，这个过程在一次请求过程中占用了较长时间，即使开启了 Keep-Alive 解决了多次连接的问题，但是依然有两个效率上的问题，一是串行的文件传输，二是连接数过多导致的性能问题。HTTP/2 的多路复用就是为了解决上述的两个性能问题。
  * HTTP/2 有两个重要概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
  * 多路复用，就是在一个 TCP 连接中可以存在多条流。即可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。


## HTTPS 中间人攻击
> https 协议由 http + ssl 协议构成。攻击的防范方法：服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性（HTTPS 只有信任了劫持者的 CA 证书才会被劫持）。中间人攻击过程如下：

  1. 服务器向客户端发送公钥。
  2. 攻击者截获公钥，保留在自己手上。
  3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
  4. 客户端收到伪造的公钥后，生成加密 hash（秘钥） 值发给服务器。
  5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
  6. 同时生成假的加密 hash 值，发给服务器。
  7. 服务器用私钥解密获得假秘钥。
  8. 服务器用假秘钥加密传输信息。


## token 加密
> JWT (JSON Web Token) 是一种用于通信双方之间传递安全信息的基于 JSON 的开放标准，常用于跨域身份验证。它可以通过 HMAC 算法或 RSA 公私秘钥生成签名，具有简洁 (数据量小)、自包含 (负载中包含了所有用户所需要的信息，避免了多次查询数据库) 的特点。JWT 加密的实现过程如下：

  1. 需要一个 secret（随机数）。
  2. 后端利用 secret 和加密算法（如：HMAC-SHA256）对 payload（如账号密码）生成一个字符串（token），然后返回前端。
  3. 前端每次 request 都在 header 中带上 token。
  4. 后端用同样的算法解密。


## 输入 URL 到页面加载的全过程

  1. 用户输入 URL，浏览器解析后获取主机名和端口号。
  2. 如果主机名是域名，则通过 DNS 查询获取主机 IP 地址。
  3. 浏览器建立一条与目标服务器的 TCP 连接（三次握手）。
  4. 浏览器向服务器发送一条 HTTP 请求报文并获取服务器响应。
  5. 浏览器关闭连接并重复请求至资源全部加载后，解析文档内容并渲染到页面。


## SSL 连接断开后如何恢复

  * __Session ID__：每次会话都有一个编号，当对话中断后重新连接时，只要客户端提供编号并且服务器有该编号的记录，则双方可以继续使用以前的密钥，而不用重新生成。
  * __Session Ticket__：服务器在上一次对话中发送给客户的。这个 ticket 是加密的并且只有服务器能够解密，里面包含了本次会话的信息，比如对话密钥和加密方法等。不管请求是否转移到其他服务器，服务器将 ticket 解密后，就能获取上次对话的信息而不用重新生成对话秘钥了。


## CDN 服务
> CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资源就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CDN 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时也减轻了源服务器的访问压力。CDN 访问过程如下：


  1. 用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址。
  2. LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)。
  3. ROOT DNS 将域名授权 dns 记录回应给 LocalDns。
  4. LocalDns 得到域名的授权 dns 记录后,继续向域名授权 dns 查询域名的 ip 地址。
  5. 域名授权 dns 查询域名记录后(一般是 CNAME )，回应给 LocalDns。
  6. LocalDns 得到域名记录后,向智能调度 DNS 查询域名的 ip 地址。
  7. 智能调度 DNS 根据一定的算法和策略(比如静态拓扑、容量等)，将最适合的 CDN 节点ip地址回应给 LocalDns。
  8. LocalDns 将得到的域名 ip 地址，回应给用户端。
  9. 用户得到域名 ip 地址后，访问站点服务器。
  10. CDN 节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)。


# 三、设计模式

## 简述设计模式及应用场景

### 组件协作
  1. Template Method 模式
    * 模式定义：定义一个操作中算法的骨架（稳定），将一些步骤（变化）延迟到子类。
    * 应用场景：React 生命周期。
  2. Observer 模式
    * 模式定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。
    * 应用场景：Redux 实现。
  3. Strategy 模式
    * 定义：定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展、子类化）。
    * 应用：国际化、多种输入一种输出。

### 单一职责
  1. Decorator 模式
    * 模式定义：动态（组合）地给一个对象增加额外功能，在增加功能方面比生成子类（继承）更加灵活（消除重复代码、减少子类个数）。
    * 应用场景：React 高阶组件、中间件。
  2. Bridge 模式
    * 模式定义：将业务功能与平台实现分离，使它们都可以独立变化。
    * 应用场景：组件组合功能。
    
### 对象创建
  1. Factory Method 模式
    * 模式定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟（目的：解耦，手段：抽象）到子类。
    * 应用场景：React.createElement(...)、gin.Default(...)
  2. Abstract Factory
    * 模式定义：提供一个接口，让该接口负责创建一系列相关或相互依赖的对象，无需指定他们具体的类。
    * 应用场景：SQL API 类有多个成员类，比如连接类、创建类、操作类，将这些组合起来放在一个 Factory 类中，由这个类完成多个成员类的创建工作。

### 对象性能
  1. Singleton 模式
    * 模式定义：保证一个类只有一个实例，并提供一个该实例的全局访问点。
    * 应用场景：游戏中的主角类实例。
  2. FlyWeight（享元模式）
    * 模式定义：运行共享技术有效地支持大量细粒度的对象。
    * 应用场景：对象池优化。

### 接口隔离
  1. Facade 模式
    * 模式定义：为子系统的一组接口提供一致（稳定）的界面，Facade 模式定义了一个方便子系统复用的高层接口。
    * 应用场景：各种硬件驱动。
  2. Proxy 模式
    * 模式定义：为其他对象提供一种代理以控制（隔离、使用接口）对这种对象的访问。
    * 应用场景：使用闭包导出方法（代理操作对象）。
  3. Adapter 模式
    * 模式定义：将一个类的接口转换为客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
    * 应用场景：Go 中的 http.ListenAndServe 所接受的结构体只需要实现 ServeHTTP 方法即可满足 http 的接口条件。
  4. Composite 模式
    * 模式定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）。
    * 应用场景：在树形结构中，Parent Node 和 Child Node 都继承于同一抽象类 Node，都使用 process 方法来执行自身的方法。


## 如何解决复杂问题
> 设计模式描述了一个不断发生的问题和解决方案的核心，可以重复使用而减少工作量。解决复杂问题时主要通过两个方面：分解 (将复杂问题简单化)、抽象 (忽略细节而处理抽象模型)。


## 白黑箱复用

  * 白箱复用：B 类继承 A 类的功能，同时了解 A 类的内部细节，从而达到复用的效果，耦合性较强。
  * 黑箱复用：B 类只需要关注 A 类所暴露的一些外部方法即可达到复用的效果，达到了解耦的效果。


## 观察者模式和订阅-发布模式
> 发布-订阅模式是观察者模式的一种变体，它只是把一部分功能抽象成一个独立的变更管理器。

  * 一对多时使用观察者模式，多对多时使用订阅-发布模式。
  * 观察者模式的主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知。


## 面向对象的设计原则

  * __依赖倒置原则__
    * 高层模块（稳定）不应该依赖低层模块（变化），两者都应该依赖于抽象（稳定）。
    * 抽象（稳定）不应该依赖于实现细节（变化），实现细节（变化）应该依赖于抽象（稳定）。
  * __开放封闭原则__
    * 对扩展开放，对更改封闭。
    * 类模块应该是可扩展的，但是不可修改。
  * __单一职责原则__
    * 一个类应该只有一个引起它变化的原因。
    * 变化的方向隐含了类的责任。
  * __Liskov 替换原则__
    * 子类必须能够替换他们的基类（IS-A）。
    * 继承表达类型抽象。
  * __接口隔离原则__
    * 不应该强迫客户端使用他们不用的方法。
    * 接口应该小而完备。
  * __优先使用对象组合，而不是类继承__
    * 类继承通常为白箱复用，对象组合通常为黑箱复用。
    * 继承在某种程度上破坏了封装性，子类父类耦合度高。
    * 对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。
  * __封装变化点__
    * 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
  * __针对接口编程，而不是针对实现编程__
    * 不将变量类型声明为具体的某个类，而是声明为某个接口。
    * 客户程序无需获取对象的具体类型，只需要知道对象所具有的接口。
    * 减少系统中的各部分依赖关系，从而实现高内聚、低耦合的类型设计方案。



# 四、算法相关

## 迭代方式实现 flatten 函数
> 迭代指按顺序访问数组、对象等的每一项 (查找、遍历)。

  ```js
  function flatten(arr) {
    for (let i = 0; i < arr.length; i++) {
      if (Array.isArray(arr[i])) {
        arr = arr.concat(arr[i])
        arr.splice(i, 1)
      }
    }
    return arr;
  }
  let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]]
  console.log(flatten(arr))
  ```

## 数组的随机排序

  ```js
  // 随机数排序
  function random1(arr) {
    return arr.sort(() => Math.random() - .5);
  }

  // 随机插入排序
  function random2(arr) {
    const cArr = [...arr];
    const newArr = [];
    while (cArr.length) {
      const index = Math.floor(Math.random() * cArr.length);
      newArr.push(cArr[index]);
      cArr.splice(index, 1);
    }
    return newArr;
  }

  // 洗牌算法，随机交换排序
  function random3(arr) {
    const l = arr.length;
    for (let i = 0; i < l; i++) {
      const index = Math.floor(Math.random() * (l - i)) + i;
      const temp = arr[index];
      arr[index] = arr[i];
      arr[i] = temp;
    }
    return arr;
  }
  ```


# 五、Nodejs

## 模块
> Node 中的每个文件模块都是一个对象，定义如下：

  ```js
  function Module(id, parent) {
    this.id = id;
    this.exports = {};
    this.parent = parent;
    this.filename = null;
    this.loaded = false;
    this.children = [];
  }
  module.exports = Module;
  var module = new Module(filename, parent);
  ```


## require 模块加载机制

  1. 计算模块绝对路径。
  2. 如果缓存中有该模块，则从缓存中取出该模块。
  3. 按优先级依次寻找并编译执行模块，将模块推入缓存（require.cache）。
  4. 输出模块的 exports 属性。


## 两个模块互相引用
> 假设 A、B 模块互相引用，此时运行 A 模块的话，先运行的 A 模块将会被缓存，但是此时缓存的是一个未执行完毕的 A 模块，而 A 模块中引入的 B 模块将会被完整加载并且正常使用，而 B 模块中调用的 A 模块将会是个默认的空对象（module.exports 的默认值），不具备 A 模块的任何功能。


## 异步 I/O

  * 进程启动时，Node 会创建一个类似于 while(true) 的循环，每执行一次循环体的过程成为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有就取出事件及其相关的回调函数。如果存在关联的回调函数就执行，然后进入下个循环，不再有事件处理时退出进程。（每个 Tick 都会把观察者中可执行的事件执行完毕后，再进行下一个 Tick）。
  * 事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，生产出的事件被传递到对应的观察者，事件循环从观察者取出事件并处理（消费者）。
  * 具体流程
    * 1、发起异步调用
    * 2、封装异步执行对象，设置回调函数和参数
    * 3、将异步执行对象推入线程池（主线程继续往下执行）
    * 4、异步执行对象执行完毕后，将执行结果连同线程一起交还给主线程。
    * 5、主线程的 Tick 检测到有执行完成的异步任务，取出对象并执行对应的回调函数。
    * 6、完成

  
  ```js
  // 简易型 tick

  const events = [];

  function observer() {
    setInterval(() => {
      console.log('checking...')
      if (events.length > 0) {
        const event = events.shift();
        event();
      }
    }, 50);
  }

  const fn = () => {
    console.log('event callback');
  }

  setInterval(() => {
    events.push(fn);
  }, 500);

  observer();
  ```


## Buffer
> Node 中用于处理二进制数据的类，其中与 IO 相关的操作（网络/文件等）均基于 Buffer。Buffer 类的实例非常类似于整数数组，但其大小是固定不变的，并且其内存在 V8 堆栈外分配原始内存空间。Buffer 类的实例创建之后，其所占用的内存大小就不能再进行调整。

## Stream
> Node 中处理流式数据的抽象接口，stream 模块用于构建实现了流接口的对象。Node 提供了 http 请求、process.stdout 等多种流对象。流可以是可读的、可写的、或者可读可写的，所有的流都是 EventEmitter 的实例。

## IPC
  * IPC 又称进程间通信技术，是用于 Node 内部父子进程之间进行通信的方法。
  * Node IPC 是通过不同平台的管道技术实现的，特点是本地网络通信、速度快、效率高。
  * Node 在启动子进程时，主进程先建立 IPC 通道，然后将 IPC 通道的 fd（文件描述符）通过环境变量（NODE_CHANNEL_FD）的方式传递给子进程，然后子进程通过 fd 与 父进程建立 IPC 连接。


## 实现热更新
> Node API require.cache，该对象引用被清除后重新调用时就会重新加载，这个机制可以用来热加载更新的模块。然后使用 fs.watchFile 监听文件的更改，文件更改后调用 clearCache 传入对应的模块名即可。使用 pm2 reload 可以实现暴力热更新，它会保证在新实例重启成功后才会把旧进程杀死，可以保持服务一直在可响应状态。

  ```js
  function clearCache(modulePath) {
    const path = require.resolve(modulePath);
    if (require.cache[path]) {
      require.cache[path] = null;
    }
  }
  ```


## 内存泄露问题
> 出现内存泄露问题时，需要检测内存使用情况并对内存泄露的位置进行定位，然后对相应代码进行修复。内存泄露的原因主要如下：

  * 闭包：如果闭包未释放，就会导致内存泄露。
  * 全局变量：全局变量挂在 root 对象上，不会被清除掉。
  * 事件监听：对同一个事件重复监听并忘记移除，将造成内存泄露。


## 垃圾回收机制
  * Node 的 js 脚本引擎是 Chrome 的 V8 引擎，所以属于 V8 的内部垃圾回收机制。V8 的垃圾回收机制根据对象的存活时间采用了不同的算法，使得垃圾回收更高效。
  * V8 内存分为新生代与老生代。
  * 对于新生代的内存采取的是将内存区一分为二，将存活的对象从一个区复制到另一个区，然后对原有的区进行内存释放，反复如此。当一个对象经过多次复制依然存活时，这个较长生命周期的对象会被移动到老生代中。
  * 对于老生代的垃圾回收采用的是标记清除算法，遍历所有对象并标记仍然存在的对象，然后在清除阶段将没有标记的对象进行清除，最后将清除后的空间进行内存释放。


## Node 更适合处理 I/O 密集型任务还是 CPU 密集型任务

  * Node 更适合处理 I/O 密集型的任务。因为 Node 的 I/O 密集型任务可以异步调用，利用事件循环的处理能力，资源占用极少，并且事件循环能力避开了多线程的调用，在调用方面是单线程，内部处理其实是多线程的。
  * 由于 JS 是单线程，Node 不适合处理 CPU 密集型的任务，CPU 密集型的任务会导致 CPU 时间片不能释放，使得后续 I/O 无法发起，从而造成阻塞。但是可以利用到多进程的特点完成对一些 CPU 密集型任务的处理，不过由于 JS 并不支持多线程，所以在这方面的处理能力会弱于其他多线程语言（例如 Java、Go）。


## Node 为何不给每个 js 文件以独立的上下文来避免作用域被污染
> Node 模块正常情况下对作用域不会造成污染（模块函数内执行），意外创建全局变量是一种例外，可以采用严格模式来避免。

  ```js
  function fn() {
    a = 1;
  }

  fn();

  var b = 10;

  console.log(a); // 1
  console.log(this.a); // undefined
  console.log(global.a); // 1 意外的全局上下文污染

  console.log(b); // 10
  console.log(this.b); // undefined
  console.log(global.b); // undefined
  ```


## console.log 是同步还是异步? 
> 内部实现是 process.stdout，将输入内容打印到 stdout，同步异步取决于 stdout 连接的数据流的类型（需要写入的位置）以及不同的操作系统。造成这种差异的原因是因为一些历史遗留问题，不过这个问题并不会影响正常的输出结果。

  * 文件：Windows、POSIX 同步。
  * TTY（终端）：Windows 异步，POSIX 同步。
  * 管道（和 socket）：Windows 同步，POSIX 异步。


## 父/子进程的死亡有何影响

  * 子进程死亡不会影响父进程，不过子进程死亡时会向它的父进程发送死亡信号。反之父进程死亡，一般情况下子进程也会随之死亡，但如果此时子进程处于可运行状态、僵死状态等等的话，子进程将被 init 进程手痒，从而成为孤儿进程。
  * 子进程死亡时（处于“终止状态”），父进程没有及时调用 wait() 或 waitpid() 来返回死亡进程的相关信息，此时子进程还有一个 PCB 残留在进程表中，被成为僵尸进程。


## 守护进程
> 不依赖终端 (tty) 的进程，不会因为用户退出终端而停止运行的进程。实现思路如下：

  1. 创建一个进程 A。
  2. 在进程 A 中创建进程 B，可以使用 child_process.fork 或其他方法。
  3. 启动子进程时，设置 detached 属性为 true，保证子进程在父进程退出后继续运行。
  4. 进程 A 退出，进程 B 由 init 进程接管。此时进程 B 为守护进程。


## 粘包问题
> 默认情况下，TCP 连接会采用延迟传送算法（Nagle 算法），在数据发送之前缓存他们。如果短时间有多个数据发送，会缓冲到一起作一次发送（缓冲大小是 socket.bufferSize），这样可以减少 IO 消耗提高性能。（TCP 有这个问题，HTTP 协议已解决）。解决方法如下：

  * 多次发送之前间隔一个等待时间：处理简单，但是影响传输效率。
  * 关闭 Nagle 算法：消耗资源高，整体性能下降。
  * 封包/拆包：使用一些有标识来进行封包拆包（类似 HTTP 协议头尾）。


## cookie、session

  * session 存在服务端，cookie 存在客户端。session 比 cookie 更安全，而且 cookie 不一定一直能用（可能被浏览器禁止）。服务端可以通过设 cookie 的值为空并设置一个及时的 expires 来清除存在客户端上的 cookie。
  * cookie 可能会包含一些关键信息，而 session 一般都是一个加密串。


## hosts 文件
> 一个没有扩展名的系统文件，作用是将网址域名和对应的 IP 地址建立一个关联“数据库”。当用户在浏览器中输入一个 url 时，系统会先从 hosts 文件中寻找对应的 IP 地址。











